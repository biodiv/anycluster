{"mappings":"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","sources":["src/anycluster-openlayers.ts"],"sourcesContent":["import {\n    AnyclusterClient,\n    AnyclusterClientSettings,\n    Viewport,\n    Cluster,\n    ClusterMethod,\n    GeoJSON as IGeoJSON,\n} from 'anycluster-client';\n\nexport {\n    ClusterMethod\n};\n\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\nimport { Icon, Stroke, Style, Fill } from 'ol/style';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport Feature from 'ol/Feature';\nimport Point from 'ol/geom/Point';\n\ninterface ExtendedFeature extends Feature {\n    x: number\n    y: number\n    count: number\n    clustertype: string\n}\n\nexport class AnyclusterOpenLayers extends AnyclusterClient {\n\n    currentZoom: number\n\n    constructor(map: any, apiUrl: string, markerFolderPath: string, settings: AnyclusterClientSettings) {\n        super(map, apiUrl, markerFolderPath, settings);\n        this.currentZoom = this.getZoom();\n    }\n\n\n    removeArea() {\n        if (this.map.hasOwnProperty(\"areaLayer\")) {\n            this.map.areaLayer.getSource().clear();\n        }\n    }\n\n    getAreaStyle(feature: Feature, resolution: number): Style {\n\n        const style = new Style({\n            stroke: new Stroke({\n                color: \"rgba(255, 0, 0, 1)\",\n                width: 2,\n            }),\n            fill: new Fill({\n                color: \"rgba(255, 0, 0, .3)\",\n            }),\n        });\n\n        return style;\n    }\n\n    addArea(geojson: IGeoJSON) {\n        if (!this.map.hasOwnProperty(\"areaLayer\")) {\n            this.createAreaLayer();\n        }\n\n        const features = new GeoJSON({\n            featureProjection: \"EPSG:3857\"\n        }).readFeatures(geojson);\n\n        \n        this.map.areaLayer.getSource().addFeatures(features);\n\n    }\n\n    createClusterLayers() {\n\n        const gridClusterLayer = new VectorLayer({\n            source: new VectorSource(),\n            style: this.getCellStyle.bind(this) as any,\n        });\n\n        this.map.addLayer(gridClusterLayer);\n        this.map.gridClusterLayer = gridClusterLayer;\n\n        const kmeansLayer = new VectorLayer({\n            source: new VectorSource()\n        });\n\n        this.map.addLayer(kmeansLayer);\n        this.map.kmeansLayer = kmeansLayer;\n\n        this.map.on(\"click\", (event: any) => {\n\n            let hit = false;\n\n            this.map.forEachFeatureAtPixel(event.pixel, (feature: ExtendedFeature) => {\n\n                if (hit == false){\n\n                    if (feature.clustertype == \"cell\" || feature.clustertype == \"marker\"){\n                        hit = true;\n                        let zoom = this.getZoom();\n\n                        if (zoom >= 13 || feature.count == 1) {\n                            this.onMarkerFinalClick(feature);\n                        }\n\n                        else {\n                            this.markerClickFunction(feature.x, feature.y);\n                        }\n                    }\n                }\n            });\n        });\n\n        this.map.on(\"pointermove\", (event: any) => {\n            let pixel = this.map.getEventPixel(event.originalEvent);\n            let hit = this.map.hasFeatureAtPixel(pixel);\n            this.map.getViewport().style.cursor = hit ? 'pointer' : '';\n        });\n    }\n\n    createAreaLayer() {\n\n        const areaLayer = new VectorLayer({\n            source: new VectorSource(),\n            style: this.getAreaStyle.bind(this) as any,\n        });\n\n        const layers = this.map.getLayers();\n        layers.insertAt(2, areaLayer);\n        //this.map.addLayer(areaLayer);\n        this.map.areaLayer = areaLayer;\n    }\n\n    getMarkerIcon(cluster: Cluster) {\n\n        const piniconObj = this.selectPinIcon(cluster);\n\n        const icon = new Icon({\n            anchor: piniconObj.relativeAnchor,\n            crossOrigin: \"anonymous\",\n            src: piniconObj.url,\n            imgSize: piniconObj.size,\n            size: piniconObj.size\n        });\n\n        const style = new Style({\n            image: icon\n        });\n\n        return style;\n          \n    }\n\n    drawMarker(cluster: Cluster) {\n\n        const style = this.getMarkerIcon(cluster);\n        const point = new Point([cluster.center.x, cluster.center.y])\n\n        let marker = new Feature(point);\n\n        marker.setStyle(style);\n\n        let extendedMarker: ExtendedFeature = this.setMarkerProps(marker, cluster);\n        extendedMarker.clustertype = \"marker\";\n\n        this.map.kmeansLayer.getSource().addFeature(extendedMarker)\n\n        this.markerList.push(extendedMarker);\n    }\n\n    getCellStyle(feature: ExtendedFeature, resolution: number): Style {\n\n        const roundedCount = this.roundMarkerCount(feature.count);\n        const fillColor = this.gridFillColors[roundedCount];\n        const strokeColor = this.gridStrokeColors[roundedCount];\n        const strokeWeight = 2;\n\n        const style = new Style({\n            stroke: new Stroke({\n                color: strokeColor,\n                width: strokeWeight,\n            }),\n            fill: new Fill({\n                color: fillColor,\n            }),\n        });\n\n        return style;\n    }\n\n    drawCell(cluster: Cluster) {\n\n        const count = cluster.count;\n\n        if (count == 1) {\n            this.drawMarker(cluster)\n        }\n        else {\n\n            const geojson = {\n                \"type\": \"Feature\",\n                \"geometry\": cluster.geojson,\n            };\n\n            let feature = new GeoJSON().readFeature(geojson);\n\n            let extendedFeature: ExtendedFeature = this.setMarkerProps(feature, cluster);\n            extendedFeature.clustertype = \"cell\";\n\n            this.map.gridClusterLayer.getSource().addFeature(extendedFeature)\n\n        }\n\n    }\n\n    removeAllMarkers() {\n\n        \n        this.map.kmeansLayer.getSource().clear();\n\n        if (this.map.hasOwnProperty(\"gridClusterLayer\")) {\n            this.map.gridClusterLayer.getSource().clear();\n        }\n\n        this.markerList.length = 0;\n\n    }\n\n    addMapEventListeners () {\n        // unfortunately fires after loadend\n        this.map.addEventListener(\"moveend\", (event: any) => {\n\n            let newZoom = this.getZoom();\n            if (newZoom != this.currentZoom){\n                this.removeAllMarkers();\n                this.currentZoom = newZoom;\n            }\n            this.getClusters();\n        });\n    }\n\n\n    getViewport(): Viewport {\n\n        const view = this.map.getView();\n\n        const extent = view.calculateExtent(this.map.getSize());\n\n        const left = extent[0];\n        const bottom = extent[1];\n        const right = extent[2];\n        const top = extent[3];\n\n        const viewportJSON = {\n            \"left\": left,\n            \"top\": top,\n            \"right\": right,\n            \"bottom\": bottom\n        };\n\n        return viewportJSON;\n        \n    }\n\n    getZoom(): number {\n        const view = this.map.getView();\n        return view.getZoom();\n    }\n\n    setZoom(zoom: number): void {\n        this.map.setZoom(zoom);\n    }\n\n\n    setMap(x: number, y: number, zoom: number): void {\n        const view = this.map.getView();\n        view.animate({\n            zoom: zoom,\n            center: [x, y],\n            duration: 500,\n        });\n    }\n\n}"],"names":["$b0d4e62e8aa64baf$export$e7e1d3d8299bc13e","$kEX8F$anyclusterclient","AnyclusterClient","constructor","map","apiUrl","markerFolderPath","settings","super","this","currentZoom","getZoom","removeArea","hasOwnProperty","areaLayer","getSource","clear","getAreaStyle","feature","resolution","$kEX8F$olstyle","Style","stroke","Stroke","color","width","fill","Fill","addArea","geojson","createAreaLayer","features","$parcel$interopDefault","$kEX8F$olformatGeoJSON","featureProjection","readFeatures","addFeatures","createClusterLayers","gridClusterLayer","$kEX8F$ollayerVector","source","$kEX8F$olsourceVector","style","getCellStyle","bind","addLayer","kmeansLayer","on","event","hit","forEachFeatureAtPixel","pixel","clustertype","count","onMarkerFinalClick","markerClickFunction","x","y","getEventPixel","originalEvent","hasFeatureAtPixel","getViewport","cursor","getLayers","insertAt","getMarkerIcon","cluster","piniconObj","selectPinIcon","icon","Icon","anchor","relativeAnchor","crossOrigin","src","url","imgSize","size","image","drawMarker","point","$kEX8F$olgeomPoint","center","marker","$kEX8F$olFeature","setStyle","extendedMarker","setMarkerProps","addFeature","markerList","push","roundedCount","roundMarkerCount","fillColor","gridFillColors","strokeColor","gridStrokeColors","drawCell","type","geometry","readFeature","extendedFeature","removeAllMarkers","length","addMapEventListeners","addEventListener","newZoom","getClusters","extent","getView","calculateExtent","getSize","left","bottom","right","top","setZoom","zoom","setMap","animate","duration"],"version":3,"file":"main.js.map"}