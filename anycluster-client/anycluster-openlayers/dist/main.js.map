{"mappings":"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","sources":["<anon>","src/index.ts","src/anycluster-openlayers.ts"],"sourcesContent":["var $kEX8F$anyclusterclient = require(\"anycluster-client\");\nvar $kEX8F$ollayerVector = require(\"ol/layer/Vector\");\nvar $kEX8F$olsourceVector = require(\"ol/source/Vector\");\nvar $kEX8F$olstyle = require(\"ol/style\");\nvar $kEX8F$olformatGeoJSON = require(\"ol/format/GeoJSON\");\nvar $kEX8F$olFeature = require(\"ol/Feature\");\nvar $kEX8F$olgeomPoint = require(\"ol/geom/Point\");\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n$parcel$export(module.exports, \"ClusterMethod\", () => $b0d4e62e8aa64baf$re_export$ClusterMethod);\n$parcel$export(module.exports, \"AnyclusterOpenLayers\", () => $b0d4e62e8aa64baf$export$e7e1d3d8299bc13e);\n\n\n\n\n\n\n\nclass $b0d4e62e8aa64baf$export$e7e1d3d8299bc13e extends (0, $kEX8F$anyclusterclient.AnyclusterClient) {\n    constructor(map, apiUrl, markerFolderPath, settings){\n        super(map, apiUrl, markerFolderPath, settings);\n        this.currentZoom = this.getZoom();\n    }\n    removeArea() {\n        if (this.map.hasOwnProperty(\"areaLayer\")) this.map.areaLayer.getSource().clear();\n    }\n    getAreaStyle(feature, resolution) {\n        const style = new (0, $kEX8F$olstyle.Style)({\n            stroke: new (0, $kEX8F$olstyle.Stroke)({\n                color: \"rgba(255, 0, 0, 1)\",\n                width: 2\n            }),\n            fill: new (0, $kEX8F$olstyle.Fill)({\n                color: \"rgba(255, 0, 0, .3)\"\n            })\n        });\n        return style;\n    }\n    addArea(geojson) {\n        if (!this.map.hasOwnProperty(\"areaLayer\")) this.createAreaLayer();\n        const features = new (0, ($parcel$interopDefault($kEX8F$olformatGeoJSON)))({\n            featureProjection: \"EPSG:3857\"\n        }).readFeatures(geojson);\n        this.map.areaLayer.getSource().addFeatures(features);\n    }\n    createClusterLayers() {\n        const gridClusterLayer = new (0, ($parcel$interopDefault($kEX8F$ollayerVector)))({\n            source: new (0, ($parcel$interopDefault($kEX8F$olsourceVector)))(),\n            style: this.getCellStyle.bind(this)\n        });\n        this.map.addLayer(gridClusterLayer);\n        this.map.gridClusterLayer = gridClusterLayer;\n        const kmeansLayer = new (0, ($parcel$interopDefault($kEX8F$ollayerVector)))({\n            source: new (0, ($parcel$interopDefault($kEX8F$olsourceVector)))()\n        });\n        this.map.addLayer(kmeansLayer);\n        this.map.kmeansLayer = kmeansLayer;\n        this.map.on(\"click\", (event)=>{\n            let hit = false;\n            this.map.forEachFeatureAtPixel(event.pixel, (feature)=>{\n                if (hit == false) {\n                    if (feature.clustertype == \"cell\" || feature.clustertype == \"marker\") {\n                        hit = true;\n                        let zoom = this.getZoom();\n                        if (zoom >= this.maxZoom || feature.count == 1) this.onMarkerFinalClick(feature);\n                        else this.markerClickFunction(feature.x, feature.y);\n                    }\n                }\n            });\n        });\n        this.map.on(\"pointermove\", (event)=>{\n            let pixel = this.map.getEventPixel(event.originalEvent);\n            let hit = this.map.hasFeatureAtPixel(pixel);\n            this.map.getViewport().style.cursor = hit ? \"pointer\" : \"\";\n        });\n    }\n    createAreaLayer() {\n        const areaLayer = new (0, ($parcel$interopDefault($kEX8F$ollayerVector)))({\n            source: new (0, ($parcel$interopDefault($kEX8F$olsourceVector)))(),\n            style: this.getAreaStyle.bind(this)\n        });\n        const layers = this.map.getLayers();\n        layers.insertAt(2, areaLayer);\n        //this.map.addLayer(areaLayer);\n        this.map.areaLayer = areaLayer;\n    }\n    getMarkerIcon(cluster) {\n        const piniconObj = this.selectPinIcon(cluster);\n        const icon = new (0, $kEX8F$olstyle.Icon)({\n            anchor: piniconObj.relativeAnchor,\n            crossOrigin: \"anonymous\",\n            src: piniconObj.url,\n            imgSize: piniconObj.size,\n            size: piniconObj.size\n        });\n        const styleOptions = {\n            image: icon\n        };\n        if (this.iconType === (0, $kEX8F$anyclusterclient.IconType).exact && cluster.count > 1) styleOptions.text = new (0, $kEX8F$olstyle.Text)({\n            text: cluster.count.toString(),\n            font: \"bold 14px sans-serif\",\n            fill: new (0, $kEX8F$olstyle.Fill)({\n                color: \"#FFF\"\n            }),\n            justify: \"center\",\n            textBaseline: \"middle\",\n            offsetY: 1,\n            padding: [\n                0,\n                0,\n                0,\n                0\n            ]\n        });\n        const style = new (0, $kEX8F$olstyle.Style)(styleOptions);\n        return style;\n    }\n    _getMarkerFeature(cluster) {\n        const style = this.getMarkerIcon(cluster);\n        const point = new (0, ($parcel$interopDefault($kEX8F$olgeomPoint)))([\n            cluster.center.x,\n            cluster.center.y\n        ]);\n        let marker = new (0, ($parcel$interopDefault($kEX8F$olFeature)))(point);\n        marker.setStyle(style);\n        return marker;\n    }\n    _drawSingleMarker(extendedMarker) {\n        extendedMarker.clustertype = \"marker\";\n        this.map.kmeansLayer.getSource().addFeature(extendedMarker);\n        this.markerList.push(extendedMarker);\n    }\n    drawKmeansMarker(cluster) {\n        let marker = this._getMarkerFeature(cluster);\n        let extendedMarker = this.setMarkerProps(marker, cluster);\n        this._drawSingleMarker(extendedMarker);\n    }\n    drawGridMarker(cluster) {\n        let marker = this._getMarkerFeature(cluster);\n        let extendedMarker = this.setCellProps(marker, cluster);\n        this._drawSingleMarker(extendedMarker);\n    }\n    getCellStyle(feature, resolution) {\n        const roundedCount = this.roundMarkerCount(feature.count);\n        const fillColor = this.gridFillColors[roundedCount];\n        const strokeColor = this.gridStrokeColors[roundedCount];\n        const strokeWeight = 2;\n        const style = new (0, $kEX8F$olstyle.Style)({\n            stroke: new (0, $kEX8F$olstyle.Stroke)({\n                color: strokeColor,\n                width: strokeWeight\n            }),\n            fill: new (0, $kEX8F$olstyle.Fill)({\n                color: fillColor\n            })\n        });\n        return style;\n    }\n    drawCell(cluster) {\n        const count = cluster.count;\n        if (count == 1) this.drawGridMarker(cluster);\n        else {\n            const geojson = {\n                \"type\": \"Feature\",\n                \"geometry\": cluster.geojson\n            };\n            let feature = new (0, ($parcel$interopDefault($kEX8F$olformatGeoJSON)))().readFeature(geojson);\n            let extendedFeature = this.setCellProps(feature, cluster);\n            extendedFeature.clustertype = \"cell\";\n            this.map.gridClusterLayer.getSource().addFeature(extendedFeature);\n        }\n    }\n    removeAllMarkers() {\n        this.map.kmeansLayer.getSource().clear();\n        if (this.map.hasOwnProperty(\"gridClusterLayer\")) this.map.gridClusterLayer.getSource().clear();\n        this.markerList.length = 0;\n    }\n    addMapEventListeners() {\n        // unfortunately fires after loadend\n        this.map.addEventListener(\"moveend\", (event)=>{\n            let newZoom = this.getZoom();\n            if (newZoom != this.currentZoom) {\n                this.removeAllMarkers();\n                this.currentZoom = newZoom;\n            }\n            if (this.isStartup === false) this.getClusters();\n        });\n    }\n    // Openlayers accumulates coordinates when panning across world borders\n    putXCoordinateIntoWorldBounds(XCoordinate) {\n        let bounds = (0, $kEX8F$anyclusterclient.Bounds3857);\n        if (this.srid === (0, $kEX8F$anyclusterclient.SRIDS).EPSG4326) bounds = (0, $kEX8F$anyclusterclient.Bounds4326);\n        const worldWidth = bounds.maxX - bounds.minX;\n        const worldCount = Math.floor(Math.abs(XCoordinate) / worldWidth) + 1;\n        const vector = worldWidth * worldCount;\n        if (XCoordinate < bounds.minX) // user panned to the right, map moved leftwards over the border\n        XCoordinate = XCoordinate + vector;\n        else if (XCoordinate > bounds.maxX) // user panned to the left, map moved rightwards over the border\n        XCoordinate = XCoordinate - vector;\n        return XCoordinate;\n    }\n    getViewport() {\n        const view = this.map.getView();\n        const extent = view.calculateExtent(this.map.getSize());\n        const left = extent[0];\n        const bottom = extent[1];\n        const right = extent[2];\n        const top = extent[3];\n        const viewportJSON = {\n            \"left\": this.putXCoordinateIntoWorldBounds(left),\n            \"top\": top,\n            \"right\": this.putXCoordinateIntoWorldBounds(right),\n            \"bottom\": bottom\n        };\n        return viewportJSON;\n    }\n    getZoom() {\n        const view = this.map.getView();\n        return view.getZoom();\n    }\n    setZoom(zoom) {\n        this.map.setZoom(zoom);\n    }\n    setMap(x, y, zoom) {\n        const view = this.map.getView();\n        view.animate({\n            zoom: zoom,\n            center: [\n                x,\n                y\n            ],\n            duration: 500\n        });\n    }\n}\n\n\n\n\n//# sourceMappingURL=main.js.map\n","export {\n    ClusterMethod,\n    AnyclusterOpenLayers,\n} from \"./anycluster-openlayers\";","import {\n    AnyclusterClient,\n    AnyclusterClientSettings,\n    Viewport,\n    KmeansCluster,\n    GridCluster,\n    ClusterMethod,\n    GeoJSON as IGeoJSON,\n    IconType,\n    SRIDS\n} from 'anycluster-client';\n\nimport {\n    Bounds3857,\n    Bounds4326\n} from 'anycluster-client';\n\nexport {\n    ClusterMethod\n};\n\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\nimport { Icon, Stroke, Style, Fill, Text } from 'ol/style';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport Feature from 'ol/Feature';\nimport Point from 'ol/geom/Point';\n\ninterface ExtendedFeature extends Feature {\n    x: number\n    y: number\n    count: number\n    clustertype: string\n}\n\ninterface StyleOptions {\n    image: Icon,\n    text?: Text,\n}\n\nexport class AnyclusterOpenLayers extends AnyclusterClient {\n\n    currentZoom: number\n\n    constructor(map: any, apiUrl: string, markerFolderPath: string, settings: AnyclusterClientSettings) {\n        super(map, apiUrl, markerFolderPath, settings);\n        this.currentZoom = this.getZoom();\n    }\n\n\n    removeArea() {\n        if (this.map.hasOwnProperty(\"areaLayer\")) {\n            this.map.areaLayer.getSource().clear();\n        }\n    }\n\n    getAreaStyle(feature: Feature, resolution: number): Style {\n\n        const style = new Style({\n            stroke: new Stroke({\n                color: \"rgba(255, 0, 0, 1)\",\n                width: 2,\n            }),\n            fill: new Fill({\n                color: \"rgba(255, 0, 0, .3)\",\n            }),\n        });\n\n        return style;\n    }\n\n    addArea(geojson: IGeoJSON) {\n        if (!this.map.hasOwnProperty(\"areaLayer\")) {\n            this.createAreaLayer();\n        }\n\n        const features = new GeoJSON({\n            featureProjection: \"EPSG:3857\"\n        }).readFeatures(geojson);\n\n        \n        this.map.areaLayer.getSource().addFeatures(features);\n\n    }\n\n    createClusterLayers() {\n\n        const gridClusterLayer = new VectorLayer({\n            source: new VectorSource(),\n            style: this.getCellStyle.bind(this) as any,\n        });\n\n        this.map.addLayer(gridClusterLayer);\n        this.map.gridClusterLayer = gridClusterLayer;\n\n        const kmeansLayer = new VectorLayer({\n            source: new VectorSource()\n        });\n\n        this.map.addLayer(kmeansLayer);\n        this.map.kmeansLayer = kmeansLayer;\n\n        this.map.on(\"click\", (event: any) => {\n\n            let hit = false;\n\n            this.map.forEachFeatureAtPixel(event.pixel, (feature: ExtendedFeature) => {\n\n                if (hit == false){\n\n                    if (feature.clustertype == \"cell\" || feature.clustertype == \"marker\"){\n                        hit = true;\n                        let zoom = this.getZoom();\n\n                        if (zoom >= this.maxZoom || feature.count == 1) {\n                            this.onMarkerFinalClick(feature);\n                        }\n\n                        else {\n                            this.markerClickFunction(feature.x, feature.y);\n                        }\n                    }\n                }\n            });\n        });\n\n        this.map.on(\"pointermove\", (event: any) => {\n            let pixel = this.map.getEventPixel(event.originalEvent);\n            let hit = this.map.hasFeatureAtPixel(pixel);\n            this.map.getViewport().style.cursor = hit ? 'pointer' : '';\n        });\n    }\n\n    createAreaLayer() {\n\n        const areaLayer = new VectorLayer({\n            source: new VectorSource(),\n            style: this.getAreaStyle.bind(this) as any,\n        });\n\n        const layers = this.map.getLayers();\n        layers.insertAt(2, areaLayer);\n        //this.map.addLayer(areaLayer);\n        this.map.areaLayer = areaLayer;\n    }\n\n    getMarkerIcon(cluster: KmeansCluster | GridCluster) {\n\n        const piniconObj = this.selectPinIcon(cluster);\n\n        const icon = new Icon({\n            anchor: piniconObj.relativeAnchor,\n            crossOrigin: \"anonymous\",\n            src: piniconObj.url,\n            imgSize: piniconObj.size,\n            size: piniconObj.size\n        });\n\n        const styleOptions: StyleOptions = {\n            image: icon,\n        };\n\n        if (this.iconType === IconType.exact && cluster.count > 1){\n            styleOptions.text = new Text({\n                text: cluster.count.toString(),\n                font: 'bold 14px sans-serif',\n                fill: new Fill({color: '#FFF'}),\n                justify: 'center',\n                textBaseline: 'middle',\n                offsetY: 1,\n                padding: [0,0,0,0],\n            })\n        }\n        const style = new Style(styleOptions);\n\n        return style;\n          \n    }\n\n    _getMarkerFeature(cluster: KmeansCluster | GridCluster) {\n        const style = this.getMarkerIcon(cluster);\n        const point = new Point([cluster.center.x, cluster.center.y]);\n\n        let marker = new Feature(point);\n\n        marker.setStyle(style);\n\n        return marker;\n    }\n\n    _drawSingleMarker(extendedMarker: ExtendedFeature) {\n        extendedMarker.clustertype = \"marker\";\n\n        this.map.kmeansLayer.getSource().addFeature(extendedMarker)\n\n        this.markerList.push(extendedMarker);\n    }\n\n    drawKmeansMarker(cluster: KmeansCluster) {\n        let marker = this._getMarkerFeature(cluster);\n        let extendedMarker: ExtendedFeature = this.setMarkerProps(marker, cluster);\n        this._drawSingleMarker(extendedMarker);\n    }\n\n    drawGridMarker(cluster: GridCluster) {\n        let marker = this._getMarkerFeature(cluster);\n        let extendedMarker: ExtendedFeature = this.setCellProps(marker, cluster);\n        this._drawSingleMarker(extendedMarker);\n    }\n\n    getCellStyle(feature: ExtendedFeature, resolution: number): Style {\n\n        const roundedCount = this.roundMarkerCount(feature.count);\n        const fillColor = this.gridFillColors[roundedCount];\n        const strokeColor = this.gridStrokeColors[roundedCount];\n        const strokeWeight = 2;\n\n        const style = new Style({\n            stroke: new Stroke({\n                color: strokeColor,\n                width: strokeWeight,\n            }),\n            fill: new Fill({\n                color: fillColor,\n            }),\n        });\n\n        return style;\n    }\n\n    drawCell(cluster: GridCluster) {\n\n        const count = cluster.count;\n\n        if (count == 1) {\n            this.drawGridMarker(cluster)\n        }\n        else {\n\n            const geojson = {\n                \"type\": \"Feature\",\n                \"geometry\": cluster.geojson,\n            };\n\n            let feature = new GeoJSON().readFeature(geojson);\n\n            let extendedFeature: ExtendedFeature = this.setCellProps(feature, cluster);\n            extendedFeature.clustertype = \"cell\";\n\n            this.map.gridClusterLayer.getSource().addFeature(extendedFeature)\n\n        }\n\n    }\n\n    removeAllMarkers() {\n\n        \n        this.map.kmeansLayer.getSource().clear();\n\n        if (this.map.hasOwnProperty(\"gridClusterLayer\")) {\n            this.map.gridClusterLayer.getSource().clear();\n        }\n\n        this.markerList.length = 0;\n\n    }\n\n    addMapEventListeners () {\n        // unfortunately fires after loadend\n        this.map.addEventListener(\"moveend\", (event: any) => {\n\n            let newZoom = this.getZoom();\n            if (newZoom != this.currentZoom){\n                this.removeAllMarkers();\n                this.currentZoom = newZoom;\n            }\n            if (this.isStartup === false) {\n                this.getClusters();\n            }\n        });\n    }\n\n    // Openlayers accumulates coordinates when panning across world borders\n    putXCoordinateIntoWorldBounds (XCoordinate: number): number {\n\n        let bounds = Bounds3857;\n\n        if (this.srid === SRIDS.EPSG4326) {\n            bounds = Bounds4326;\n        }\n\n        const worldWidth = bounds.maxX - bounds.minX;\n        const worldCount = Math.floor( Math.abs(XCoordinate) / worldWidth ) + 1;\n        const vector = worldWidth * worldCount;\n\n        if (XCoordinate < bounds.minX) {\n            // user panned to the right, map moved leftwards over the border\n            XCoordinate = XCoordinate + vector;\n        } else if (XCoordinate > bounds.maxX) {\n            // user panned to the left, map moved rightwards over the border\n            XCoordinate = XCoordinate - vector;\n        }\n\n        return XCoordinate;\n    }\n\n    getViewport(): Viewport {\n\n        const view = this.map.getView();\n\n        const extent = view.calculateExtent(this.map.getSize());\n\n        const left = extent[0];\n        const bottom = extent[1];\n        const right = extent[2];\n        const top = extent[3];\n\n        const viewportJSON = {\n            \"left\": this.putXCoordinateIntoWorldBounds(left),\n            \"top\": top,\n            \"right\": this.putXCoordinateIntoWorldBounds(right),\n            \"bottom\": bottom\n        };\n\n        return viewportJSON;\n        \n    }\n\n    getZoom(): number {\n        const view = this.map.getView();\n        return view.getZoom();\n    }\n\n    setZoom(zoom: number): void {\n        this.map.setZoom(zoom);\n    }\n\n\n    setMap(x: number, y: number, zoom: number): void {\n        const view = this.map.getView();\n        view.animate({\n            zoom: zoom,\n            center: [x, y],\n            duration: 500,\n        });\n    }\n\n}"],"names":["$kEX8F$anyclusterclient","require","$kEX8F$ollayerVector","$kEX8F$olsourceVector","$kEX8F$olstyle","$kEX8F$olformatGeoJSON","$kEX8F$olFeature","$kEX8F$olgeomPoint","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","module","exports","$b0d4e62e8aa64baf$re_export$ClusterMethod","$b0d4e62e8aa64baf$export$e7e1d3d8299bc13e","AnyclusterClient","constructor","map","apiUrl","markerFolderPath","settings","currentZoom","getZoom","removeArea","hasOwnProperty","areaLayer","getSource","clear","getAreaStyle","feature","resolution","style","Style","stroke","Stroke","color","width","fill","Fill","addArea","geojson","createAreaLayer","features","featureProjection","readFeatures","addFeatures","createClusterLayers","gridClusterLayer","source","getCellStyle","bind","addLayer","kmeansLayer","on","event","hit","forEachFeatureAtPixel","pixel","clustertype","zoom","maxZoom","count","onMarkerFinalClick","markerClickFunction","x","y","getEventPixel","originalEvent","hasFeatureAtPixel","getViewport","cursor","layers","getLayers","insertAt","getMarkerIcon","cluster","piniconObj","selectPinIcon","icon","Icon","anchor","relativeAnchor","crossOrigin","src","url","imgSize","size","styleOptions","image","iconType","IconType","exact","text","Text","toString","font","justify","textBaseline","offsetY","padding","_getMarkerFeature","point","center","marker","setStyle","_drawSingleMarker","extendedMarker","addFeature","markerList","push","drawKmeansMarker","setMarkerProps","drawGridMarker","setCellProps","roundedCount","roundMarkerCount","fillColor","gridFillColors","strokeColor","gridStrokeColors","drawCell","readFeature","extendedFeature","removeAllMarkers","length","addMapEventListeners","addEventListener","newZoom","isStartup","getClusters","putXCoordinateIntoWorldBounds","XCoordinate","bounds","Bounds3857","srid","SRIDS","EPSG4326","Bounds4326","worldWidth","maxX","minX","worldCount","Math","floor","abs","vector","view","getView","extent","calculateExtent","getSize","left","bottom","right","top","viewportJSON","setZoom","setMap","animate","duration"],"version":3,"file":"main.js.map"}