{"mappings":"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","sources":["<anon>","src/index.ts","src/anycluster-openlayers.ts"],"sourcesContent":["var $kEX8F$anyclusterclient = require(\"anycluster-client\");\nvar $kEX8F$ollayerVector = require(\"ol/layer/Vector\");\nvar $kEX8F$olsourceVector = require(\"ol/source/Vector\");\nvar $kEX8F$olstyle = require(\"ol/style\");\nvar $kEX8F$olformatGeoJSON = require(\"ol/format/GeoJSON\");\nvar $kEX8F$olFeature = require(\"ol/Feature\");\nvar $kEX8F$olgeomPoint = require(\"ol/geom/Point\");\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n$parcel$export(module.exports, \"ClusterMethod\", () => $b0d4e62e8aa64baf$re_export$ClusterMethod);\n$parcel$export(module.exports, \"AnyclusterOpenLayers\", () => $b0d4e62e8aa64baf$export$e7e1d3d8299bc13e);\n\n\n\n\n\n\n\nclass $b0d4e62e8aa64baf$export$e7e1d3d8299bc13e extends (0, $kEX8F$anyclusterclient.AnyclusterClient) {\n    constructor(map, apiUrl, markerFolderPath, settings){\n        super(map, apiUrl, markerFolderPath, settings);\n        this.currentZoom = this.getZoom();\n    }\n    removeArea() {\n        if (this.map.hasOwnProperty(\"areaLayer\")) this.map.areaLayer.getSource().clear();\n    }\n    getAreaStyle(feature, resolution) {\n        const style = new (0, $kEX8F$olstyle.Style)({\n            stroke: new (0, $kEX8F$olstyle.Stroke)({\n                color: \"rgba(255, 0, 0, 1)\",\n                width: 2\n            }),\n            fill: new (0, $kEX8F$olstyle.Fill)({\n                color: \"rgba(255, 0, 0, .3)\"\n            })\n        });\n        return style;\n    }\n    addArea(geojson) {\n        if (!this.map.hasOwnProperty(\"areaLayer\")) this.createAreaLayer();\n        const features = new (0, ($parcel$interopDefault($kEX8F$olformatGeoJSON)))({\n            featureProjection: \"EPSG:3857\"\n        }).readFeatures(geojson);\n        this.map.areaLayer.getSource().addFeatures(features);\n    }\n    createClusterLayers() {\n        const gridClusterLayer = new (0, ($parcel$interopDefault($kEX8F$ollayerVector)))({\n            source: new (0, ($parcel$interopDefault($kEX8F$olsourceVector)))(),\n            style: this.getCellStyle.bind(this)\n        });\n        this.map.addLayer(gridClusterLayer);\n        this.map.gridClusterLayer = gridClusterLayer;\n        const kmeansLayer = new (0, ($parcel$interopDefault($kEX8F$ollayerVector)))({\n            source: new (0, ($parcel$interopDefault($kEX8F$olsourceVector)))()\n        });\n        this.map.addLayer(kmeansLayer);\n        this.map.kmeansLayer = kmeansLayer;\n        this.map.on(\"click\", (event)=>{\n            let hit = false;\n            this.map.forEachFeatureAtPixel(event.pixel, (feature)=>{\n                if (hit == false) {\n                    if (feature.clustertype == \"cell\" || feature.clustertype == \"marker\") {\n                        hit = true;\n                        let zoom = this.getZoom();\n                        if (zoom >= 13 || feature.count == 1) this.onMarkerFinalClick(feature);\n                        else this.markerClickFunction(feature.x, feature.y);\n                    }\n                }\n            });\n        });\n        this.map.on(\"pointermove\", (event)=>{\n            let pixel = this.map.getEventPixel(event.originalEvent);\n            let hit = this.map.hasFeatureAtPixel(pixel);\n            this.map.getViewport().style.cursor = hit ? \"pointer\" : \"\";\n        });\n    }\n    createAreaLayer() {\n        const areaLayer = new (0, ($parcel$interopDefault($kEX8F$ollayerVector)))({\n            source: new (0, ($parcel$interopDefault($kEX8F$olsourceVector)))(),\n            style: this.getAreaStyle.bind(this)\n        });\n        const layers = this.map.getLayers();\n        layers.insertAt(2, areaLayer);\n        //this.map.addLayer(areaLayer);\n        this.map.areaLayer = areaLayer;\n    }\n    getMarkerIcon(cluster) {\n        const piniconObj = this.selectPinIcon(cluster);\n        const icon = new (0, $kEX8F$olstyle.Icon)({\n            anchor: piniconObj.relativeAnchor,\n            crossOrigin: \"anonymous\",\n            src: piniconObj.url,\n            imgSize: piniconObj.size,\n            size: piniconObj.size\n        });\n        const style = new (0, $kEX8F$olstyle.Style)({\n            image: icon\n        });\n        return style;\n    }\n    drawMarker(cluster) {\n        const style = this.getMarkerIcon(cluster);\n        const point = new (0, ($parcel$interopDefault($kEX8F$olgeomPoint)))([\n            cluster.center.x,\n            cluster.center.y\n        ]);\n        let marker = new (0, ($parcel$interopDefault($kEX8F$olFeature)))(point);\n        marker.setStyle(style);\n        let extendedMarker = this.setMarkerProps(marker, cluster);\n        extendedMarker.clustertype = \"marker\";\n        this.map.kmeansLayer.getSource().addFeature(extendedMarker);\n        this.markerList.push(extendedMarker);\n    }\n    getCellStyle(feature, resolution) {\n        const roundedCount = this.roundMarkerCount(feature.count);\n        const fillColor = this.gridFillColors[roundedCount];\n        const strokeColor = this.gridStrokeColors[roundedCount];\n        const strokeWeight = 2;\n        const style = new (0, $kEX8F$olstyle.Style)({\n            stroke: new (0, $kEX8F$olstyle.Stroke)({\n                color: strokeColor,\n                width: strokeWeight\n            }),\n            fill: new (0, $kEX8F$olstyle.Fill)({\n                color: fillColor\n            })\n        });\n        return style;\n    }\n    drawCell(cluster) {\n        const count = cluster.count;\n        if (count == 1) this.drawMarker(cluster);\n        else {\n            const geojson = {\n                \"type\": \"Feature\",\n                \"geometry\": cluster.geojson\n            };\n            let feature = new (0, ($parcel$interopDefault($kEX8F$olformatGeoJSON)))().readFeature(geojson);\n            let extendedFeature = this.setMarkerProps(feature, cluster);\n            extendedFeature.clustertype = \"cell\";\n            this.map.gridClusterLayer.getSource().addFeature(extendedFeature);\n        }\n    }\n    removeAllMarkers() {\n        this.map.kmeansLayer.getSource().clear();\n        if (this.map.hasOwnProperty(\"gridClusterLayer\")) this.map.gridClusterLayer.getSource().clear();\n        this.markerList.length = 0;\n    }\n    addMapEventListeners() {\n        // unfortunately fires after loadend\n        this.map.addEventListener(\"moveend\", (event)=>{\n            let newZoom = this.getZoom();\n            if (newZoom != this.currentZoom) {\n                this.removeAllMarkers();\n                this.currentZoom = newZoom;\n            }\n            this.getClusters();\n        });\n    }\n    getViewport() {\n        const view = this.map.getView();\n        const extent = view.calculateExtent(this.map.getSize());\n        const left = extent[0];\n        const bottom = extent[1];\n        const right = extent[2];\n        const top = extent[3];\n        const viewportJSON = {\n            \"left\": left,\n            \"top\": top,\n            \"right\": right,\n            \"bottom\": bottom\n        };\n        return viewportJSON;\n    }\n    getZoom() {\n        const view = this.map.getView();\n        return view.getZoom();\n    }\n    setZoom(zoom) {\n        this.map.setZoom(zoom);\n    }\n    setMap(x, y, zoom) {\n        const view = this.map.getView();\n        view.animate({\n            zoom: zoom,\n            center: [\n                x,\n                y\n            ],\n            duration: 500\n        });\n    }\n}\n\n\n\n\n//# sourceMappingURL=main.js.map\n","export {\n    ClusterMethod,\n    AnyclusterOpenLayers,\n} from \"./anycluster-openlayers\";","import {\n    AnyclusterClient,\n    AnyclusterClientSettings,\n    Viewport,\n    Cluster,\n    ClusterMethod,\n    GeoJSON as IGeoJSON,\n} from 'anycluster-client';\n\nexport {\n    ClusterMethod\n};\n\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\nimport { Icon, Stroke, Style, Fill } from 'ol/style';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport Feature from 'ol/Feature';\nimport Point from 'ol/geom/Point';\n\ninterface ExtendedFeature extends Feature {\n    x: number\n    y: number\n    count: number\n    clustertype: string\n}\n\nexport class AnyclusterOpenLayers extends AnyclusterClient {\n\n    currentZoom: number\n\n    constructor(map: any, apiUrl: string, markerFolderPath: string, settings: AnyclusterClientSettings) {\n        super(map, apiUrl, markerFolderPath, settings);\n        this.currentZoom = this.getZoom();\n    }\n\n\n    removeArea() {\n        if (this.map.hasOwnProperty(\"areaLayer\")) {\n            this.map.areaLayer.getSource().clear();\n        }\n    }\n\n    getAreaStyle(feature: Feature, resolution: number): Style {\n\n        const style = new Style({\n            stroke: new Stroke({\n                color: \"rgba(255, 0, 0, 1)\",\n                width: 2,\n            }),\n            fill: new Fill({\n                color: \"rgba(255, 0, 0, .3)\",\n            }),\n        });\n\n        return style;\n    }\n\n    addArea(geojson: IGeoJSON) {\n        if (!this.map.hasOwnProperty(\"areaLayer\")) {\n            this.createAreaLayer();\n        }\n\n        const features = new GeoJSON({\n            featureProjection: \"EPSG:3857\"\n        }).readFeatures(geojson);\n\n        \n        this.map.areaLayer.getSource().addFeatures(features);\n\n    }\n\n    createClusterLayers() {\n\n        const gridClusterLayer = new VectorLayer({\n            source: new VectorSource(),\n            style: this.getCellStyle.bind(this) as any,\n        });\n\n        this.map.addLayer(gridClusterLayer);\n        this.map.gridClusterLayer = gridClusterLayer;\n\n        const kmeansLayer = new VectorLayer({\n            source: new VectorSource()\n        });\n\n        this.map.addLayer(kmeansLayer);\n        this.map.kmeansLayer = kmeansLayer;\n\n        this.map.on(\"click\", (event: any) => {\n\n            let hit = false;\n\n            this.map.forEachFeatureAtPixel(event.pixel, (feature: ExtendedFeature) => {\n\n                if (hit == false){\n\n                    if (feature.clustertype == \"cell\" || feature.clustertype == \"marker\"){\n                        hit = true;\n                        let zoom = this.getZoom();\n\n                        if (zoom >= 13 || feature.count == 1) {\n                            this.onMarkerFinalClick(feature);\n                        }\n\n                        else {\n                            this.markerClickFunction(feature.x, feature.y);\n                        }\n                    }\n                }\n            });\n        });\n\n        this.map.on(\"pointermove\", (event: any) => {\n            let pixel = this.map.getEventPixel(event.originalEvent);\n            let hit = this.map.hasFeatureAtPixel(pixel);\n            this.map.getViewport().style.cursor = hit ? 'pointer' : '';\n        });\n    }\n\n    createAreaLayer() {\n\n        const areaLayer = new VectorLayer({\n            source: new VectorSource(),\n            style: this.getAreaStyle.bind(this) as any,\n        });\n\n        const layers = this.map.getLayers();\n        layers.insertAt(2, areaLayer);\n        //this.map.addLayer(areaLayer);\n        this.map.areaLayer = areaLayer;\n    }\n\n    getMarkerIcon(cluster: Cluster) {\n\n        const piniconObj = this.selectPinIcon(cluster);\n\n        const icon = new Icon({\n            anchor: piniconObj.relativeAnchor,\n            crossOrigin: \"anonymous\",\n            src: piniconObj.url,\n            imgSize: piniconObj.size,\n            size: piniconObj.size\n        });\n\n        const style = new Style({\n            image: icon\n        });\n\n        return style;\n          \n    }\n\n    drawMarker(cluster: Cluster) {\n\n        const style = this.getMarkerIcon(cluster);\n        const point = new Point([cluster.center.x, cluster.center.y])\n\n        let marker = new Feature(point);\n\n        marker.setStyle(style);\n\n        let extendedMarker: ExtendedFeature = this.setMarkerProps(marker, cluster);\n        extendedMarker.clustertype = \"marker\";\n\n        this.map.kmeansLayer.getSource().addFeature(extendedMarker)\n\n        this.markerList.push(extendedMarker);\n    }\n\n    getCellStyle(feature: ExtendedFeature, resolution: number): Style {\n\n        const roundedCount = this.roundMarkerCount(feature.count);\n        const fillColor = this.gridFillColors[roundedCount];\n        const strokeColor = this.gridStrokeColors[roundedCount];\n        const strokeWeight = 2;\n\n        const style = new Style({\n            stroke: new Stroke({\n                color: strokeColor,\n                width: strokeWeight,\n            }),\n            fill: new Fill({\n                color: fillColor,\n            }),\n        });\n\n        return style;\n    }\n\n    drawCell(cluster: Cluster) {\n\n        const count = cluster.count;\n\n        if (count == 1) {\n            this.drawMarker(cluster)\n        }\n        else {\n\n            const geojson = {\n                \"type\": \"Feature\",\n                \"geometry\": cluster.geojson,\n            };\n\n            let feature = new GeoJSON().readFeature(geojson);\n\n            let extendedFeature: ExtendedFeature = this.setMarkerProps(feature, cluster);\n            extendedFeature.clustertype = \"cell\";\n\n            this.map.gridClusterLayer.getSource().addFeature(extendedFeature)\n\n        }\n\n    }\n\n    removeAllMarkers() {\n\n        \n        this.map.kmeansLayer.getSource().clear();\n\n        if (this.map.hasOwnProperty(\"gridClusterLayer\")) {\n            this.map.gridClusterLayer.getSource().clear();\n        }\n\n        this.markerList.length = 0;\n\n    }\n\n    addMapEventListeners () {\n        // unfortunately fires after loadend\n        this.map.addEventListener(\"moveend\", (event: any) => {\n\n            let newZoom = this.getZoom();\n            if (newZoom != this.currentZoom){\n                this.removeAllMarkers();\n                this.currentZoom = newZoom;\n            }\n            this.getClusters();\n        });\n    }\n\n\n    getViewport(): Viewport {\n\n        const view = this.map.getView();\n\n        const extent = view.calculateExtent(this.map.getSize());\n\n        const left = extent[0];\n        const bottom = extent[1];\n        const right = extent[2];\n        const top = extent[3];\n\n        const viewportJSON = {\n            \"left\": left,\n            \"top\": top,\n            \"right\": right,\n            \"bottom\": bottom\n        };\n\n        return viewportJSON;\n        \n    }\n\n    getZoom(): number {\n        const view = this.map.getView();\n        return view.getZoom();\n    }\n\n    setZoom(zoom: number): void {\n        this.map.setZoom(zoom);\n    }\n\n\n    setMap(x: number, y: number, zoom: number): void {\n        const view = this.map.getView();\n        view.animate({\n            zoom: zoom,\n            center: [x, y],\n            duration: 500,\n        });\n    }\n\n}"],"names":["$kEX8F$anyclusterclient","require","$kEX8F$ollayerVector","$kEX8F$olsourceVector","$kEX8F$olstyle","$kEX8F$olformatGeoJSON","$kEX8F$olFeature","$kEX8F$olgeomPoint","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","module","exports","$b0d4e62e8aa64baf$re_export$ClusterMethod","$b0d4e62e8aa64baf$export$e7e1d3d8299bc13e","AnyclusterClient","constructor","map","apiUrl","markerFolderPath","settings","currentZoom","getZoom","removeArea","hasOwnProperty","areaLayer","getSource","clear","getAreaStyle","feature","resolution","style","Style","stroke","Stroke","color","width","fill","Fill","addArea","geojson","createAreaLayer","features","featureProjection","readFeatures","addFeatures","createClusterLayers","gridClusterLayer","source","getCellStyle","bind","addLayer","kmeansLayer","on","event","hit","forEachFeatureAtPixel","pixel","clustertype","zoom","count","onMarkerFinalClick","markerClickFunction","x","y","getEventPixel","originalEvent","hasFeatureAtPixel","getViewport","cursor","layers","getLayers","insertAt","getMarkerIcon","cluster","piniconObj","selectPinIcon","icon","Icon","anchor","relativeAnchor","crossOrigin","src","url","imgSize","size","image","drawMarker","point","center","marker","setStyle","extendedMarker","setMarkerProps","addFeature","markerList","push","roundedCount","roundMarkerCount","fillColor","gridFillColors","strokeColor","gridStrokeColors","drawCell","readFeature","extendedFeature","removeAllMarkers","length","addMapEventListeners","addEventListener","newZoom","getClusters","view","getView","extent","calculateExtent","getSize","left","bottom","right","top","setZoom","setMap","animate","duration"],"version":3,"file":"main.js.map"}