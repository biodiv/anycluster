{"mappings":"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","sources":["src/index.ts","src/anycluster-openlayers.ts"],"sourcesContent":["export {\n    ClusterMethod,\n    AnyclusterOpenLayers,\n} from \"./anycluster-openlayers\";","import {\n    AnyclusterClient,\n    AnyclusterClientSettings,\n    Viewport,\n    Cluster,\n    ClusterMethod,\n    GeoJSON as IGeoJSON,\n    IconType,\n    SRIDS\n} from 'anycluster-client';\n\nimport {\n    Bounds3857,\n    Bounds4326\n} from 'anycluster-client';\n\nexport {\n    ClusterMethod\n};\n\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\nimport { Icon, Stroke, Style, Fill, Text } from 'ol/style';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport Feature from 'ol/Feature';\nimport Point from 'ol/geom/Point';\n\ninterface ExtendedFeature extends Feature {\n    x: number\n    y: number\n    count: number\n    clustertype: string\n}\n\ninterface StyleOptions {\n    image: Icon,\n    text?: Text,\n}\n\nexport class AnyclusterOpenLayers extends AnyclusterClient {\n\n    currentZoom: number\n\n    constructor(map: any, apiUrl: string, markerFolderPath: string, settings: AnyclusterClientSettings) {\n        super(map, apiUrl, markerFolderPath, settings);\n        this.currentZoom = this.getZoom();\n    }\n\n\n    removeArea() {\n        if (this.map.hasOwnProperty(\"areaLayer\")) {\n            this.map.areaLayer.getSource().clear();\n        }\n    }\n\n    getAreaStyle(feature: Feature, resolution: number): Style {\n\n        const style = new Style({\n            stroke: new Stroke({\n                color: \"rgba(255, 0, 0, 1)\",\n                width: 2,\n            }),\n            fill: new Fill({\n                color: \"rgba(255, 0, 0, .3)\",\n            }),\n        });\n\n        return style;\n    }\n\n    addArea(geojson: IGeoJSON) {\n        if (!this.map.hasOwnProperty(\"areaLayer\")) {\n            this.createAreaLayer();\n        }\n\n        const features = new GeoJSON({\n            featureProjection: \"EPSG:3857\"\n        }).readFeatures(geojson);\n\n        \n        this.map.areaLayer.getSource().addFeatures(features);\n\n    }\n\n    createClusterLayers() {\n\n        const gridClusterLayer = new VectorLayer({\n            source: new VectorSource(),\n            style: this.getCellStyle.bind(this) as any,\n        });\n\n        this.map.addLayer(gridClusterLayer);\n        this.map.gridClusterLayer = gridClusterLayer;\n\n        const kmeansLayer = new VectorLayer({\n            source: new VectorSource()\n        });\n\n        this.map.addLayer(kmeansLayer);\n        this.map.kmeansLayer = kmeansLayer;\n\n        this.map.on(\"click\", (event: any) => {\n\n            let hit = false;\n\n            this.map.forEachFeatureAtPixel(event.pixel, (feature: ExtendedFeature) => {\n\n                if (hit == false){\n\n                    if (feature.clustertype == \"cell\" || feature.clustertype == \"marker\"){\n                        hit = true;\n                        let zoom = this.getZoom();\n\n                        if (zoom >= this.maxZoom || feature.count == 1) {\n                            this.onMarkerFinalClick(feature);\n                        }\n\n                        else {\n                            this.markerClickFunction(feature.x, feature.y);\n                        }\n                    }\n                }\n            });\n        });\n\n        this.map.on(\"pointermove\", (event: any) => {\n            let pixel = this.map.getEventPixel(event.originalEvent);\n            let hit = this.map.hasFeatureAtPixel(pixel);\n            this.map.getViewport().style.cursor = hit ? 'pointer' : '';\n        });\n    }\n\n    createAreaLayer() {\n\n        const areaLayer = new VectorLayer({\n            source: new VectorSource(),\n            style: this.getAreaStyle.bind(this) as any,\n        });\n\n        const layers = this.map.getLayers();\n        layers.insertAt(2, areaLayer);\n        //this.map.addLayer(areaLayer);\n        this.map.areaLayer = areaLayer;\n    }\n\n    getMarkerIcon(cluster: Cluster) {\n\n        const piniconObj = this.selectPinIcon(cluster);\n\n        const icon = new Icon({\n            anchor: piniconObj.relativeAnchor,\n            crossOrigin: \"anonymous\",\n            src: piniconObj.url,\n            imgSize: piniconObj.size,\n            size: piniconObj.size\n        });\n\n        const styleOptions: StyleOptions = {\n            image: icon,\n        };\n\n        if (this.iconType === IconType.exact && cluster.count > 1){\n            styleOptions.text = new Text({\n                text: cluster.count.toString(),\n                font: 'bold 14px sans-serif',\n                fill: new Fill({color: '#FFF'}),\n                justify: 'center',\n                textBaseline: 'middle',\n                offsetY: 1,\n                padding: [0,0,0,0],\n            })\n        }\n        const style = new Style(styleOptions);\n\n        return style;\n          \n    }\n\n    drawMarker(cluster: Cluster) {\n\n        const style = this.getMarkerIcon(cluster);\n        const point = new Point([cluster.center.x, cluster.center.y]);\n\n        let marker = new Feature(point);\n\n        marker.setStyle(style);\n\n        let extendedMarker: ExtendedFeature = this.setMarkerProps(marker, cluster);\n        extendedMarker.clustertype = \"marker\";\n\n        this.map.kmeansLayer.getSource().addFeature(extendedMarker)\n\n        this.markerList.push(extendedMarker);\n    }\n\n    getCellStyle(feature: ExtendedFeature, resolution: number): Style {\n\n        const roundedCount = this.roundMarkerCount(feature.count);\n        const fillColor = this.gridFillColors[roundedCount];\n        const strokeColor = this.gridStrokeColors[roundedCount];\n        const strokeWeight = 2;\n\n        const style = new Style({\n            stroke: new Stroke({\n                color: strokeColor,\n                width: strokeWeight,\n            }),\n            fill: new Fill({\n                color: fillColor,\n            }),\n        });\n\n        return style;\n    }\n\n    drawCell(cluster: Cluster) {\n\n        const count = cluster.count;\n\n        if (count == 1) {\n            this.drawMarker(cluster)\n        }\n        else {\n\n            const geojson = {\n                \"type\": \"Feature\",\n                \"geometry\": cluster.geojson,\n            };\n\n            let feature = new GeoJSON().readFeature(geojson);\n\n            let extendedFeature: ExtendedFeature = this.setMarkerProps(feature, cluster);\n            extendedFeature.clustertype = \"cell\";\n\n            this.map.gridClusterLayer.getSource().addFeature(extendedFeature)\n\n        }\n\n    }\n\n    removeAllMarkers() {\n\n        \n        this.map.kmeansLayer.getSource().clear();\n\n        if (this.map.hasOwnProperty(\"gridClusterLayer\")) {\n            this.map.gridClusterLayer.getSource().clear();\n        }\n\n        this.markerList.length = 0;\n\n    }\n\n    addMapEventListeners () {\n        // unfortunately fires after loadend\n        this.map.addEventListener(\"moveend\", (event: any) => {\n\n            let newZoom = this.getZoom();\n            if (newZoom != this.currentZoom){\n                this.removeAllMarkers();\n                this.currentZoom = newZoom;\n            }\n            this.getClusters();\n        });\n    }\n\n    // Openlayers accumulates coordinates when panning across world borders\n    putXCoordinateIntoWorldBounds (XCoordinate: number): number {\n\n        let bounds = Bounds3857;\n\n        if (this.srid === SRIDS.EPSG4326) {\n            bounds = Bounds4326;\n        }\n\n        const worldWidth = bounds.maxX - bounds.minX;\n        const worldCount = Math.floor( Math.abs(XCoordinate) / worldWidth ) + 1;\n        const vector = worldWidth * worldCount;\n\n        if (XCoordinate < bounds.minX) {\n            // user panned to the right, map moved leftwards over the border\n            XCoordinate = XCoordinate + vector;\n        } else if (XCoordinate > bounds.maxX) {\n            // user panned to the left, map moved rightwards over the border\n            XCoordinate = XCoordinate - vector;\n        }\n\n        return XCoordinate;\n    }\n\n    getViewport(): Viewport {\n\n        const view = this.map.getView();\n\n        const extent = view.calculateExtent(this.map.getSize());\n\n        const left = extent[0];\n        const bottom = extent[1];\n        const right = extent[2];\n        const top = extent[3];\n\n        const viewportJSON = {\n            \"left\": this.putXCoordinateIntoWorldBounds(left),\n            \"top\": top,\n            \"right\": this.putXCoordinateIntoWorldBounds(right),\n            \"bottom\": bottom\n        };\n\n        return viewportJSON;\n        \n    }\n\n    getZoom(): number {\n        const view = this.map.getView();\n        return view.getZoom();\n    }\n\n    setZoom(zoom: number): void {\n        this.map.setZoom(zoom);\n    }\n\n\n    setMap(x: number, y: number, zoom: number): void {\n        const view = this.map.getView();\n        view.animate({\n            zoom: zoom,\n            center: [x, y],\n            duration: 500,\n        });\n    }\n\n}"],"names":[],"version":3,"file":"ancluster-openlayers.js.map"}