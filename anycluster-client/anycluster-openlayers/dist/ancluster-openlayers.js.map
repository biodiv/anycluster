{"mappings":"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","sources":["src/index.ts","src/anycluster-openlayers.ts"],"sourcesContent":["export {\n    ClusterMethod,\n    AnyclusterOpenLayers,\n} from \"./anycluster-openlayers\";","import {\n    AnyclusterClient,\n    AnyclusterClientSettings,\n    Viewport,\n    Cluster,\n    ClusterMethod,\n    GeoJSON as IGeoJSON,\n} from 'anycluster-client';\n\nexport {\n    ClusterMethod\n};\n\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\nimport { Icon, Stroke, Style, Fill } from 'ol/style';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport Feature from 'ol/Feature';\nimport Point from 'ol/geom/Point';\n\ninterface ExtendedFeature extends Feature {\n    x: number\n    y: number\n    count: number\n    clustertype: string\n}\n\nexport class AnyclusterOpenLayers extends AnyclusterClient {\n\n    currentZoom: number\n\n    constructor(map: any, apiUrl: string, markerFolderPath: string, settings: AnyclusterClientSettings) {\n        super(map, apiUrl, markerFolderPath, settings);\n        this.currentZoom = this.getZoom();\n    }\n\n\n    removeArea() {\n        if (this.map.hasOwnProperty(\"areaLayer\")) {\n            this.map.areaLayer.getSource().clear();\n        }\n    }\n\n    getAreaStyle(feature: Feature, resolution: number): Style {\n\n        const style = new Style({\n            stroke: new Stroke({\n                color: \"rgba(255, 0, 0, 1)\",\n                width: 2,\n            }),\n            fill: new Fill({\n                color: \"rgba(255, 0, 0, .3)\",\n            }),\n        });\n\n        return style;\n    }\n\n    addArea(geojson: IGeoJSON) {\n        if (!this.map.hasOwnProperty(\"areaLayer\")) {\n            this.createAreaLayer();\n        }\n\n        const features = new GeoJSON({\n            featureProjection: \"EPSG:3857\"\n        }).readFeatures(geojson);\n\n        \n        this.map.areaLayer.getSource().addFeatures(features);\n\n    }\n\n    createClusterLayers() {\n\n        const gridClusterLayer = new VectorLayer({\n            source: new VectorSource(),\n            style: this.getCellStyle.bind(this) as any,\n        });\n\n        this.map.addLayer(gridClusterLayer);\n        this.map.gridClusterLayer = gridClusterLayer;\n\n        const kmeansLayer = new VectorLayer({\n            source: new VectorSource()\n        });\n\n        this.map.addLayer(kmeansLayer);\n        this.map.kmeansLayer = kmeansLayer;\n\n        this.map.on(\"click\", (event: any) => {\n\n            let hit = false;\n\n            this.map.forEachFeatureAtPixel(event.pixel, (feature: ExtendedFeature) => {\n\n                if (hit == false){\n\n                    if (feature.clustertype == \"cell\" || feature.clustertype == \"marker\"){\n                        hit = true;\n                        let zoom = this.getZoom();\n\n                        if (zoom >= 13 || feature.count == 1) {\n                            this.onMarkerFinalClick(feature);\n                        }\n\n                        else {\n                            this.markerClickFunction(feature.x, feature.y);\n                        }\n                    }\n                }\n            });\n        });\n\n        this.map.on(\"pointermove\", (event: any) => {\n            let pixel = this.map.getEventPixel(event.originalEvent);\n            let hit = this.map.hasFeatureAtPixel(pixel);\n            this.map.getViewport().style.cursor = hit ? 'pointer' : '';\n        });\n    }\n\n    createAreaLayer() {\n\n        const areaLayer = new VectorLayer({\n            source: new VectorSource(),\n            style: this.getAreaStyle.bind(this) as any,\n        });\n\n        const layers = this.map.getLayers();\n        layers.insertAt(2, areaLayer);\n        //this.map.addLayer(areaLayer);\n        this.map.areaLayer = areaLayer;\n    }\n\n    getMarkerIcon(cluster: Cluster) {\n\n        const piniconObj = this.selectPinIcon(cluster);\n\n        const icon = new Icon({\n            anchor: piniconObj.relativeAnchor,\n            crossOrigin: \"anonymous\",\n            src: piniconObj.url,\n            imgSize: piniconObj.size,\n            size: piniconObj.size\n        });\n\n        const style = new Style({\n            image: icon\n        });\n\n        return style;\n          \n    }\n\n    drawMarker(cluster: Cluster) {\n\n        const style = this.getMarkerIcon(cluster);\n        const point = new Point([cluster.center.x, cluster.center.y])\n\n        let marker = new Feature(point);\n\n        marker.setStyle(style);\n\n        let extendedMarker: ExtendedFeature = this.setMarkerProps(marker, cluster);\n        extendedMarker.clustertype = \"marker\";\n\n        this.map.kmeansLayer.getSource().addFeature(extendedMarker)\n\n        this.markerList.push(extendedMarker);\n    }\n\n    getCellStyle(feature: ExtendedFeature, resolution: number): Style {\n\n        const roundedCount = this.roundMarkerCount(feature.count);\n        const fillColor = this.gridFillColors[roundedCount];\n        const strokeColor = this.gridStrokeColors[roundedCount];\n        const strokeWeight = 2;\n\n        const style = new Style({\n            stroke: new Stroke({\n                color: strokeColor,\n                width: strokeWeight,\n            }),\n            fill: new Fill({\n                color: fillColor,\n            }),\n        });\n\n        return style;\n    }\n\n    drawCell(cluster: Cluster) {\n\n        const count = cluster.count;\n\n        if (count == 1) {\n            this.drawMarker(cluster)\n        }\n        else {\n\n            const geojson = {\n                \"type\": \"Feature\",\n                \"geometry\": cluster.geojson,\n            };\n\n            let feature = new GeoJSON().readFeature(geojson);\n\n            let extendedFeature: ExtendedFeature = this.setMarkerProps(feature, cluster);\n            extendedFeature.clustertype = \"cell\";\n\n            this.map.gridClusterLayer.getSource().addFeature(extendedFeature)\n\n        }\n\n    }\n\n    removeAllMarkers() {\n\n        \n        this.map.kmeansLayer.getSource().clear();\n\n        if (this.map.hasOwnProperty(\"gridClusterLayer\")) {\n            this.map.gridClusterLayer.getSource().clear();\n        }\n\n        this.markerList.length = 0;\n\n    }\n\n    addMapEventListeners () {\n        // unfortunately fires after loadend\n        this.map.addEventListener(\"moveend\", (event: any) => {\n\n            let newZoom = this.getZoom();\n            if (newZoom != this.currentZoom){\n                this.removeAllMarkers();\n                this.currentZoom = newZoom;\n            }\n            this.getClusters();\n        });\n    }\n\n\n    getViewport(): Viewport {\n\n        const view = this.map.getView();\n\n        const extent = view.calculateExtent(this.map.getSize());\n\n        const left = extent[0];\n        const bottom = extent[1];\n        const right = extent[2];\n        const top = extent[3];\n\n        const viewportJSON = {\n            \"left\": left,\n            \"top\": top,\n            \"right\": right,\n            \"bottom\": bottom\n        };\n\n        return viewportJSON;\n        \n    }\n\n    getZoom(): number {\n        const view = this.map.getView();\n        return view.getZoom();\n    }\n\n    setZoom(zoom: number): void {\n        this.map.setZoom(zoom);\n    }\n\n\n    setMap(x: number, y: number, zoom: number): void {\n        const view = this.map.getView();\n        view.animate({\n            zoom: zoom,\n            center: [x, y],\n            duration: 500,\n        });\n    }\n\n}"],"names":[],"version":3,"file":"ancluster-openlayers.js.map"}