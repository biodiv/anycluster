{"mappings":"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","sources":["src/index.ts","src/anycluster-google.ts","../src/index.ts","../src/consts.ts","../src/anycluster.ts","../src/anycluster-client.ts","node_modules/@googlemaps/js-api-loader/dist/index.esm.js","node_modules/@googlemaps/js-api-loader/node_modules/fast-deep-equal/index.js","node_modules/@googlemaps/js-api-loader/src/index.ts"],"sourcesContent":["export {\n    ClusterMethod,\n    AnyclusterGoogle,\n} from \"./anycluster-google\";","import {\n    AnyclusterClient,\n    AnyclusterClientSettings,\n    Viewport,\n    Cluster,\n    ClusterMethod,\n    GeoJSON as IGeoJSON,\n} from 'anycluster-client';\n\nimport { Loader } from '@googlemaps/js-api-loader';\n\nexport {\n    ClusterMethod\n};\n\nexport class AnyclusterGoogle extends AnyclusterClient {\n\n    currentZoom: number\n\n    google: any\n\n    constructor(apiKey: string, map: any, apiUrl: string, markerFolderPath: string, settings: AnyclusterClientSettings) {\n\n        const loader = new Loader({\n            apiKey: apiKey,\n            version: \"monthly\",\n            libraries: [\"marker\", \"drawing\"]\n        });\n\n        loader.load().then((google) => {\n            this.google = google;\n        })\n            .catch(e => {\n                // do something\n            });\n\n        super(map, apiUrl, markerFolderPath, settings);\n\n        this.currentZoom = this.getZoom();\n\n    }\n\n\n    removeArea() {\n        this.map.data.forEach((feature) => {\n            this.map.data.remove(feature);\n        });\n    }\n\n    addArea(geojson: IGeoJSON) {\n\n        this.map.data.addGeoJson(\n            geojson\n        );\n\n    }\n\n    createClusterLayers() {\n\n        this.map.data.setStyle((feature) => {\n\n            if (feature.getProperty(\"clustertype\") == \"cell\"){\n\n                const roundedCount = this.roundMarkerCount(feature.getProperty(\"count\"));\n\n                const fillColor = this.gridStrokeColors[roundedCount];\n                const strokeColor = this.gridStrokeColors[roundedCount];\n                const strokeWeight = 1;\n\n                const style = {\n                    \"fillColor\": fillColor,\n                    //\"fillOpacity\": .5,\n                    \"strokeWeight\": strokeWeight,\n                    \"strokeColor\": strokeColor,\n                    //\"strokeOpacity\": .8\n                };\n\n                return style;\n            }\n\n        });\n\n        this.map.data.addListener(\"click\", (event: any) => {\n            const feature = event.feature;\n\n            if (feature.clustertype == \"cell\" || feature.clustertype == \"marker\"){\n\n                let zoom = this.getZoom();\n\n                if (zoom >= 13 || feature.count == 1) {\n                    this.onMarkerFinalClick(feature);\n                }\n\n                else {\n                    this.markerClickFunction(feature.x, feature.y);\n                }\n            }\n        });\n    }\n\n    createAreaLayer() {\n    }\n\n    getMarkerIcon(cluster: Cluster) {\n        // get the correct icon\n        const piniconObj = this.selectPinIcon(cluster);\n\n        const iconSize = new this.google.maps.Size(piniconObj.size[0], piniconObj.size[1]);\n        const anchor = new this.google.maps.Point(piniconObj.anchor[0], piniconObj.anchor[1]);\n\n        const markerIcon = {\n            \"url\": piniconObj.url,\n            \"size\": iconSize,\n            \"anchor\": anchor,\n        };\n\n        return markerIcon;\n    }\n\n    drawMarker(cluster: Cluster) {\n\n        const markerIcon = this.getMarkerIcon(cluster);\n\n        const markerOptions = {\n            \"map\": this.map,\n            \"position\": {\n                \"lat\": cluster.center.y,\n                \"lng\": cluster.center.x\n            },\n            \"icon\": markerIcon,\n        };\n\n        let marker = new this.google.maps.Marker(markerOptions);\n\n        marker = this.setMarkerProps(marker, cluster);\n\n        this.addMarkerClickListener(marker);\n\n        this.markerList.push(marker);\n    }\n\n    drawCell(cluster: Cluster) {\n        const count = cluster.count;\n\n        if (count == 1) {\n            this.drawMarker(cluster);\n        }\n\n        else {\n\n            const geojson = {\n                \"type\": \"Feature\",\n                \"geometry\": cluster.geojson,\n                \"properties\": {\n                    \"clustertype\" : \"cell\",\n                    \"x\": cluster.center.x,\n                    \"y\": cluster.center.y,\n                    \"count\": count,\n                    \"geojson\": cluster.geojson,\n                }\n            };\n\n            const cell = this.map.data.addGeoJson(geojson)[0];\n\n            cell.x = cluster.center.x;\n            cell.y = cluster.center.y;\n            cell.count = count;\n            cell.geojson = geojson;\n            cell.clustertype = \"cell\";\n\n        }\n    }\n\n    removeAllMarkers() {\n\n        for (let i = 0; i < this.markerList.length; i++) {\n            this.markerList[i].setMap(null);\n        }\n\n        this.map.data.forEach((feature) => {\n            if (feature.clustertype == \"cell\"){\n                this.map.data.remove(feature);\n            }\n        });\n\n        this.markerList.length = 0;\n    }\n\n    addMapEventListeners() {\n        this.map.addListener(\"dragend\", () => this.getClusters());\n        this.map.addListener(\"zoom_changed\", () => {\n            this.removeAllMarkers();\n            this.getClusters();\n        });\n    }\n\n\n    getViewport(): Viewport {\n\n        const latLngBounds = this.map.getBounds();\n        const northEast = latLngBounds.getNorthEast();\n        const southWest = latLngBounds.getSouthWest();\n\n        const viewport = {\n            \"left\": southWest.lng(),\n            \"right\": northEast.lng(),\n            \"top\": northEast.lat(),\n            \"bottom\": southWest.lat(),\n        };\n\n        return viewport;\n    }\n\n    getZoom(): number {\n        return this.map.getZoom();\n    }\n\n    setZoom(zoom: number): void {\n        this.map.setZoom(zoom);\n    }\n\n\n    setMap(x: number, y: number, zoom: number): void {\n\n        const mapOptions = {\n            \"center\": {\n                lat: y,\n                lng: x\n            },\n            \"zoom\": zoom,\n        };\n\n        this.map.setOptions(mapOptions);\n    }\n\n    addMarkerClickListener(marker) {\n\n        const zoom = this.getZoom();\n\n        if (zoom >= 13 || marker.count == 1) {\n            marker.addListener(\"click\", (event) => {\n                this.onMarkerFinalClick(marker);\n            });\n        }\n\n        else {\n            marker.addListener(\"click\", (event) => {\n                this.markerClickFunction(marker.x, marker.y);\n            });\n        }\n    }\n\n}","export {\n    ClusterMethod,\n    GeometryType,\n    IconType,\n    SRIDS,\n    Operators,\n    LogicalOperators,\n} from \"./consts\";\n\nexport { \n    Anycluster\n} from \"./anycluster\";\n\nexport {\n    AnyclusterClient\n} from \"./anycluster-client\";","\nexport interface MaxBounds {\n    minX: number,\n    maxX: number,\n    minY: number,\n    maxY: number\n}\n\nexport enum SRIDS {\n    EPSG4326 = 'EPSG:4326',\n    EPSG3857 = 'EPSG:3857'\n}\n\nexport enum ClusterMethod {\n    kmeans = 'kmeans',\n    grid = 'grid'\n}\n\n\nexport enum GeometryType {\n    viewport = 'viewport',\n    area = 'area'\n}\n\nexport enum IconType {\n    exact = 'exact',\n    rounded = 'rounded'\n}\n\nexport enum DefaultGridSizes {\n    grid = 64,\n    kmeans = 150\n}\n\nexport const DefaultMarkerImageSizes = {\n    1: [24, 39],\n    5: [30, 30],\n    10: [30, 30],\n    50: [40, 40],\n    100: [40, 40],\n    1000: [50, 50],\n    10000: [60, 60]\n}\n\nexport enum Operators {\n    in = 'in',\n    notIn = 'not in',\n    equals = '=',\n    unEquals = '!=',\n    largerThan = '>=',\n    smallerThan = '<=',\n    startswith = 'startswith',\n    contains = 'contains',\n}\n\nexport enum LogicalOperators {\n    AND = 'AND',\n    OR = 'OR',\n}","import { SRIDS, MaxBounds, ClusterMethod, GeometryType, Operators, LogicalOperators } from \"./consts\";\nimport { Point, GeoJSON, Coordinates, Viewport } from \"./geometry\";\n\nexport const Bounds4326: MaxBounds = Object.freeze({\n    minX: -179,\n    maxX: 179,\n    minY: -89,\n    maxY: 89\n})\n\n\nexport const Bounds3857: MaxBounds = Object.freeze({\n    minX: -20037500, //-20037508.34\n    maxX: 20037500, // 20037508.34\n    minY: -20048960, // -20048966.1\n    maxY: 20048960 //  20048966.1\n})\n\nexport interface Filter {\n    column: string\n    value: string | number | boolean\n    operator: Operators\n    logicalOperator?: LogicalOperators\n}\n\nexport interface NestedFilter {\n    filters : Filter[]\n    logicalOperator?: LogicalOperators\n}\n\nexport type FilterOrNestedFilter = Filter | NestedFilter;\n\nexport interface ClusterRequestData {\n    output_srid: SRIDS\n    geometry_type: GeometryType\n    geojson: GeoJSON\n    clear_cache: boolean\n    filters: FilterOrNestedFilter[]\n}\n\nexport type FilterList = Filter[];\n\nexport type FilterOrNestedFilterList = FilterOrNestedFilter[];\n\nexport interface GetKmeansClusterContentRequestData {\n    geometry_type: GeometryType\n    input_srid: SRIDS\n    x: number\n    y: number\n    ids: number[]\n}\n\nexport interface Modulations {\n    [name:string] : Filter | NestedFilter\n}\n\nexport interface MapContentCountRequestData extends ClusterRequestData {\n    modulations?: Modulations\n}\n\nexport interface GroupedMapContentRequestData extends ClusterRequestData {\n    group_by: string\n}\n\nexport class Anycluster {\n\n    maxBounds: MaxBounds\n\n    constructor(private apiUrl: string, public gridSize: number, public srid: SRIDS) {\n\n        if (this.srid == SRIDS.EPSG4326) {\n            this.maxBounds = Bounds4326;\n        }\n        else if (this.srid == SRIDS.EPSG3857) {\n            this.maxBounds = Bounds3857;\n        }\n        else {\n            throw new Error(`invalid srid given: ${this.srid} `);\n        }\n\n    }\n\n    async getGridCluster(zoom: number, data: ClusterRequestData) {\n        const url = `${this.apiUrl}grid/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters;\n    }\n\n    async getKmeansCluster(zoom: number, data: ClusterRequestData) {\n\n        const url = `${this.apiUrl}kmeans/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters\n    }\n\n    async getKmeansClusterContent(zoom: number, data: GetKmeansClusterContentRequestData) {\n\n        const url = `${this.apiUrl}get-kmeans-cluster-content/${zoom}/${this.gridSize}/`;\n\n        const clusterContent = await this.post(url, data);\n\n        return clusterContent;\n    }\n\n    async getDatasetContent(zoom: number, datasetId: number) {\n        const url = `${this.apiUrl}get-dataset-content/${zoom}/${this.gridSize}/${datasetId}/`;\n\n        const clusterContent = await this.get(url);\n\n        return clusterContent;\n    }\n\n    async getMapContentCount(zoom: number, data: MapContentCountRequestData) {\n        const url = `${this.apiUrl}get-map-content-count/${zoom}/${this.gridSize}/`;\n\n        const mapContentCount = await this.post(url, data)\n\n        return mapContentCount;\n    }\n\n    async getGroupedMapContents(zoom: number, data: GroupedMapContentRequestData) {\n        const url = `${this.apiUrl}get-grouped-map-contents/${zoom}/${this.gridSize}/`;\n\n        const groupedMapContents = await this.post(url, data);\n\n        return groupedMapContents;\n\n    }\n\n    viewportToGeoJSON(viewport: Viewport) {\n\n        const left = Math.max(viewport.left, this.maxBounds.minX);\n        const right = Math.min(viewport.right, this.maxBounds.maxX);\n        const top = Math.min(viewport.top, this.maxBounds.maxY);\n        const bottom = Math.max(viewport.bottom, this.maxBounds.minY);\n\n        const geometryType = \"Polygon\";\n\n        const coordinates = [[\n            [left, top],\n            [right, top],\n            [right, bottom],\n            [left, bottom],\n            [left, top]\n        ]];\n\n        const geoJSON = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": geometryType,\n                \"coordinates\": coordinates,\n                \"crs\": {\n                    \"type\": \"name\",\n                    \"properties\": {\n                        \"name\": this.srid\n                    }\n                }\n            }\n        };\n\n        return geoJSON;\n    }\n\n    async post(url: string, postData: object) {\n\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'POST',\n            body: JSON.stringify(postData),\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n\n    }\n\n    async get(url: string) {\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n    }\n}","\nimport { ClusterMethod, GeometryType, IconType, SRIDS, DefaultGridSizes, DefaultMarkerImageSizes } from \"./consts\";\nimport { GeoJSON, Marker, Cluster, Viewport } from \"./geometry\";\nimport {\n    Anycluster,\n    GetKmeansClusterContentRequestData,\n    ClusterRequestData,\n    MapContentCountRequestData,\n    GroupedMapContentRequestData,\n    Filter,\n    FilterList,\n    NestedFilter,\n    FilterOrNestedFilter,\n    FilterOrNestedFilterList,\n    Modulations\n} from \"./anycluster\";\n\n\nconst defaultGridFillColors = {\n    5: \"rgba(255, 192, 203, .5)\",\n    10: \"rgba(240, 128, 128, .5)\",\n    50: \"rgba(255, 127, 80, .5)\",\n    100: \"rgba(255, 165, 0, .5)\",\n    1000: \"rgba(255, 69, 0, .5)\",\n    10000: \"rgba(255, 0 , 0, .5)\"\n};\n\nconst defaultGridStrokeColors = {\n    5: \"pink\",\n    10: \"lightcoral\",\n    50: \"coral\",\n    100: \"orange\",\n    1000: \"orangered\",\n    10000: \"red\"\n};\n\nexport interface AnyclusterClientSettings {\n    srid?: SRIDS // srid of the map\n    kmeansGridSize?: number\n    gridGridSize?: number\n    clusterMethod?: ClusterMethod\n    geometryType?: GeometryType\n    area?: any\n    iconType?: IconType\n    onFinalClick?: Function\n    singlePinImages?: Record<string, string>\n    markerImageSizes?: Record<string, number[]>\n    gridFillColors?: Record<number, string>\n    gridStrokeColors?: Record<number, string>\n    onGotClusters?: () => void\n}\n\nexport class AnyclusterClient {\n\n    srid: SRIDS\n    kmeansGridSize: number\n    gridGridSize: number\n    clusterMethod: ClusterMethod\n    geometryType: GeometryType\n\n    area: GeoJSON | null\n    iconType: IconType\n\n    anycluster: Anycluster\n    markerList: any[]\n    onFinalClick: Function\n    onGotClusters: Function\n    singlePinImages?: Record<string, string>\n\n    markerImageSizes: Record<string, number[]>\n\n    gridFillColors: Record<number, string>\n    gridStrokeColors: Record<number, string>\n\n    filters: FilterOrNestedFilterList = []\n\n\n    constructor(public map: any, public apiUrl: string, public markerFolderPath: string, settings: AnyclusterClientSettings) {\n\n        this.map = map;\n        this.apiUrl = apiUrl;\n        this.markerFolderPath = markerFolderPath;\n\n        settings = settings || {};\n\n\n        // settings\n        this.srid = settings.srid ? settings.srid : SRIDS.EPSG4326;\n        this.kmeansGridSize = settings.gridGridSize ? settings.gridGridSize : DefaultGridSizes.kmeans;\n        this.gridGridSize = settings.gridGridSize ? settings.gridGridSize : DefaultGridSizes.grid;\n\n        this.clusterMethod = settings.clusterMethod ? settings.clusterMethod : ClusterMethod.kmeans;\n        this.geometryType = settings.geometryType ? settings.geometryType : GeometryType.viewport;\n\n        this.area = settings.area ? settings.area : null;\n        this.iconType = settings.iconType ? settings.iconType : IconType.rounded;\n\n        this.singlePinImages = settings.singlePinImages ? settings.singlePinImages : {};\n\n        this.markerImageSizes = settings.markerImageSizes ? settings.markerImageSizes : DefaultMarkerImageSizes;\n\n        this.gridFillColors = settings.gridFillColors ? settings.gridFillColors : defaultGridFillColors;\n        this.gridStrokeColors = settings.gridStrokeColors ? settings.gridStrokeColors : defaultGridStrokeColors;\n\n        // hooks\n        this.onGotClusters = settings.onGotClusters ? settings.onGotClusters : this._onGotClusters;\n        this.onFinalClick = settings.onFinalClick ? settings.onFinalClick : this._onFinalClick;\n\n\n        if (this.area) {\n            this.setArea(this.area);\n        }\n\n        const gridSize = this.getGridSize();\n        this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n\n        this.createClusterLayers();\n        this.markerList = [];\n\n        this.startClustering();\n    }\n\n    createClusterLayers(): void {\n        throw new Error(\"NotImplementedError: createClusterLayers\");\n    }\n\n    addArea(geojson: object): void {\n        throw new Error(\"NotImplementedError: addArea\");\n    }\n\n    removeArea(): void {\n        throw new Error(\"NotImplementedError: removeArea\");\n    }\n\n    removeAllMarkers(): void {\n        throw new Error(\"NotImplementedError: removeAllMarkers\");\n    }\n\n    getZoom(): number {\n        throw new Error(\"NotImplementedError: getZoom\");\n    }\n\n    setMap(x: number, y: number, zoom: number): void {\n        throw new Error(\"NotImplementedError: setMap\");\n    }\n\n    getViewport(): Viewport {\n        throw new Error(\"NotImplementedError: setMap\");\n    }\n\n    addMapEventListeners(): void {\n        throw new Error(\"NotImplementedError: addMapEventListeners\");\n    }\n\n    drawMarker(cluster: Cluster): void {\n        throw new Error(\"NotImplementedError: drawMarker\");\n    }\n\n    drawCell(cluster: Cluster): void {\n        throw new Error(\"NotImplementedError: drawCell\");\n    }\n\n    getAreaContent(geojson: GeoJSON): void {\n        throw new Error(\"NotImplementedError: getAreaContent\");\n    }\n\n\n    getGridSize(): number {\n        if (this.clusterMethod == ClusterMethod.grid) {\n            return this.gridGridSize;\n        }\n\n        return this.kmeansGridSize;\n    }\n\n    setClusterMethod(clusterMethod: ClusterMethod) {\n\n        if (clusterMethod == ClusterMethod.grid) {\n            this.area = null;\n            this.geometryType = GeometryType.viewport;\n            this.removeArea();\n        }\n\n        this.removeAllMarkers();\n        this.clusterMethod = clusterMethod;\n        const gridSize = this.getGridSize();\n        this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n        this.markerList = [];\n        this.getClusters(true);\n    }\n\n    setArea(geojson: GeoJSON) {\n\n        this.area = geojson;\n\n        this.removeArea();\n\n        if (geojson == null) {\n            this.geometryType = GeometryType.viewport;\n            this.setClusterMethod(ClusterMethod.kmeans);\n        }\n        else {\n\n            this.addArea(geojson);\n\n            this.geometryType = GeometryType.area;\n\n            this.setClusterMethod(ClusterMethod.kmeans);\n        }\n    }\n\n    getSinglePinImageURL(cluster: Cluster) {\n\n        const pinimg = cluster.pinimg;\n\n        let url = `${this.markerFolderPath}pin_unknown.png`;\n\n        if (this.singlePinImages && pinimg && pinimg in this.singlePinImages) {\n            url = this.singlePinImages[pinimg];\n        }\n\n        return url\n\n    }\n\n    selectPinIcon(cluster: Cluster) {\n\n        const count = cluster.count;\n\n        let markerImageUrl = this.getSinglePinImageURL(cluster);\n        let pinicon = \"1\";\n\n        if (count > 10000) {\n            pinicon = \"10000\";\n        }\n\n        else if (count > 1000) {\n            pinicon = \"1000\";\n        }\n\n        else if (count > 100) {\n            pinicon = \"100\";\n        }\n\n        else if (count > 50) {\n            pinicon = \"50\";\n        }\n\n        else if (count > 10) {\n            pinicon = \"10\";\n        }\n\n        else if (count > 1) {\n            pinicon = \"5\";\n        }\n\n        if (count > 1) {\n            if (this.iconType == IconType.exact) {\n                markerImageUrl = `${this.markerFolderPath}${pinicon}_empty.png`;\n            }\n            else {\n                markerImageUrl = `${this.markerFolderPath}${pinicon}.png`;\n            }\n        }\n\n        const size = this.markerImageSizes[pinicon];\n        let anchor = [Math.round(size[0] / 2), size[1] - 1];\n        let relativeAnchor = [0.5, 1];\n\n        if (count > 1) {\n            anchor = [Math.round((size[0] / 2)), Math.round(size[1] / 2)];\n            relativeAnchor = [0.5, 0.5];\n        }\n\n        const imgObj = {\n            url: markerImageUrl,\n            size: size,\n            anchor: anchor,\n            relativeAnchor: relativeAnchor,\n            popupAnchor: [0, -Math.round(size[1]) + 8]\n        }\n\n        return imgObj;\n\n    }\n\n    // marker can be an openlayers Feature or a L.marker\n    setMarkerProps(marker: any, cluster: Cluster) {\n\n        // add properties required by anycluster\n        marker.x = cluster.center.x;\n        marker.y = cluster.center.y;\n        marker.count = cluster.count;\n\n        if (cluster.hasOwnProperty(\"ids\")) {\n            marker.ids = cluster.ids;\n        }\n\n        if (cluster.hasOwnProperty(\"id\")) {\n            marker.id = cluster.id;\n        }\n\n        if (cluster.hasOwnProperty(\"geojson\")) {\n\n            /*const geojson = {\n                \"type\": \"Feature\",\n                \"count\": cluster.count,\n                \"geometry\": cluster.geojson,\n                \"properties\": {\n                    \"count\": cluster.count\n                },\n                \"crs\" : {\n                    \"type\" : \"name\",\n                    \"properties\" : {\n                        \"name\" : this.srid\n                    }\n                }\n            };*/\n\n            marker.geojson = cluster.geojson;\n        }\n\n        return marker;\n\n    }\n\n    markerClickFunction(x: number, y: number) {\n        this.removeAllMarkers();\n        let zoom = this.getZoom();\n        zoom = zoom + 3;\n        this.setMap(x, y, zoom);\n    }\n\n    async onMarkerFinalClick(marker: any) {\n\n        const zoom = this.getZoom();\n        const x = marker.x;\n        const y = marker.y;\n        const ids = marker.ids;\n\n        if (this.clusterMethod == ClusterMethod.kmeans) {\n\n            const postData = {\n                \"geometry_type\": this.geometryType,\n                \"input_srid\": this.srid,\n                \"x\": x,\n                \"y\": y,\n                \"ids\": ids,\n                \"filters\": this.filters\n            } as GetKmeansClusterContentRequestData;\n\n            const data = await this.anycluster.getKmeansClusterContent(zoom, postData);\n\n            this.onFinalClick(marker, data);\n\n        }\n        else if (this.clusterMethod = ClusterMethod.grid) {\n\n            if (marker.count == 1) {\n                const data = await this.anycluster.getDatasetContent(zoom, marker.id);\n                this.onFinalClick(marker, data);\n            }\n            else {\n                const geojson = marker[\"geojson\"];\n                const data = await this.getAreaContent(geojson);\n\n                this.onFinalClick(marker, data);\n            }\n\n        }\n    }\n\n    roundMarkerCount(count: number): number {\n\n        if (count == 1) {\n            count = 1;\n        }\n        else if (count <= 5) {\n            count = 5;\n        }\n        else if (count <= 10) {\n            count = 10;\n        }\n        else if (count <= 50) {\n            count = 50;\n        }\n        else if (count <= 100) {\n            count = 100;\n        }\n        else if (count <= 1000) {\n            count = 1000;\n        }\n        else {\n            count = 10000;\n        }\n\n        return count;\n    }\n\n    getClusterGeometry() {\n        let geoJSON;\n\n        if (this.geometryType == GeometryType.viewport) {\n            const viewport = this.getViewport();\n            geoJSON = this.anycluster.viewportToGeoJSON(viewport);\n        }\n        else if (this.geometryType == GeometryType.area && this.area) {\n            geoJSON = this.area;\n        }\n        else {\n            throw new Error('No cluster geometry found');\n        }\n\n        return geoJSON;\n\n    }\n\n    async getClusters(clearCache = false) {\n\n        const geoJSON = this.getClusterGeometry()\n\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": clearCache,\n            \"filters\": this.filters\n        } as ClusterRequestData;\n\n        const zoom = this.getZoom();\n\n        if (this.clusterMethod == ClusterMethod.kmeans) {\n\n\n            const clusters: Cluster[] = await this.anycluster.getKmeansCluster(zoom, postData);\n\n            if (clusters.length > 0) {\n                clusters.forEach(cluster => {\n                    this.drawMarker(cluster);\n                });\n            }\n        }\n        else if (this.clusterMethod == ClusterMethod.grid) {\n            const clusters: Cluster[] = await this.anycluster.getGridCluster(zoom, postData);\n\n            if (clusters.length > 0) {\n                clusters.forEach(cluster => {\n                    this.drawCell(cluster);\n                });\n            }\n        }\n        else {\n            throw new Error(`Invalid clusterMethod: ${this.clusterMethod}`);\n        }\n\n        this.onGotClusters();\n\n    }\n\n    startClustering() {\n        this.getClusters(true);\n        this.addMapEventListeners();\n    }\n\n    filtersAreEqual(filter1: FilterOrNestedFilter, filter2: FilterOrNestedFilter): boolean {\n        if ('column' in filter1 && 'column' in filter2) {\n            if (filter1.column == filter2.column && filter1.value == filter2.value && filter1.operator == filter2.operator) {\n                return true;\n            }\n        }\n        // testing with json.stringify is not ideal because {\"a\":1,\"b\":2} === {\"b\":2,\"a\":1} returns false\n        else if (JSON.stringify(filter1) === JSON.stringify(filter2)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    // filtering\n    filter(filter: Filter | NestedFilter | FilterOrNestedFilter[], reloadMarkers?: boolean) {\n\n        if (Array.isArray(filter)) {\n            this.filters = filter;\n        }\n        else {\n            this.filters = [filter];\n        }\n        this.postFilterChange(reloadMarkers);\n    }\n\n    addFilter(filter: Filter, reloadMarkers?: boolean) {\n\n        let filterExists = false;\n\n        for (let f = 0; f < this.filters.length; f++) {\n            let existingFilter: FilterOrNestedFilter = this.filters[f];\n\n            if (this.filtersAreEqual(filter, existingFilter)) {\n                filterExists = true;\n                break;\n            }\n\n        }\n\n        if (!filterExists) {\n            this.filters.push(filter);\n        }\n\n        this.postFilterChange(reloadMarkers);\n    }\n\n    addFilters(filtersToAdd: FilterList, reloadMarkers?: boolean) {\n\n        for (let fa = 0; fa < filtersToAdd.length; fa++) {\n            let filter = filtersToAdd[fa];\n            this.addFilter(filter, false);\n        }\n        this.postFilterChange(reloadMarkers);\n    }\n\n    removeFilter(filter: Filter, reloadMarkers?: boolean) {\n\n        for (let f = 0; f < this.filters.length; f++) {\n            let existingFilter: FilterOrNestedFilter = this.filters[f];\n\n            if (this.filtersAreEqual(filter, existingFilter)) {\n                this.filters.splice(f, 1);\n                break;\n            }\n        }\n        this.postFilterChange(reloadMarkers);\n    }\n\n    removeFilters(filtersToRemove: FilterList, reloadMarkers?: boolean) {\n\n        for (let fr = 0; fr < filtersToRemove.length; fr++) {\n\n            let filter = filtersToRemove[fr];\n\n            this.removeFilter(filter, false);\n        }\n\n        this.postFilterChange(reloadMarkers);\n    }\n\n    resetFilters(reloadMarkers?: boolean) {\n        this.filters = [];\n        this.postFilterChange(reloadMarkers);\n    }\n\n    postFilterChange(reloadMarkers?: boolean) {\n        if (reloadMarkers != false) {\n            reloadMarkers = true;\n        }\n        if (reloadMarkers == true) {\n            this.removeAllMarkers();\n            this.getClusters(true);\n        }\n    }\n\n    /**\n     * methods for getting counts of objects on the current map / geometry\n     */\n\n    async getMapContentCount(modulations?: Modulations) {\n\n        const geoJSON = this.getClusterGeometry()\n\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": true,\n            \"filters\": this.filters,\n            \"modulations\": modulations,\n        } as MapContentCountRequestData;\n\n        const zoom = this.getZoom();\n\n        const data = await this.anycluster.getMapContentCount(zoom, postData);\n\n        return data;\n    }\n\n    async getGroupedMapContents(groupBy: string) {\n\n        const geoJSON = this.getClusterGeometry()\n\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": true,\n            \"filters\": this.filters,\n            \"group_by\": groupBy,\n        } as GroupedMapContentRequestData;\n\n        const zoom = this.getZoom();\n\n        const data = await this.anycluster.getGroupedMapContents(zoom, postData);\n\n        return data;\n\n    }\n\n    // hooks\n    _onFinalClick(marker: Marker, data: any) {\n        alert(JSON.stringify(data));\n    }\n\n    _onGotClusters() { }\n\n}","// do not edit .js files directly - edit src/index.jst\n\n\n\nvar fastDeepEqual = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at.\n *\n *      Http://www.apache.org/licenses/LICENSE-2.0.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_ID = \"__googleMapsScriptId\";\n/**\n * The status of the [[Loader]].\n */\nvar LoaderStatus;\n(function (LoaderStatus) {\n    LoaderStatus[LoaderStatus[\"INITIALIZED\"] = 0] = \"INITIALIZED\";\n    LoaderStatus[LoaderStatus[\"LOADING\"] = 1] = \"LOADING\";\n    LoaderStatus[LoaderStatus[\"SUCCESS\"] = 2] = \"SUCCESS\";\n    LoaderStatus[LoaderStatus[\"FAILURE\"] = 3] = \"FAILURE\";\n})(LoaderStatus || (LoaderStatus = {}));\n/**\n * [[Loader]] makes it easier to add Google Maps JavaScript API to your application\n * dynamically using\n * [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n * It works by dynamically creating and appending a script node to the the\n * document head and wrapping the callback function so as to return a promise.\n *\n * ```\n * const loader = new Loader({\n *   apiKey: \"\",\n *   version: \"weekly\",\n *   libraries: [\"places\"]\n * });\n *\n * loader.load().then((google) => {\n *   const map = new google.maps.Map(...)\n * })\n * ```\n */\nclass Loader {\n    /**\n     * Creates an instance of Loader using [[LoaderOptions]]. No defaults are set\n     * using this library, instead the defaults are set by the Google Maps\n     * JavaScript API server.\n     *\n     * ```\n     * const loader = Loader({apiKey, version: 'weekly', libraries: ['places']});\n     * ```\n     */\n    constructor({ apiKey, authReferrerPolicy, channel, client, id = DEFAULT_ID, language, libraries = [], mapIds, nonce, region, retries = 3, url = \"https://maps.googleapis.com/maps/api/js\", version, }) {\n        this.CALLBACK = \"__googleMapsCallback\";\n        this.callbacks = [];\n        this.done = false;\n        this.loading = false;\n        this.errors = [];\n        this.apiKey = apiKey;\n        this.authReferrerPolicy = authReferrerPolicy;\n        this.channel = channel;\n        this.client = client;\n        this.id = id || DEFAULT_ID; // Do not allow empty string\n        this.language = language;\n        this.libraries = libraries;\n        this.mapIds = mapIds;\n        this.nonce = nonce;\n        this.region = region;\n        this.retries = retries;\n        this.url = url;\n        this.version = version;\n        if (Loader.instance) {\n            if (!fastDeepEqual(this.options, Loader.instance.options)) {\n                throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(Loader.instance.options)}`);\n            }\n            return Loader.instance;\n        }\n        Loader.instance = this;\n    }\n    get options() {\n        return {\n            version: this.version,\n            apiKey: this.apiKey,\n            channel: this.channel,\n            client: this.client,\n            id: this.id,\n            libraries: this.libraries,\n            language: this.language,\n            region: this.region,\n            mapIds: this.mapIds,\n            nonce: this.nonce,\n            url: this.url,\n            authReferrerPolicy: this.authReferrerPolicy,\n        };\n    }\n    get status() {\n        if (this.errors.length) {\n            return LoaderStatus.FAILURE;\n        }\n        if (this.done) {\n            return LoaderStatus.SUCCESS;\n        }\n        if (this.loading) {\n            return LoaderStatus.LOADING;\n        }\n        return LoaderStatus.INITIALIZED;\n    }\n    get failed() {\n        return this.done && !this.loading && this.errors.length >= this.retries + 1;\n    }\n    /**\n     * CreateUrl returns the Google Maps JavaScript API script url given the [[LoaderOptions]].\n     *\n     * @ignore\n     */\n    createUrl() {\n        let url = this.url;\n        url += `?callback=${this.CALLBACK}`;\n        if (this.apiKey) {\n            url += `&key=${this.apiKey}`;\n        }\n        if (this.channel) {\n            url += `&channel=${this.channel}`;\n        }\n        if (this.client) {\n            url += `&client=${this.client}`;\n        }\n        if (this.libraries.length > 0) {\n            url += `&libraries=${this.libraries.join(\",\")}`;\n        }\n        if (this.language) {\n            url += `&language=${this.language}`;\n        }\n        if (this.region) {\n            url += `&region=${this.region}`;\n        }\n        if (this.version) {\n            url += `&v=${this.version}`;\n        }\n        if (this.mapIds) {\n            url += `&map_ids=${this.mapIds.join(\",\")}`;\n        }\n        if (this.authReferrerPolicy) {\n            url += `&auth_referrer_policy=${this.authReferrerPolicy}`;\n        }\n        return url;\n    }\n    deleteScript() {\n        const script = document.getElementById(this.id);\n        if (script) {\n            script.remove();\n        }\n    }\n    /**\n     * Load the Google Maps JavaScript API script and return a Promise.\n     */\n    load() {\n        return this.loadPromise();\n    }\n    /**\n     * Load the Google Maps JavaScript API script and return a Promise.\n     *\n     * @ignore\n     */\n    loadPromise() {\n        return new Promise((resolve, reject) => {\n            this.loadCallback((err) => {\n                if (!err) {\n                    resolve(window.google);\n                }\n                else {\n                    reject(err.error);\n                }\n            });\n        });\n    }\n    /**\n     * Load the Google Maps JavaScript API script with a callback.\n     */\n    loadCallback(fn) {\n        this.callbacks.push(fn);\n        this.execute();\n    }\n    /**\n     * Set the script on document.\n     */\n    setScript() {\n        if (document.getElementById(this.id)) {\n            // TODO wrap onerror callback for cases where the script was loaded elsewhere\n            this.callback();\n            return;\n        }\n        const url = this.createUrl();\n        const script = document.createElement(\"script\");\n        script.id = this.id;\n        script.type = \"text/javascript\";\n        script.src = url;\n        script.onerror = this.loadErrorCallback.bind(this);\n        script.defer = true;\n        script.async = true;\n        if (this.nonce) {\n            script.nonce = this.nonce;\n        }\n        document.head.appendChild(script);\n    }\n    /**\n     * Reset the loader state.\n     */\n    reset() {\n        this.deleteScript();\n        this.done = false;\n        this.loading = false;\n        this.errors = [];\n        this.onerrorEvent = null;\n    }\n    resetIfRetryingFailed() {\n        if (this.failed) {\n            this.reset();\n        }\n    }\n    loadErrorCallback(e) {\n        this.errors.push(e);\n        if (this.errors.length <= this.retries) {\n            const delay = this.errors.length * Math.pow(2, this.errors.length);\n            console.log(`Failed to load Google Maps script, retrying in ${delay} ms.`);\n            setTimeout(() => {\n                this.deleteScript();\n                this.setScript();\n            }, delay);\n        }\n        else {\n            this.onerrorEvent = e;\n            this.callback();\n        }\n    }\n    setCallback() {\n        window.__googleMapsCallback = this.callback.bind(this);\n    }\n    callback() {\n        this.done = true;\n        this.loading = false;\n        this.callbacks.forEach((cb) => {\n            cb(this.onerrorEvent);\n        });\n        this.callbacks = [];\n    }\n    execute() {\n        this.resetIfRetryingFailed();\n        if (this.done) {\n            this.callback();\n        }\n        else {\n            // short circuit and warn if google.maps is already loaded\n            if (window.google && window.google.maps && window.google.maps.version) {\n                console.warn(\"Google Maps already loaded outside @googlemaps/js-api-loader.\" +\n                    \"This may result in undesirable behavior as options and script parameters may not match.\");\n                this.callback();\n                return;\n            }\n            if (this.loading) ;\n            else {\n                this.loading = true;\n                this.setCallback();\n                this.setScript();\n            }\n        }\n    }\n}\n\nexport { DEFAULT_ID, Loader, LoaderStatus };\n//# sourceMappingURL=index.esm.js.map\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at.\n *\n *      Http://www.apache.org/licenses/LICENSE-2.0.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport isEqual from \"fast-deep-equal\";\n\n/**\n * @ignore\n */\ndeclare global {\n  interface Window {\n    __googleMapsCallback: (e: Event) => void;\n  }\n}\n\nexport const DEFAULT_ID = \"__googleMapsScriptId\";\n\nexport type Libraries = (\n  | \"drawing\"\n  | \"geometry\"\n  | \"localContext\"\n  | \"marker\"\n  | \"places\"\n  | \"visualization\"\n)[];\n\n/**\n * The Google Maps JavaScript API\n * [documentation](https://developers.google.com/maps/documentation/javascript/tutorial)\n * is the authoritative source for [[LoaderOptions]].\n/**\n * Loader options\n */\nexport interface LoaderOptions {\n  /**\n   * See https://developers.google.com/maps/documentation/javascript/get-api-key.\n   */\n  apiKey: string;\n  /**\n   * @deprecated See https://developers.google.com/maps/premium/overview.\n   */\n  channel?: string;\n  /**\n   * @deprecated See https://developers.google.com/maps/premium/overview, use `apiKey` instead.\n   */\n  client?: string;\n  /**\n   * In your application you can specify release channels or version numbers:\n   *\n   * The weekly version is specified with `version=weekly`. This version is\n   * updated once per week, and is the most current.\n   *\n   * ```\n   * const loader = Loader({apiKey, version: 'weekly'});\n   * ```\n   *\n   * The quarterly version is specified with `version=quarterly`. This version\n   * is updated once per quarter, and is the most predictable.\n   *\n   * ```\n   * const loader = Loader({apiKey, version: 'quarterly'});\n   * ```\n   *\n   * The version number is specified with `version=n.nn`. You can choose\n   * `version=3.40`, `version=3.39`, or `version=3.38`. Version numbers are\n   * updated once per quarter.\n   *\n   * ```\n   * const loader = Loader({apiKey, version: '3.40'});\n   * ```\n   *\n   * If you do not explicitly specify a version, you will receive the\n   * weekly version by default.\n   */\n  version?: string;\n  /**\n   * The id of the script tag. Before adding a new script, the Loader will check for an existing one.\n   */\n  id?: string;\n  /**\n   * When loading the Maps JavaScript API via the URL you may optionally load\n   * additional libraries through use of the libraries URL parameter. Libraries\n   * are modules of code that provide additional functionality to the main Maps\n   * JavaScript API but are not loaded unless you specifically request them.\n   *\n   * ```\n   * const loader = Loader({\n   *  apiKey,\n   *  libraries: ['drawing', 'geometry', 'places', 'visualization'],\n   * });\n   * ```\n   *\n   * Set the [list of libraries](https://developers.google.com/maps/documentation/javascript/libraries) for more options.\n   */\n  libraries?: Libraries;\n  /**\n   * By default, the Maps JavaScript API uses the user's preferred language\n   * setting as specified in the browser, when displaying textual information\n   * such as the names for controls, copyright notices, driving directions and\n   * labels on maps. In most cases, it's preferable to respect the browser\n   * setting. However, if you want the Maps JavaScript API to ignore the\n   * browser's language setting, you can force it to display information in a\n   * particular language when loading the Maps JavaScript API code.\n   *\n   * For example, the following example localizes the language to Japan:\n   *\n   * ```\n   * const loader = Loader({apiKey, language: 'ja', region: 'JP'});\n   * ```\n   *\n   * See the [list of supported\n   * languages](https://developers.google.com/maps/faq#languagesupport). Note\n   * that new languages are added often, so this list may not be exhaustive.\n   *\n   */\n  language?: string;\n  /**\n   * When you load the Maps JavaScript API from maps.googleapis.com it applies a\n   * default bias for application behavior towards the United States. If you\n   * want to alter your application to serve different map tiles or bias the\n   * application (such as biasing geocoding results towards the region), you can\n   * override this default behavior by adding a region parameter when loading\n   * the Maps JavaScript API code.\n   *\n   * The region parameter accepts Unicode region subtag identifiers which\n   * (generally) have a one-to-one mapping to country code Top-Level Domains\n   * (ccTLDs). Most Unicode region identifiers are identical to ISO 3166-1\n   * codes, with some notable exceptions. For example, Great Britain's ccTLD is\n   * \"uk\" (corresponding to the domain .co.uk) while its region identifier is\n   * \"GB.\"\n   *\n   * For example, the following example localizes the map to the United Kingdom:\n   *\n   * ```\n   * const loader = Loader({apiKey, region: 'GB'});\n   * ```\n   */\n  region?: string;\n  /**\n   * @deprecated Passing `mapIds` is no longer required in the script tag.\n   */\n  mapIds?: string[];\n  /**\n   * Use a custom url and path to load the Google Maps API script.\n   */\n  url?: string;\n  /**\n   * Use a cryptographic nonce attribute.\n   */\n  nonce?: string;\n  /**\n   * The number of script load retries.\n   */\n  retries?: number;\n  /**\n   * Maps JS customers can configure HTTP Referrer Restrictions in the Cloud\n   * Console to limit which URLs are allowed to use a particular API Key. By\n   * default, these restrictions can be configured to allow only certain paths\n   * to use an API Key. If any URL on the same domain or origin may use the API\n   * Key, you can set `auth_referrer_policy=origin` to limit the amount of data\n   * sent when authorizing requests from the Maps JavaScript API. This is\n   * available starting in version 3.46. When this parameter is specified and\n   * HTTP Referrer Restrictions are enabled on Cloud Console, Maps JavaScript\n   * API will only be able to load if there is an HTTP Referrer Restriction that\n   * matches the current website's domain without a path specified.\n   */\n  authReferrerPolicy?: \"origin\";\n}\n\n/**\n * The status of the [[Loader]].\n */\nexport enum LoaderStatus {\n  INITIALIZED,\n  LOADING,\n  SUCCESS,\n  FAILURE,\n}\n\n/**\n * [[Loader]] makes it easier to add Google Maps JavaScript API to your application\n * dynamically using\n * [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n * It works by dynamically creating and appending a script node to the the\n * document head and wrapping the callback function so as to return a promise.\n *\n * ```\n * const loader = new Loader({\n *   apiKey: \"\",\n *   version: \"weekly\",\n *   libraries: [\"places\"]\n * });\n *\n * loader.load().then((google) => {\n *   const map = new google.maps.Map(...)\n * })\n * ```\n */\nexport class Loader {\n  private static instance: Loader;\n  /**\n   * See [[LoaderOptions.version]]\n   */\n  public readonly version: string;\n  /**\n   * See [[LoaderOptions.apiKey]]\n   */\n  public readonly apiKey: string;\n  /**\n   * See [[LoaderOptions.channel]]\n   */\n  public readonly channel: string;\n  /**\n   * See [[LoaderOptions.client]]\n   */\n  public readonly client: string;\n  /**\n   * See [[LoaderOptions.id]]\n   */\n  public readonly id: string;\n  /**\n   * See [[LoaderOptions.libraries]]\n   */\n  public readonly libraries: Libraries;\n  /**\n   * See [[LoaderOptions.language]]\n   */\n  public readonly language: string;\n\n  /**\n   * See [[LoaderOptions.region]]\n   */\n  public readonly region: string;\n\n  /**\n   * See [[LoaderOptions.mapIds]]\n   */\n  public readonly mapIds: string[];\n\n  /**\n   * See [[LoaderOptions.nonce]]\n   */\n  public readonly nonce: string | null;\n\n  /**\n   * See [[LoaderOptions.retries]]\n   */\n  public readonly retries: number;\n\n  /**\n   * See [[LoaderOptions.url]]\n   */\n  public readonly url: string;\n  /**\n   * See [[LoaderOptions.authReferrerPolicy]]\n   */\n  public readonly authReferrerPolicy: \"origin\";\n\n  private CALLBACK = \"__googleMapsCallback\";\n  private callbacks: ((e: ErrorEvent) => void)[] = [];\n  private done = false;\n  private loading = false;\n  private onerrorEvent: ErrorEvent;\n  private errors: ErrorEvent[] = [];\n\n  /**\n   * Creates an instance of Loader using [[LoaderOptions]]. No defaults are set\n   * using this library, instead the defaults are set by the Google Maps\n   * JavaScript API server.\n   *\n   * ```\n   * const loader = Loader({apiKey, version: 'weekly', libraries: ['places']});\n   * ```\n   */\n  constructor({\n    apiKey,\n    authReferrerPolicy,\n    channel,\n    client,\n    id = DEFAULT_ID,\n    language,\n    libraries = [],\n    mapIds,\n    nonce,\n    region,\n    retries = 3,\n    url = \"https://maps.googleapis.com/maps/api/js\",\n    version,\n  }: LoaderOptions) {\n    this.apiKey = apiKey;\n    this.authReferrerPolicy = authReferrerPolicy;\n    this.channel = channel;\n    this.client = client;\n    this.id = id || DEFAULT_ID; // Do not allow empty string\n    this.language = language;\n    this.libraries = libraries;\n    this.mapIds = mapIds;\n    this.nonce = nonce;\n    this.region = region;\n    this.retries = retries;\n    this.url = url;\n    this.version = version;\n\n    if (Loader.instance) {\n      if (!isEqual(this.options, Loader.instance.options)) {\n        throw new Error(\n          `Loader must not be called again with different options. ${JSON.stringify(\n            this.options\n          )} !== ${JSON.stringify(Loader.instance.options)}`\n        );\n      }\n\n      return Loader.instance;\n    }\n\n    Loader.instance = this;\n  }\n\n  public get options(): LoaderOptions {\n    return {\n      version: this.version,\n      apiKey: this.apiKey,\n      channel: this.channel,\n      client: this.client,\n      id: this.id,\n      libraries: this.libraries,\n      language: this.language,\n      region: this.region,\n      mapIds: this.mapIds,\n      nonce: this.nonce,\n      url: this.url,\n      authReferrerPolicy: this.authReferrerPolicy,\n    };\n  }\n\n  public get status(): LoaderStatus {\n    if (this.errors.length) {\n      return LoaderStatus.FAILURE;\n    }\n    if (this.done) {\n      return LoaderStatus.SUCCESS;\n    }\n    if (this.loading) {\n      return LoaderStatus.LOADING;\n    }\n    return LoaderStatus.INITIALIZED;\n  }\n\n  private get failed(): boolean {\n    return this.done && !this.loading && this.errors.length >= this.retries + 1;\n  }\n\n  /**\n   * CreateUrl returns the Google Maps JavaScript API script url given the [[LoaderOptions]].\n   *\n   * @ignore\n   */\n  public createUrl(): string {\n    let url = this.url;\n\n    url += `?callback=${this.CALLBACK}`;\n\n    if (this.apiKey) {\n      url += `&key=${this.apiKey}`;\n    }\n\n    if (this.channel) {\n      url += `&channel=${this.channel}`;\n    }\n\n    if (this.client) {\n      url += `&client=${this.client}`;\n    }\n\n    if (this.libraries.length > 0) {\n      url += `&libraries=${this.libraries.join(\",\")}`;\n    }\n\n    if (this.language) {\n      url += `&language=${this.language}`;\n    }\n\n    if (this.region) {\n      url += `&region=${this.region}`;\n    }\n\n    if (this.version) {\n      url += `&v=${this.version}`;\n    }\n\n    if (this.mapIds) {\n      url += `&map_ids=${this.mapIds.join(\",\")}`;\n    }\n\n    if (this.authReferrerPolicy) {\n      url += `&auth_referrer_policy=${this.authReferrerPolicy}`;\n    }\n\n    return url;\n  }\n\n  public deleteScript(): void {\n    const script = document.getElementById(this.id);\n    if (script) {\n      script.remove();\n    }\n  }\n\n  /**\n   * Load the Google Maps JavaScript API script and return a Promise.\n   */\n  public load(): Promise<typeof google> {\n    return this.loadPromise();\n  }\n\n  /**\n   * Load the Google Maps JavaScript API script and return a Promise.\n   *\n   * @ignore\n   */\n  public loadPromise(): Promise<typeof google> {\n    return new Promise((resolve, reject) => {\n      this.loadCallback((err: ErrorEvent) => {\n        if (!err) {\n          resolve(window.google);\n        } else {\n          reject(err.error);\n        }\n      });\n    });\n  }\n\n  /**\n   * Load the Google Maps JavaScript API script with a callback.\n   */\n  public loadCallback(fn: (e: ErrorEvent) => void): void {\n    this.callbacks.push(fn);\n    this.execute();\n  }\n\n  /**\n   * Set the script on document.\n   */\n  private setScript(): void {\n    if (document.getElementById(this.id)) {\n      // TODO wrap onerror callback for cases where the script was loaded elsewhere\n      this.callback();\n      return;\n    }\n\n    const url = this.createUrl();\n    const script = document.createElement(\"script\");\n    script.id = this.id;\n    script.type = \"text/javascript\";\n    script.src = url;\n    script.onerror = this.loadErrorCallback.bind(this);\n    script.defer = true;\n    script.async = true;\n\n    if (this.nonce) {\n      script.nonce = this.nonce;\n    }\n\n    document.head.appendChild(script);\n  }\n\n  /**\n   * Reset the loader state.\n   */\n  private reset(): void {\n    this.deleteScript();\n    this.done = false;\n    this.loading = false;\n    this.errors = [];\n    this.onerrorEvent = null;\n  }\n\n  private resetIfRetryingFailed(): void {\n    if (this.failed) {\n      this.reset();\n    }\n  }\n\n  private loadErrorCallback(e: ErrorEvent): void {\n    this.errors.push(e);\n\n    if (this.errors.length <= this.retries) {\n      const delay = this.errors.length * 2 ** this.errors.length;\n\n      console.log(\n        `Failed to load Google Maps script, retrying in ${delay} ms.`\n      );\n\n      setTimeout(() => {\n        this.deleteScript();\n        this.setScript();\n      }, delay);\n    } else {\n      this.onerrorEvent = e;\n      this.callback();\n    }\n  }\n\n  private setCallback(): void {\n    window.__googleMapsCallback = this.callback.bind(this);\n  }\n\n  private callback(): void {\n    this.done = true;\n    this.loading = false;\n\n    this.callbacks.forEach((cb) => {\n      cb(this.onerrorEvent);\n    });\n\n    this.callbacks = [];\n  }\n\n  private execute(): void {\n    this.resetIfRetryingFailed();\n\n    if (this.done) {\n      this.callback();\n    } else {\n      // short circuit and warn if google.maps is already loaded\n      if (window.google && window.google.maps && window.google.maps.version) {\n        console.warn(\n          \"Google Maps already loaded outside @googlemaps/js-api-loader.\" +\n            \"This may result in undesirable behavior as options and script parameters may not match.\"\n        );\n        this.callback();\n        return;\n      }\n\n      if (this.loading) {\n        // do nothing but wait\n      } else {\n        this.loading = true;\n        this.setCallback();\n        this.setScript();\n      }\n    }\n  }\n}\n"],"names":["isEqual"],"version":3,"file":"anycluster-google.js.map"}