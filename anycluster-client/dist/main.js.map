{"mappings":"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","sources":["src/consts.ts","src/anycluster.ts","src/anycluster-client.ts"],"sourcesContent":["\nexport interface MaxBounds {\n    minX: number,\n    maxX: number,\n    minY: number,\n    maxY: number\n}\n\nexport enum SRIDS {\n    EPSG4326 = 'EPSG:4326',\n    EPSG3857 = 'EPSG:3857'\n}\n\nexport enum ClusterMethod {\n    kmeans = 'kmeans',\n    grid = 'grid'\n}\n\n\nexport enum GeometryType {\n    viewport = 'viewport',\n    area = 'area'\n}\n\nexport enum IconType {\n    exact = 'exact',\n    rounded = 'rounded'\n}\n\nexport enum DefaultGridSizes {\n    grid = 64,\n    kmeans = 150\n}\n\nexport const DefaultMarkerImageSizes = {\n    1: [24, 39],\n    5: [30, 30],\n    10: [30, 30],\n    50: [40, 40],\n    100: [40, 40],\n    1000: [50, 50],\n    10000: [60, 60]\n}\n\nexport enum Operators {\n    in = 'in',\n    notIn = 'not in',\n    equals = '=',\n    unEquals = '!=',\n    largerThan = '>=',\n    smallerThan = '<=',\n    startswith = 'startswith',\n    contains = 'contains',\n}","import { SRIDS, MaxBounds, ClusterMethod, GeometryType, Operators } from \"./consts\";\nimport { Point, GeoJSON, Coordinates, Viewport } from \"./geometry\";\n\nexport const Bounds4326: MaxBounds = Object.freeze({\n    minX: -179,\n    maxX: 179,\n    minY: -89,\n    maxY: 89\n})\n\n\nexport const Bounds3857: MaxBounds = Object.freeze({\n    minX: -20037500, //-20037508.34\n    maxX: 20037500, // 20037508.34\n    minY: -20048960, // -20048966.1\n    maxY: 20048960 //  20048966.1\n})\n\nexport interface Filter {\n    column: string\n    value: string | number | boolean\n    operator: Operators\n}\n\nexport interface ClusterRequestData {\n    output_srid: SRIDS\n    geometry_type: GeometryType\n    geojson: GeoJSON\n    clear_cache: boolean\n    filters: Filter[]\n}\n\nexport type FilterList = Filter[]\n\nexport interface GetKmeansClusterContentRequestData {\n    geometry_type: GeometryType\n    input_srid: SRIDS\n    x: number\n    y: number\n    ids: number[]\n}\n\n\nexport class Anycluster {\n\n    maxBounds: MaxBounds\n\n    constructor(private apiUrl: string, public gridSize: number, public srid: SRIDS) {\n\n        if (this.srid == SRIDS.EPSG4326) {\n            this.maxBounds = Bounds4326;\n        }\n        else if (this.srid == SRIDS.EPSG3857) {\n            this.maxBounds = Bounds3857;\n        }\n        else {\n            throw new Error(`invalid srid given: ${this.srid} `);\n        }\n\n    }\n\n    async getGridCluster(zoom: number, data: ClusterRequestData) {\n        const url = `${this.apiUrl}grid/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters;\n    }\n\n    async getKmeansCluster(zoom: number, data: ClusterRequestData) {\n\n        const url = `${this.apiUrl}kmeans/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters\n    }\n\n    async getKmeansClusterContent(zoom: number, data: GetKmeansClusterContentRequestData) {\n\n        const url = `${this.apiUrl}get-kmeans-cluster-content/${zoom}/${this.gridSize}/`;\n\n        const clusterContent = await this.post(url, data);\n\n        return clusterContent;\n    }\n\n    async getDatasetContent(zoom: number, datasetId: number) {\n        const url = `${this.apiUrl}get-dataset-content/${zoom}/${this.gridSize}/${datasetId}/`;\n\n        const clusterContent = await this.get(url);\n\n        return clusterContent;\n    }\n\n    getAreaContent() {\n\n    }\n\n    viewportToGeoJSON(viewport: Viewport) {\n\n        const left = Math.max(viewport.left, this.maxBounds.minX);\n        const right = Math.min(viewport.right, this.maxBounds.maxX);\n        const top = Math.min(viewport.top, this.maxBounds.maxY);\n        const bottom = Math.max(viewport.bottom, this.maxBounds.minY);\n\n        const geometryType = \"Polygon\";\n\n        const coordinates = [[\n            [left, top],\n            [right, top],\n            [right, bottom],\n            [left, bottom],\n            [left, top]\n        ]];\n\n        const geoJSON = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": geometryType,\n                \"coordinates\": coordinates,\n                \"crs\": {\n                    \"type\": \"name\",\n                    \"properties\": {\n                        \"name\": this.srid\n                    }\n                }\n            }\n        };\n\n        return geoJSON;\n    }\n\n    async post(url: string, postData: object) {\n\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'POST',\n            body: JSON.stringify(postData),\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n\n    }\n\n    async get(url: string) {\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n    }\n}","\nimport { ClusterMethod, GeometryType, IconType, SRIDS, DefaultGridSizes, DefaultMarkerImageSizes } from \"./consts\";\nimport { GeoJSON, Marker, Cluster, Viewport } from \"./geometry\";\nimport { Anycluster, GetKmeansClusterContentRequestData, ClusterRequestData, Filter, FilterList } from \"./anycluster\";\n\n\nconst defaultGridFillColors = {\n    5: \"rgba(255, 192, 203, .5)\",\n    10: \"rgba(240, 128, 128, .5)\",\n    50: \"rgba(255, 127, 80, .5)\",\n    100: \"rgba(255, 165, 0, .5)\",\n    1000: \"rgba(255, 69, 0, .5)\",\n    10000: \"rgba(255, 0 , 0, .5)\"\n};\n\nconst defaultGridStrokeColors = {\n    5: \"pink\",\n    10: \"lightcoral\",\n    50: \"coral\",\n    100: \"orange\",\n    1000: \"orangered\",\n    10000: \"red\"\n};\n\nexport interface AnyclusterClientSettings {\n    srid?: SRIDS // srid of the map\n    kmeansGridSize?: number\n    gridGridSize?: number\n    clusterMethod?: ClusterMethod\n    geometryType?: GeometryType\n    area?: any\n    iconType?: IconType\n    onFinalClick?: Function\n    singlePinImages?: Record<string, string>\n    markerImageSizes?: Record<string, number[]>\n    gridFillColors?: Record<number, string>\n    gridStrokeColors?: Record<number, string>\n}\n\nexport class AnyclusterClient {\n\n    srid: SRIDS\n    kmeansGridSize: number\n    gridGridSize: number\n    clusterMethod: ClusterMethod\n    geometryType: GeometryType\n\n    area: GeoJSON | null\n    iconType: IconType\n\n    anycluster: Anycluster\n    markerList: any[]\n    onFinalClick: Function\n    singlePinImages?: Record<string, string>\n\n    markerImageSizes: Record<string, number[]>\n\n    gridFillColors: Record<number, string>\n    gridStrokeColors: Record<number, string>\n\n    filters: FilterList = []\n\n\n    constructor(public map: any, public apiUrl: string, public markerFolderPath: string, settings: AnyclusterClientSettings) {\n\n        this.map = map;\n        this.apiUrl = apiUrl;\n        this.markerFolderPath = markerFolderPath;\n\n        settings = settings || {};\n\n\n        // settings\n        this.srid = settings.srid ? settings.srid : SRIDS.EPSG4326;\n        this.kmeansGridSize = settings.gridGridSize ? settings.gridGridSize : DefaultGridSizes.kmeans;\n        this.gridGridSize = settings.gridGridSize ? settings.gridGridSize : DefaultGridSizes.grid;\n\n        this.clusterMethod = settings.clusterMethod ? settings.clusterMethod : ClusterMethod.kmeans;\n        this.geometryType = settings.geometryType ? settings.geometryType : GeometryType.viewport;\n\n        this.area = settings.area ? settings.area : null;\n        this.iconType = settings.iconType ? settings.iconType : IconType.rounded;\n\n        this.onFinalClick = settings.onFinalClick ? settings.onFinalClick : this._onFinalClick;\n\n        this.singlePinImages = settings.singlePinImages ? settings.singlePinImages : {};\n\n        this.markerImageSizes = settings.markerImageSizes ? settings.markerImageSizes : DefaultMarkerImageSizes;\n\n        this.gridFillColors = settings.gridFillColors ? settings.gridFillColors : defaultGridFillColors;\n        this.gridStrokeColors = settings.gridStrokeColors ? settings.gridStrokeColors : defaultGridStrokeColors;\n\n\n        if (this.area) {\n            this.setArea(this.area);\n        }\n\n        const gridSize = this.getGridSize();\n        this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n\n        this.createClusterLayers();\n        this.markerList = [];\n\n        this.startClustering();\n    }\n\n    createClusterLayers(): void {\n        throw new Error(\"NotImplementedError: createClusterLayers\");\n    }\n\n    addArea(geojson: object): void {\n        throw new Error(\"NotImplementedError: addArea\");\n    }\n\n    removeArea(): void {\n        throw new Error(\"NotImplementedError: removeArea\");\n    }\n\n    removeAllMarkers(): void {\n        throw new Error(\"NotImplementedError: removeAllMarkers\");\n    }\n\n    getZoom(): number {\n        throw new Error(\"NotImplementedError: getZoom\");\n    }\n\n    setMap(x: number, y: number, zoom: number): void {\n        throw new Error(\"NotImplementedError: setMap\");\n    }\n\n    getViewport(): Viewport {\n        throw new Error(\"NotImplementedError: setMap\");\n    }\n\n    addMapEventListeners(): void {\n        throw new Error(\"NotImplementedError: addMapEventListeners\");\n    }\n\n    drawMarker(cluster: Cluster): void {\n        throw new Error(\"NotImplementedError: drawMarker\");\n    }\n\n    drawCell(cluster: Cluster): void {\n        throw new Error(\"NotImplementedError: drawCell\");\n    }\n\n    getAreaContent(geojson: GeoJSON): void {\n        throw new Error(\"NotImplementedError: getAreaContent\");\n    }\n\n\n    getGridSize(): number {\n        if (this.clusterMethod == ClusterMethod.grid) {\n            return this.gridGridSize;\n        }\n\n        return this.kmeansGridSize;\n    }\n\n    setClusterMethod(clusterMethod: ClusterMethod) {\n\n        if (clusterMethod == ClusterMethod.grid) {\n            this.area = null;\n            this.geometryType = GeometryType.viewport;\n            this.removeArea();\n        }\n\n        this.removeAllMarkers();\n        this.clusterMethod = clusterMethod;\n        const gridSize = this.getGridSize();\n        this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n        this.markerList = [];\n        this.getClusters(true);\n    }\n\n    setArea(geojson: GeoJSON) {\n\n        this.area = geojson;\n\n        this.removeArea();\n\n        if (geojson == null) {\n            this.geometryType = GeometryType.viewport;\n            this.setClusterMethod(ClusterMethod.kmeans);\n        }\n        else {\n\n            this.addArea(geojson);\n\n            this.geometryType = GeometryType.area;\n\n            this.setClusterMethod(ClusterMethod.kmeans);\n        }\n    }\n\n    getSinglePinImageURL(cluster: Cluster) {\n\n        const pinimg = cluster.pinimg;\n\n        let url = `${this.markerFolderPath}pin_unknown.png`;\n\n        if (this.singlePinImages && pinimg && pinimg in this.singlePinImages) {\n            url = this.singlePinImages[pinimg];\n        }\n\n        return url\n\n    }\n\n    selectPinIcon(cluster: Cluster) {\n\n        const count = cluster.count;\n\n        let markerImageUrl = this.getSinglePinImageURL(cluster);\n        let pinicon = \"1\";\n\n        if (count > 10000) {\n            pinicon = \"10000\";\n        }\n\n        else if (count > 1000) {\n            pinicon = \"1000\";\n        }\n\n        else if (count > 100) {\n            pinicon = \"100\";\n        }\n\n        else if (count > 50) {\n            pinicon = \"50\";\n        }\n\n        else if (count > 10) {\n            pinicon = \"10\";\n        }\n\n        else if (count > 1) {\n            pinicon = \"5\";\n        }\n\n        if (count > 1) {\n            if (this.iconType == IconType.exact) {\n                markerImageUrl = `${this.markerFolderPath}${pinicon}_empty.png`;\n            }\n            else {\n                markerImageUrl = `${this.markerFolderPath}${pinicon}.png`;\n            }\n        }\n\n        const size = this.markerImageSizes[pinicon];\n        let anchor = [Math.round(size[0] / 2), size[1] - 1];\n        let relativeAnchor = [0.5, 1];\n\n        if (count > 1) {\n            anchor = [Math.round((size[0] / 2)), Math.round(size[1] / 2)];\n            relativeAnchor = [0.5, 0.5];\n        }\n\n        const imgObj = {\n            url: markerImageUrl,\n            size: size,\n            anchor: anchor,\n            relativeAnchor: relativeAnchor,\n            popupAnchor: [0, -Math.round(size[1]) + 8]\n        }\n\n        return imgObj;\n\n    }\n\n    // marker can be an openlayers Feature or a L.marker\n    setMarkerProps(marker: any, cluster: Cluster) {\n\n        // add properties required by anycluster\n        marker.x = cluster.center.x;\n        marker.y = cluster.center.y;\n        marker.count = cluster.count;\n\n        if (cluster.hasOwnProperty(\"ids\")) {\n            marker.ids = cluster.ids;\n        }\n\n        if (cluster.hasOwnProperty(\"id\")) {\n            marker.id = cluster.id;\n        }\n\n        if (cluster.hasOwnProperty(\"geojson\")) {\n\n            /*const geojson = {\n                \"type\": \"Feature\",\n                \"count\": cluster.count,\n                \"geometry\": cluster.geojson,\n                \"properties\": {\n                    \"count\": cluster.count\n                },\n                \"crs\" : {\n                    \"type\" : \"name\",\n                    \"properties\" : {\n                        \"name\" : this.srid\n                    }\n                }\n            };*/\n\n            marker.geojson = cluster.geojson;\n        }\n\n        return marker;\n\n    }\n\n    markerClickFunction(x: number, y: number) {\n        this.removeAllMarkers();\n        let zoom = this.getZoom();\n        zoom = zoom + 3;\n        this.setMap(x, y, zoom);\n    }\n\n    async onMarkerFinalClick(marker: any) {\n\n        const zoom = this.getZoom();\n        const x = marker.x;\n        const y = marker.y;\n        const ids = marker.ids;\n\n        if (this.clusterMethod == ClusterMethod.kmeans) {\n\n            const postData = {\n                \"geometry_type\": this.geometryType,\n                \"input_srid\": this.srid,\n                \"x\": x,\n                \"y\": y,\n                \"ids\": ids,\n                \"filters\": this.filters\n            } as GetKmeansClusterContentRequestData;\n\n            const data = await this.anycluster.getKmeansClusterContent(zoom, postData);\n\n            this.onFinalClick(marker, data);\n\n        }\n        else if (this.clusterMethod = ClusterMethod.grid) {\n\n            if (marker.count == 1) {\n                const data = await this.anycluster.getDatasetContent(zoom, marker.id);\n                this.onFinalClick(marker, data);\n            }\n            else {\n                const geojson = marker[\"geojson\"];\n                const data = await this.getAreaContent(geojson);\n\n                this.onFinalClick(marker, data);\n            }\n\n        }\n    }\n\n    roundMarkerCount(count: number): number {\n\n        if (count == 1) {\n            count = 1;\n        }\n        else if (count <= 5) {\n            count = 5;\n        }\n        else if (count <= 10) {\n            count = 10;\n        }\n        else if (count <= 50) {\n            count = 50;\n        }\n        else if (count <= 100) {\n            count = 100;\n        }\n        else if (count <= 1000) {\n            count = 1000;\n        }\n        else {\n            count = 10000;\n        }\n\n        return count;\n    }\n\n    getClusterGeometry() {\n        let geoJSON;\n\n        if (this.geometryType == GeometryType.viewport) {\n            const viewport = this.getViewport();\n            geoJSON = this.anycluster.viewportToGeoJSON(viewport);\n        }\n        else if (this.geometryType == GeometryType.area && this.area) {\n            geoJSON = this.area;\n        }\n        else {\n            throw new Error('No cluster geometry found');\n        }\n\n        return geoJSON;\n\n    }\n\n    async getClusters(clearCache = false) {\n\n        const geoJSON = this.getClusterGeometry()\n\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": clearCache,\n            \"filters\": this.filters\n        } as ClusterRequestData;\n\n        const zoom = this.getZoom();\n\n        if (this.clusterMethod == ClusterMethod.kmeans) {\n\n\n            const clusters: Cluster[] = await this.anycluster.getKmeansCluster(zoom, postData);\n\n            if (clusters.length > 0) {\n                clusters.forEach(cluster => {\n                    this.drawMarker(cluster);\n                });\n            }\n        }\n        else if (this.clusterMethod == ClusterMethod.grid) {\n            const clusters: Cluster[] = await this.anycluster.getGridCluster(zoom, postData);\n\n            if (clusters.length > 0) {\n                clusters.forEach(cluster => {\n                    this.drawCell(cluster);\n                });\n            }\n        }\n        else {\n            throw new Error(`Invalid clusterMethod: ${this.clusterMethod}`);\n        }\n    }\n\n    startClustering() {\n        this.getClusters(true);\n        this.addMapEventListeners();\n    }\n\n    _onFinalClick(marker: Marker, data: any) {\n        alert(JSON.stringify(data));\n    }\n\n    filtersAreEqual(filter1: Filter, filter2: Filter): boolean {\n        if (filter1.column == filter2.column && filter1.value == filter2.value && filter1.operator == filter2.operator) {\n            return true;\n        }\n\n        return false;\n    }\n\n    // filtering\n    filter(filter: Filter, reloadMarkers?: boolean) {\n        this.filters = [filter];\n        this.postFilterChange(reloadMarkers);\n    }\n\n    addFilter(filter: Filter, reloadMarkers?: boolean) {\n\n        let filterExists = false;\n\n        for (let f = 0; f < this.filters.length; f++) {\n            let existingFilter = this.filters[f];\n\n            if (this.filtersAreEqual(filter, existingFilter)) {\n                filterExists = true;\n                break;\n            }\n\n        }\n\n        if (!filterExists) {\n            this.filters.push(filter);\n        }\n\n        this.postFilterChange(reloadMarkers);\n    }\n\n    addFilters(filtersToAdd: FilterList, reloadMarkers?: boolean) {\n\n        for (let fa = 0; fa < filtersToAdd.length; fa++) {\n            let filter = filtersToAdd[fa];\n            this.addFilter(filter, false);\n        }\n        this.postFilterChange(reloadMarkers);\n    }\n\n    removeFilter(filter: Filter, reloadMarkers?: boolean) {\n\n        for (let f = 0; f < this.filters.length; f++) {\n            let existingFilter = this.filters[f];\n\n            if (this.filtersAreEqual(filter, existingFilter)) {\n                this.filters.splice(f, 1);\n                break;\n            }\n        }\n        this.postFilterChange(reloadMarkers);\n    }\n\n    removeFilters(filtersToRemove: FilterList, reloadMarkers?: boolean) {\n\n        for (let fr = 0; fr < filtersToRemove.length; fr++) {\n\n            let filter = filtersToRemove[fr];\n\n            this.removeFilter(filter, false);\n        }\n\n        this.postFilterChange(reloadMarkers);\n    }\n\n    resetFilters(reloadMarkers?: boolean) {\n        this.filters = [];\n        this.postFilterChange(reloadMarkers);\n    }\n\n    postFilterChange(reloadMarkers?: boolean) {\n        if (reloadMarkers != false){\n            reloadMarkers = true;\n        }\n        if (reloadMarkers == true) {\n            this.removeAllMarkers();\n            this.getClusters(true);\n        }\n    }\n\n}"],"names":["$d23ecb6e11364e2e$export$55fee9ea2526ad0d","SRIDS","$d23ecb6e11364e2e$export$ae91e066970d978a","ClusterMethod","$d23ecb6e11364e2e$export$8f4397a63c3cef66","GeometryType","$d23ecb6e11364e2e$export$13ff1290a9e22e77","IconType","$d23ecb6e11364e2e$export$9c3a9f8fbf06a34","DefaultGridSizes","$d23ecb6e11364e2e$export$96b1907ff7fa3578","$d23ecb6e11364e2e$export$7fa100a28fbb5fe2","Operators","$a84c901b6d8dcdc7$export$2104d4dd9d4984b2","Object","freeze","minX","maxX","minY","maxY","$a84c901b6d8dcdc7$export$6db2f048e15a981e","$a84c901b6d8dcdc7$export$5e01b9ff483562af","constructor","apiUrl","gridSize","srid","this","EPSG4326","maxBounds","EPSG3857","Error","async","zoom","data","url","post","datasetId","get","getAreaContent","viewportToGeoJSON","viewport","left","Math","max","right","min","top","bottom","type","geometry","coordinates","crs","properties","name","postData","encodedUrl","encodeURI","options","method","body","JSON","stringify","headers","mode","credentials","response","fetch","responseData","json","ok","$873ecc376aa9f94e$var$defaultGridFillColors","$873ecc376aa9f94e$var$defaultGridStrokeColors","$873ecc376aa9f94e$export$a09c19a7c4419c1","map","markerFolderPath","settings","filters","kmeansGridSize","gridGridSize","kmeans","grid","clusterMethod","geometryType","area","iconType","rounded","onFinalClick","_onFinalClick","singlePinImages","markerImageSizes","gridFillColors","gridStrokeColors","setArea","getGridSize","anycluster","createClusterLayers","markerList","startClustering","addArea","geojson","removeArea","removeAllMarkers","getZoom","setMap","x","y","getViewport","addMapEventListeners","drawMarker","cluster","drawCell","setClusterMethod","getClusters","getSinglePinImageURL","pinimg","selectPinIcon","count","markerImageUrl","pinicon","exact","size","anchor","round","relativeAnchor","popupAnchor","setMarkerProps","marker","center","hasOwnProperty","ids","id","markerClickFunction","geometry_type","input_srid","getKmeansClusterContent","getDatasetContent","roundMarkerCount","getClusterGeometry","geoJSON","clearCache","output_srid","clear_cache","clusters","getKmeansCluster","length","forEach","getGridCluster","alert","filtersAreEqual","filter1","filter2","column","value","operator","filter","reloadMarkers","postFilterChange","addFilter","filterExists","f","existingFilter","push","addFilters","filtersToAdd","fa","removeFilter","splice","removeFilters","filtersToRemove","fr","resetFilters"],"version":3,"file":"main.js.map"}