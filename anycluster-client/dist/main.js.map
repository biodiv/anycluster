{"mappings":"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","sources":["<anon>","src/index.ts","src/consts.ts","src/anycluster.ts","src/anycluster-client.ts"],"sourcesContent":["function $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n$parcel$export(module.exports, \"ClusterMethod\", () => $d23ecb6e11364e2e$export$ae91e066970d978a);\n$parcel$export(module.exports, \"GeometryType\", () => $d23ecb6e11364e2e$export$8f4397a63c3cef66);\n$parcel$export(module.exports, \"IconType\", () => $d23ecb6e11364e2e$export$13ff1290a9e22e77);\n$parcel$export(module.exports, \"SRIDS\", () => $d23ecb6e11364e2e$export$55fee9ea2526ad0d);\n$parcel$export(module.exports, \"Operators\", () => $d23ecb6e11364e2e$export$7fa100a28fbb5fe2);\n$parcel$export(module.exports, \"LogicalOperators\", () => $d23ecb6e11364e2e$export$9a28c02ac0f6fc9d);\n$parcel$export(module.exports, \"Anycluster\", () => $a84c901b6d8dcdc7$export$5e01b9ff483562af);\n$parcel$export(module.exports, \"Bounds3857\", () => $a84c901b6d8dcdc7$export$6db2f048e15a981e);\n$parcel$export(module.exports, \"Bounds4326\", () => $a84c901b6d8dcdc7$export$2104d4dd9d4984b2);\n$parcel$export(module.exports, \"AnyclusterClient\", () => $873ecc376aa9f94e$export$a09c19a7c4419c1);\nvar $d23ecb6e11364e2e$export$55fee9ea2526ad0d;\n(function(SRIDS) {\n    SRIDS[\"EPSG4326\"] = \"EPSG:4326\";\n    SRIDS[\"EPSG3857\"] = \"EPSG:3857\";\n})($d23ecb6e11364e2e$export$55fee9ea2526ad0d || ($d23ecb6e11364e2e$export$55fee9ea2526ad0d = {}));\nvar $d23ecb6e11364e2e$export$ae91e066970d978a;\n(function(ClusterMethod) {\n    ClusterMethod[\"kmeans\"] = \"kmeans\";\n    ClusterMethod[\"grid\"] = \"grid\";\n})($d23ecb6e11364e2e$export$ae91e066970d978a || ($d23ecb6e11364e2e$export$ae91e066970d978a = {}));\nvar $d23ecb6e11364e2e$export$8f4397a63c3cef66;\n(function(GeometryType) {\n    GeometryType[\"viewport\"] = \"viewport\";\n    GeometryType[\"area\"] = \"area\";\n})($d23ecb6e11364e2e$export$8f4397a63c3cef66 || ($d23ecb6e11364e2e$export$8f4397a63c3cef66 = {}));\nvar $d23ecb6e11364e2e$export$13ff1290a9e22e77;\n(function(IconType) {\n    IconType[\"exact\"] = \"exact\";\n    IconType[\"rounded\"] = \"rounded\";\n})($d23ecb6e11364e2e$export$13ff1290a9e22e77 || ($d23ecb6e11364e2e$export$13ff1290a9e22e77 = {}));\nvar $d23ecb6e11364e2e$export$9c3a9f8fbf06a34;\n(function(DefaultGridSizes) {\n    DefaultGridSizes[DefaultGridSizes[\"grid\"] = 64] = \"grid\";\n    DefaultGridSizes[DefaultGridSizes[\"kmeans\"] = 150] = \"kmeans\";\n})($d23ecb6e11364e2e$export$9c3a9f8fbf06a34 || ($d23ecb6e11364e2e$export$9c3a9f8fbf06a34 = {}));\nconst $d23ecb6e11364e2e$export$96b1907ff7fa3578 = {\n    1: [\n        24,\n        39\n    ],\n    5: [\n        30,\n        30\n    ],\n    10: [\n        30,\n        30\n    ],\n    50: [\n        40,\n        40\n    ],\n    100: [\n        40,\n        40\n    ],\n    1000: [\n        50,\n        50\n    ],\n    10000: [\n        60,\n        60\n    ]\n};\nvar $d23ecb6e11364e2e$export$7fa100a28fbb5fe2;\n(function(Operators) {\n    Operators[\"in\"] = \"in\";\n    Operators[\"notIn\"] = \"not in\";\n    Operators[\"equals\"] = \"=\";\n    Operators[\"unEquals\"] = \"!=\";\n    Operators[\"largerThan\"] = \">=\";\n    Operators[\"smallerThan\"] = \"<=\";\n    Operators[\"startswith\"] = \"startswith\";\n    Operators[\"contains\"] = \"contains\";\n})($d23ecb6e11364e2e$export$7fa100a28fbb5fe2 || ($d23ecb6e11364e2e$export$7fa100a28fbb5fe2 = {}));\nvar $d23ecb6e11364e2e$export$9a28c02ac0f6fc9d;\n(function(LogicalOperators) {\n    LogicalOperators[\"AND\"] = \"AND\";\n    LogicalOperators[\"OR\"] = \"OR\";\n})($d23ecb6e11364e2e$export$9a28c02ac0f6fc9d || ($d23ecb6e11364e2e$export$9a28c02ac0f6fc9d = {}));\nconst $d23ecb6e11364e2e$export$aa170efeb32c8cf9 = 13;\n\n\n\nconst $a84c901b6d8dcdc7$export$2104d4dd9d4984b2 = Object.freeze({\n    minX: -179,\n    maxX: 179,\n    minY: -89,\n    maxY: 89\n});\nconst $a84c901b6d8dcdc7$export$6db2f048e15a981e = Object.freeze({\n    minX: -20037500,\n    maxX: 20037500,\n    minY: -20048960,\n    maxY: 20048960 //  20048966.1\n});\nclass $a84c901b6d8dcdc7$export$5e01b9ff483562af {\n    constructor(apiUrl, gridSize, srid){\n        this.apiUrl = apiUrl;\n        this.gridSize = gridSize;\n        this.srid = srid;\n        if (this.srid == (0, $d23ecb6e11364e2e$export$55fee9ea2526ad0d).EPSG4326) this.maxBounds = $a84c901b6d8dcdc7$export$2104d4dd9d4984b2;\n        else if (this.srid == (0, $d23ecb6e11364e2e$export$55fee9ea2526ad0d).EPSG3857) this.maxBounds = $a84c901b6d8dcdc7$export$6db2f048e15a981e;\n        else throw new Error(`invalid srid given: ${this.srid} `);\n    }\n    validateZoom(zoom) {\n        if (!Number.isInteger(zoom)) throw new Error(`[anycluster] non-integer zoom: ${zoom}`);\n    }\n    async getGridCluster(zoom, data) {\n        this.validateZoom(zoom);\n        const url = `${this.apiUrl}grid/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters;\n    }\n    async getKmeansCluster(zoom, data) {\n        this.validateZoom(zoom);\n        const url = `${this.apiUrl}kmeans/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters;\n    }\n    async getKmeansClusterContent(zoom, data) {\n        this.validateZoom(zoom);\n        const url = `${this.apiUrl}get-kmeans-cluster-content/${zoom}/${this.gridSize}/`;\n        const clusterContent = await this.post(url, data);\n        return clusterContent;\n    }\n    async getDatasetContent(zoom, datasetId) {\n        this.validateZoom(zoom);\n        const url = `${this.apiUrl}get-dataset-content/${zoom}/${this.gridSize}/${datasetId}/`;\n        const clusterContent = await this.get(url);\n        return clusterContent;\n    }\n    async getMapContentCount(zoom, data) {\n        this.validateZoom(zoom);\n        const url = `${this.apiUrl}get-map-content-count/${zoom}/${this.gridSize}/`;\n        const mapContentCount = await this.post(url, data);\n        return mapContentCount;\n    }\n    async getGroupedMapContents(zoom, data) {\n        this.validateZoom(zoom);\n        const url = `${this.apiUrl}get-grouped-map-contents/${zoom}/${this.gridSize}/`;\n        const groupedMapContents = await this.post(url, data);\n        return groupedMapContents;\n    }\n    async getAreaContent(zoom, data) {\n        this.validateZoom(zoom);\n        const url = `${this.apiUrl}get-area-content/${zoom}/${this.gridSize}/`;\n        const areaContent = await this.post(url, data);\n        return areaContent;\n    }\n    viewportToGeoJSON(viewport) {\n        const left = Math.max(viewport.left, this.maxBounds.minX);\n        const right = Math.min(viewport.right, this.maxBounds.maxX);\n        const top = Math.min(viewport.top, this.maxBounds.maxY);\n        const bottom = Math.max(viewport.bottom, this.maxBounds.minY);\n        const geometryType = \"Polygon\";\n        const coordinates = [\n            [\n                [\n                    left,\n                    top\n                ],\n                [\n                    right,\n                    top\n                ],\n                [\n                    right,\n                    bottom\n                ],\n                [\n                    left,\n                    bottom\n                ],\n                [\n                    left,\n                    top\n                ]\n            ]\n        ];\n        const geoJSON = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": geometryType,\n                \"coordinates\": coordinates,\n                \"crs\": {\n                    \"type\": \"name\",\n                    \"properties\": {\n                        \"name\": this.srid\n                    }\n                }\n            }\n        };\n        return geoJSON;\n    }\n    async post(url, postData) {\n        const encodedUrl = encodeURI(url);\n        const options = {\n            method: \"POST\",\n            body: JSON.stringify(postData),\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            mode: \"cors\",\n            credentials: \"include\"\n        };\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n        if (response.ok) return responseData;\n        else throw new Error(JSON.stringify(responseData));\n    }\n    async get(url) {\n        const encodedUrl = encodeURI(url);\n        const options = {\n            method: \"GET\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            mode: \"cors\",\n            credentials: \"include\"\n        };\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n        if (response.ok) return responseData;\n        else throw new Error(JSON.stringify(responseData));\n    }\n}\n\n\n\n\nconst $873ecc376aa9f94e$var$defaultGridFillColors = {\n    5: \"rgba(255, 192, 203, .5)\",\n    10: \"rgba(240, 128, 128, .5)\",\n    50: \"rgba(255, 127, 80, .5)\",\n    100: \"rgba(255, 165, 0, .5)\",\n    1000: \"rgba(255, 69, 0, .5)\",\n    10000: \"rgba(255, 0 , 0, .5)\"\n};\nconst $873ecc376aa9f94e$var$defaultGridStrokeColors = {\n    5: \"pink\",\n    10: \"lightcoral\",\n    50: \"coral\",\n    100: \"orange\",\n    1000: \"orangered\",\n    10000: \"red\"\n};\nclass $873ecc376aa9f94e$export$a09c19a7c4419c1 {\n    constructor(map, apiUrl, markerFolderPath, settings){\n        this.map = map;\n        this.apiUrl = apiUrl;\n        this.markerFolderPath = markerFolderPath;\n        this.filters = [];\n        this.isStartup = false // openlayers fires moveend after loadend. This triggers two clustering requests of which the latter has to be dismissed\n        ;\n        this.latestFilterChangeTimestamp = null;\n        this.map = map;\n        this.apiUrl = apiUrl;\n        this.markerFolderPath = markerFolderPath;\n        settings = settings || {};\n        // settings\n        this.srid = settings.srid ? settings.srid : (0, $d23ecb6e11364e2e$export$55fee9ea2526ad0d).EPSG4326;\n        this.kmeansGridSize = settings.gridGridSize ? settings.gridGridSize : (0, $d23ecb6e11364e2e$export$9c3a9f8fbf06a34).kmeans;\n        this.gridGridSize = settings.gridGridSize ? settings.gridGridSize : (0, $d23ecb6e11364e2e$export$9c3a9f8fbf06a34).grid;\n        this.clusterMethod = settings.clusterMethod ? settings.clusterMethod : (0, $d23ecb6e11364e2e$export$ae91e066970d978a).kmeans;\n        this.geometryType = settings.geometryType ? settings.geometryType : (0, $d23ecb6e11364e2e$export$8f4397a63c3cef66).viewport;\n        this.area = settings.area ? settings.area : null;\n        this.iconType = settings.iconType ? settings.iconType : (0, $d23ecb6e11364e2e$export$13ff1290a9e22e77).rounded;\n        this.singlePinImages = settings.singlePinImages ? settings.singlePinImages : {};\n        this.getSinglePinImageURL = settings.getSinglePinImageURL ? settings.getSinglePinImageURL : this._getSinglePinImageURL;\n        this.markerImageSizes = settings.markerImageSizes ? settings.markerImageSizes : (0, $d23ecb6e11364e2e$export$96b1907ff7fa3578);\n        this.gridFillColors = settings.gridFillColors ? settings.gridFillColors : $873ecc376aa9f94e$var$defaultGridFillColors;\n        this.gridStrokeColors = settings.gridStrokeColors ? settings.gridStrokeColors : $873ecc376aa9f94e$var$defaultGridStrokeColors;\n        this.maxZoom = settings.maxZoom ? settings.maxZoom : (0, $d23ecb6e11364e2e$export$aa170efeb32c8cf9);\n        // hooks\n        this.onGotClusters = settings.onGotClusters ? settings.onGotClusters : this._onGotClusters;\n        this.onFinalClick = settings.onFinalClick ? settings.onFinalClick : this._onFinalClick;\n        if (this.area) this.setArea(this.area);\n        const gridSize = this.getGridSize();\n        this.anycluster = new (0, $a84c901b6d8dcdc7$export$5e01b9ff483562af)(this.apiUrl, gridSize, this.srid);\n        this.createClusterLayers();\n        this.markerList = [];\n        const startClustering = settings.startClustering === false ? settings.startClustering : true;\n        if (startClustering === true) this.startClustering();\n    }\n    createClusterLayers() {\n        throw new Error(\"NotImplementedError: createClusterLayers\");\n    }\n    addArea(geojson) {\n        throw new Error(\"NotImplementedError: addArea\");\n    }\n    removeArea() {\n        throw new Error(\"NotImplementedError: removeArea\");\n    }\n    removeAllMarkers() {\n        throw new Error(\"NotImplementedError: removeAllMarkers\");\n    }\n    getZoom() {\n        throw new Error(\"NotImplementedError: getZoom\");\n    }\n    setMap(x, y, zoom) {\n        throw new Error(\"NotImplementedError: setMap\");\n    }\n    getViewport() {\n        throw new Error(\"NotImplementedError: setMap\");\n    }\n    addMapEventListeners() {\n        throw new Error(\"NotImplementedError: addMapEventListeners\");\n    }\n    drawKmeansMarker(cluster) {\n        throw new Error(\"NotImplementedError: drawKmeansMarker\");\n    }\n    drawCell(cluster) {\n        throw new Error(\"NotImplementedError: drawCell\");\n    }\n    drawGridMarker(cluster) {\n        throw new Error(\"NotImplementedError: drawGridMarker\");\n    }\n    getGridSize() {\n        if (this.clusterMethod == (0, $d23ecb6e11364e2e$export$ae91e066970d978a).grid) return this.gridGridSize;\n        return this.kmeansGridSize;\n    }\n    setClusterMethod(clusterMethod) {\n        if (clusterMethod == (0, $d23ecb6e11364e2e$export$ae91e066970d978a).grid) {\n            this.area = null;\n            this.geometryType = (0, $d23ecb6e11364e2e$export$8f4397a63c3cef66).viewport;\n            this.removeArea();\n        }\n        this.removeAllMarkers();\n        this.clusterMethod = clusterMethod;\n        const gridSize = this.getGridSize();\n        this.anycluster = new (0, $a84c901b6d8dcdc7$export$5e01b9ff483562af)(this.apiUrl, gridSize, this.srid);\n        this.markerList = [];\n        this.getClusters(true);\n    }\n    setArea(geojson) {\n        this.area = geojson;\n        this.removeArea();\n        if (geojson == null) {\n            this.geometryType = (0, $d23ecb6e11364e2e$export$8f4397a63c3cef66).viewport;\n            this.setClusterMethod((0, $d23ecb6e11364e2e$export$ae91e066970d978a).kmeans);\n        } else {\n            this.addArea(geojson);\n            this.geometryType = (0, $d23ecb6e11364e2e$export$8f4397a63c3cef66).area;\n            this.setClusterMethod((0, $d23ecb6e11364e2e$export$ae91e066970d978a).kmeans);\n        }\n    }\n    _getSinglePinImageURL(cluster) {\n        const pinimg = cluster.pinimg;\n        let url = `${this.markerFolderPath}pin_unknown.png`;\n        if (this.singlePinImages && pinimg && pinimg in this.singlePinImages) url = this.singlePinImages[pinimg];\n        return url;\n    }\n    selectPinIcon(cluster) {\n        const count = cluster.count;\n        let markerImageUrl = this.getSinglePinImageURL(cluster);\n        let pinicon = \"1\";\n        if (count > 10000) pinicon = \"10000\";\n        else if (count > 1000) pinicon = \"1000\";\n        else if (count > 100) pinicon = \"100\";\n        else if (count > 50) pinicon = \"50\";\n        else if (count > 10) pinicon = \"10\";\n        else if (count > 1) pinicon = \"5\";\n        if (count > 1) {\n            if (this.iconType == (0, $d23ecb6e11364e2e$export$13ff1290a9e22e77).exact) markerImageUrl = `${this.markerFolderPath}${pinicon}_empty.png`;\n            else markerImageUrl = `${this.markerFolderPath}${pinicon}.png`;\n        }\n        const size = this.markerImageSizes[pinicon];\n        let anchor = [\n            Math.round(size[0] / 2),\n            size[1] - 1\n        ];\n        let relativeAnchor = [\n            0.5,\n            1\n        ];\n        if (count > 1) {\n            anchor = [\n                Math.round(size[0] / 2),\n                Math.round(size[1] / 2)\n            ];\n            relativeAnchor = [\n                0.5,\n                0.5\n            ];\n        }\n        const imgObj = {\n            url: markerImageUrl,\n            size: size,\n            anchor: anchor,\n            relativeAnchor: relativeAnchor,\n            popupAnchor: [\n                0,\n                -Math.round(size[1]) + 8\n            ]\n        };\n        return imgObj;\n    }\n    // marker can be an openlayers Feature or a L.marker\n    setMarkerProps(marker, cluster) {\n        // add properties required by anycluster\n        marker.x = cluster.center.x;\n        marker.y = cluster.center.y;\n        marker.count = cluster.count;\n        marker.ids = cluster.ids;\n        return marker;\n    }\n    setCellProps(cell, cluster) {\n        cell.x = cluster.center.x;\n        cell.y = cluster.center.y;\n        cell.count = cluster.count;\n        cell.id = cluster.id;\n        cell.geojson = cluster.geojson;\n        return cell;\n    }\n    markerClickFunction(x, y) {\n        this.removeAllMarkers();\n        let zoom = this.getZoom();\n        zoom = zoom + 3;\n        this.setMap(x, y, zoom);\n    }\n    async onMarkerFinalClick(marker) {\n        const zoom = this.getZoom();\n        const x = marker.x;\n        const y = marker.y;\n        const geoJSON = this.getClusterGeometry();\n        if (this.clusterMethod == (0, $d23ecb6e11364e2e$export$ae91e066970d978a).kmeans) {\n            const ids = marker.ids;\n            const postData = {\n                \"geometry_type\": this.geometryType,\n                \"geojson\": geoJSON,\n                \"input_srid\": this.srid,\n                \"x\": x,\n                \"y\": y,\n                \"ids\": ids,\n                \"filters\": this.filters\n            };\n            const data = await this.anycluster.getKmeansClusterContent(zoom, postData);\n            this.onFinalClick(marker, data);\n        } else if (this.clusterMethod = (0, $d23ecb6e11364e2e$export$ae91e066970d978a).grid) {\n            if (marker.count == 1) {\n                const data = await this.anycluster.getDatasetContent(zoom, marker.id);\n                this.onFinalClick(marker, data);\n            } else {\n                const geojson = marker[\"geojson\"];\n                const zoom = this.getZoom();\n                const data = await this.anycluster.getAreaContent(zoom, geojson);\n                this.onFinalClick(marker, data);\n            }\n        }\n    }\n    roundMarkerCount(count) {\n        if (count == 1) count = 1;\n        else if (count <= 5) count = 5;\n        else if (count <= 10) count = 10;\n        else if (count <= 50) count = 50;\n        else if (count <= 100) count = 100;\n        else if (count <= 1000) count = 1000;\n        else count = 10000;\n        return count;\n    }\n    getClusterGeometry() {\n        let geoJSON;\n        if (this.geometryType == (0, $d23ecb6e11364e2e$export$8f4397a63c3cef66).viewport) {\n            const viewport = this.getViewport();\n            geoJSON = this.anycluster.viewportToGeoJSON(viewport);\n        } else if (this.geometryType == (0, $d23ecb6e11364e2e$export$8f4397a63c3cef66).area && this.area) geoJSON = this.area;\n        else throw new Error(\"No cluster geometry found\");\n        return geoJSON;\n    }\n    async getClusters(clearCache = false) {\n        const geoJSON = this.getClusterGeometry();\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": clearCache,\n            \"filters\": this.filters\n        };\n        const zoom = this.getZoom();\n        const filterTimestamp = this.latestFilterChangeTimestamp;\n        if (this.clusterMethod == (0, $d23ecb6e11364e2e$export$ae91e066970d978a).kmeans) {\n            const clusters = await this.anycluster.getKmeansCluster(zoom, postData);\n            const postResponseZoom = this.getZoom();\n            // only draw markers/cells if the user did not zoom or change filters during the wait for the response\n            if (clusters.length > 0 && filterTimestamp === this.latestFilterChangeTimestamp && zoom === postResponseZoom) {\n                clusters.forEach((cluster)=>{\n                    this.drawKmeansMarker(cluster);\n                });\n                this.onGotClusters();\n            } else console.log(`[anycluster]: not drawing markers because of outdated response`);\n        } else if (this.clusterMethod == (0, $d23ecb6e11364e2e$export$ae91e066970d978a).grid) {\n            const clusters = await this.anycluster.getGridCluster(zoom, postData);\n            const postResponseZoom = this.getZoom();\n            // only draw markers/cells if the user did not zoom or change filters during the wait for the response\n            if (clusters.length > 0 && filterTimestamp === this.latestFilterChangeTimestamp && zoom === postResponseZoom) {\n                clusters.forEach((cluster)=>{\n                    this.drawCell(cluster);\n                });\n                this.onGotClusters();\n            } else console.log(`[anycluster]: not drawing markers because of outdated response`);\n        } else throw new Error(`Invalid clusterMethod: ${this.clusterMethod}`);\n    }\n    async startClustering() {\n        this.isStartup = true;\n        await this.getClusters(true);\n        this.addMapEventListeners();\n        this.isStartup = false;\n    }\n    filtersAreEqual(filter1, filter2) {\n        if (\"column\" in filter1 && \"column\" in filter2) {\n            if (filter1.column == filter2.column && filter1.value == filter2.value && filter1.operator == filter2.operator) return true;\n        } else if (JSON.stringify(filter1) === JSON.stringify(filter2)) return true;\n        return false;\n    }\n    // filtering\n    filter(filter, reloadMarkers) {\n        if (Array.isArray(filter)) this.filters = filter;\n        else this.filters = [\n            filter\n        ];\n        this.postFilterChange(reloadMarkers);\n    }\n    addFilter(filter, reloadMarkers) {\n        let filterExists = false;\n        for(let f = 0; f < this.filters.length; f++){\n            let existingFilter = this.filters[f];\n            if (this.filtersAreEqual(filter, existingFilter)) {\n                filterExists = true;\n                break;\n            }\n        }\n        if (!filterExists) this.filters.push(filter);\n        this.postFilterChange(reloadMarkers);\n    }\n    addFilters(filtersToAdd, reloadMarkers) {\n        for(let fa = 0; fa < filtersToAdd.length; fa++){\n            let filter = filtersToAdd[fa];\n            this.addFilter(filter, false);\n        }\n        this.postFilterChange(reloadMarkers);\n    }\n    removeFilter(filter, reloadMarkers) {\n        for(let f = 0; f < this.filters.length; f++){\n            let existingFilter = this.filters[f];\n            if (this.filtersAreEqual(filter, existingFilter)) {\n                this.filters.splice(f, 1);\n                break;\n            }\n        }\n        this.postFilterChange(reloadMarkers);\n    }\n    removeFilters(filtersToRemove, reloadMarkers) {\n        for(let fr = 0; fr < filtersToRemove.length; fr++){\n            let filter = filtersToRemove[fr];\n            this.removeFilter(filter, false);\n        }\n        this.postFilterChange(reloadMarkers);\n    }\n    resetFilters(reloadMarkers) {\n        this.filters = [];\n        this.postFilterChange(reloadMarkers);\n    }\n    postFilterChange(reloadMarkers) {\n        this.latestFilterChangeTimestamp = new Date().getTime();\n        if (reloadMarkers != false) reloadMarkers = true;\n        if (reloadMarkers == true) {\n            this.removeAllMarkers();\n            this.getClusters(true);\n        }\n    }\n    /**\n   * method for getting the unaggregated, paginated content of the map\n   */ async getMapContents(limit, offset, orderBy) {\n        const geoJSON = this.getClusterGeometry();\n        const zoom = this.getZoom();\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": (0, $d23ecb6e11364e2e$export$8f4397a63c3cef66).area,\n            \"geojson\": geoJSON,\n            \"clear_cache\": false,\n            \"filters\": this.filters,\n            \"limit\": limit,\n            \"offset\": offset,\n            \"order_by\": orderBy\n        };\n        const data = this.anycluster.getAreaContent(zoom, postData);\n        return data;\n    }\n    /**\n   * methods for getting counts of objects on the current map / geometry\n   */ async getMapContentCount(modulations) {\n        const geoJSON = this.getClusterGeometry();\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": true,\n            \"filters\": this.filters,\n            \"modulations\": modulations\n        };\n        const zoom = this.getZoom();\n        const data = await this.anycluster.getMapContentCount(zoom, postData);\n        return data;\n    }\n    async getFilteredMapContentCount(filters, modulations) {\n        const geoJSON = this.getClusterGeometry();\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": true,\n            \"filters\": filters,\n            \"modulations\": modulations\n        };\n        const zoom = this.getZoom();\n        const data = await this.anycluster.getMapContentCount(zoom, postData);\n        return data;\n    }\n    async getGroupedMapContents(groupBy) {\n        const geoJSON = this.getClusterGeometry();\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": true,\n            \"filters\": this.filters,\n            \"group_by\": groupBy\n        };\n        const zoom = this.getZoom();\n        const data = await this.anycluster.getGroupedMapContents(zoom, postData);\n        return data;\n    }\n    async getFilteredGroupedMapContents(filters, groupBy) {\n        const geoJSON = this.getClusterGeometry();\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": true,\n            \"filters\": filters,\n            \"group_by\": groupBy\n        };\n        const zoom = this.getZoom();\n        const data = await this.anycluster.getGroupedMapContents(zoom, postData);\n        return data;\n    }\n    // hooks\n    _onFinalClick(marker, data) {\n        alert(JSON.stringify(data));\n    }\n    _onGotClusters() {}\n}\n\n\n\n\n//# sourceMappingURL=main.js.map\n","export {\n    ClusterMethod,\n    GeometryType,\n    IconType,\n    SRIDS,\n    Operators,\n    LogicalOperators,\n} from \"./consts\";\n\nexport { \n    Anycluster,\n    Bounds3857,\n    Bounds4326,\n} from \"./anycluster\";\n\nexport type {\n    Filter,\n    GetKmeansClusterContentRequestData,\n    ClusterRequestData,\n    MapContentCountRequestData,\n    GroupedMapContentRequestData,\n    AreaContentRequestData,\n    FilterList,\n    NestedFilter,\n    FilterOrNestedFilter,\n    FilterOrNestedFilterList,\n    Modulations,\n} from \"./anycluster\";\n\nexport {\n    AnyclusterClient,\n} from \"./anycluster-client\";\n\nexport type {\n    AnyclusterClientSettings\n} from \"./anycluster-client\";\n\nexport type {\n    GeoJSON,\n    Marker,\n    Viewport,\n} from \"./geometry\";\n\nexport type {\n    KmeansCluster,\n    KmeansClusterResponse,\n    GridCluster,\n} from \"./types\";","\nexport interface MaxBounds {\n    minX: number,\n    maxX: number,\n    minY: number,\n    maxY: number\n}\n\nexport enum SRIDS {\n    EPSG4326 = 'EPSG:4326',\n    EPSG3857 = 'EPSG:3857'\n}\n\nexport enum ClusterMethod {\n    kmeans = 'kmeans',\n    grid = 'grid'\n}\n\n\nexport enum GeometryType {\n    viewport = 'viewport',\n    area = 'area'\n}\n\nexport enum IconType {\n    exact = 'exact',\n    rounded = 'rounded'\n}\n\nexport enum DefaultGridSizes {\n    grid = 64,\n    kmeans = 150\n}\n\nexport const DefaultMarkerImageSizes = {\n    1: [24, 39],\n    5: [30, 30],\n    10: [30, 30],\n    50: [40, 40],\n    100: [40, 40],\n    1000: [50, 50],\n    10000: [60, 60]\n}\n\nexport enum Operators {\n    in = 'in',\n    notIn = 'not in',\n    equals = '=',\n    unEquals = '!=',\n    largerThan = '>=',\n    smallerThan = '<=',\n    startswith = 'startswith',\n    contains = 'contains',\n}\n\nexport enum LogicalOperators {\n    AND = 'AND',\n    OR = 'OR',\n}\n\nexport const DefaultMaxZoom = 13;","import { SRIDS, MaxBounds, ClusterMethod, GeometryType, Operators, LogicalOperators } from \"./consts\";\nimport { Point, GeoJSON, Coordinates, Viewport } from \"./geometry\";\nimport type { KmeansClusterResponse } from \"./types\";\n\nexport const Bounds4326: MaxBounds = Object.freeze({\n    minX: -179,\n    maxX: 179,\n    minY: -89,\n    maxY: 89\n});\n\n\nexport const Bounds3857: MaxBounds = Object.freeze({\n    minX: -20037500, //-20037508.34\n    maxX: 20037500, // 20037508.34\n    minY: -20048960, // -20048966.1\n    maxY: 20048960 //  20048966.1\n});\n\nexport interface Filter {\n    column: string\n    value: string | number | boolean\n    operator: Operators\n    logicalOperator?: LogicalOperators\n}\n\nexport interface NestedFilter {\n    filters : Filter[]\n    logicalOperator?: LogicalOperators\n}\n\nexport type FilterOrNestedFilter = Filter | NestedFilter;\n\nexport interface ClusterRequestData {\n    output_srid: SRIDS\n    geometry_type: GeometryType\n    geojson: GeoJSON\n    clear_cache: boolean\n    filters: FilterOrNestedFilter[]\n}\n\nexport type FilterList = Filter[];\n\nexport type FilterOrNestedFilterList = FilterOrNestedFilter[];\n\nexport interface GetKmeansClusterContentRequestData {\n    geometry_type: GeometryType\n    geojson?: GeoJSON\n    input_srid: SRIDS\n    x: number\n    y: number\n    ids: number[]\n}\n\nexport interface Modulations {\n    [name:string] : FilterOrNestedFilter | FilterOrNestedFilterList\n}\n\nexport interface MapContentCountRequestData extends ClusterRequestData {\n    modulations?: Modulations\n}\n\nexport interface AreaContentRequestData extends ClusterRequestData {\n    limit?: number\n    offset?: number\n    order_by?: string\n}\n\nexport interface GroupedMapContentRequestData extends ClusterRequestData {\n    group_by: string\n}\n\nexport class Anycluster {\n\n    maxBounds: MaxBounds\n\n    constructor(private apiUrl: string, public gridSize: number, public srid: SRIDS) {\n\n        if (this.srid == SRIDS.EPSG4326) {\n            this.maxBounds = Bounds4326;\n        }\n        else if (this.srid == SRIDS.EPSG3857) {\n            this.maxBounds = Bounds3857;\n        }\n        else {\n            throw new Error(`invalid srid given: ${this.srid} `);\n        }\n\n    }\n\n    validateZoom(zoom: number) {\n        if (!Number.isInteger(zoom)) {\n            throw new Error(`[anycluster] non-integer zoom: ${zoom}`);\n        }\n    }\n\n    async getGridCluster(zoom: number, data: ClusterRequestData) {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}grid/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters;\n    }\n\n    async getKmeansCluster(zoom: number, data: ClusterRequestData): Promise<KmeansClusterResponse> {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}kmeans/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters;\n    }\n\n    async getKmeansClusterContent(zoom: number, data: GetKmeansClusterContentRequestData) {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}get-kmeans-cluster-content/${zoom}/${this.gridSize}/`;\n\n        const clusterContent = await this.post(url, data);\n\n        return clusterContent;\n    }\n\n    async getDatasetContent(zoom: number, datasetId: number) {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}get-dataset-content/${zoom}/${this.gridSize}/${datasetId}/`;\n\n        const clusterContent = await this.get(url);\n\n        return clusterContent;\n    }\n\n    async getMapContentCount(zoom: number, data: MapContentCountRequestData) {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}get-map-content-count/${zoom}/${this.gridSize}/`;\n\n        const mapContentCount = await this.post(url, data)\n\n        return mapContentCount;\n    }\n\n    async getGroupedMapContents(zoom: number, data: GroupedMapContentRequestData) {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}get-grouped-map-contents/${zoom}/${this.gridSize}/`;\n\n        const groupedMapContents = await this.post(url, data);\n\n        return groupedMapContents;\n\n    }\n\n    async getAreaContent(zoom:number, data: AreaContentRequestData) {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}get-area-content/${zoom}/${this.gridSize}/`;\n\n        const areaContent = await this.post(url, data);\n\n        return areaContent;\n    }\n\n    viewportToGeoJSON(viewport: Viewport) {\n\n        const left = Math.max(viewport.left, this.maxBounds.minX);\n        const right = Math.min(viewport.right, this.maxBounds.maxX);\n        const top = Math.min(viewport.top, this.maxBounds.maxY);\n        const bottom = Math.max(viewport.bottom, this.maxBounds.minY);\n\n        const geometryType = \"Polygon\";\n\n        const coordinates = [[\n            [left, top],\n            [right, top],\n            [right, bottom],\n            [left, bottom],\n            [left, top]\n        ]];\n\n        const geoJSON = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": geometryType,\n                \"coordinates\": coordinates,\n                \"crs\": {\n                    \"type\": \"name\",\n                    \"properties\": {\n                        \"name\": this.srid\n                    }\n                }\n            }\n        };\n\n        return geoJSON;\n    }\n\n    async post(url: string, postData: object) {\n\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'POST',\n            body: JSON.stringify(postData),\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n\n    }\n\n    async get(url: string) {\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n    }\n}","\nimport { ClusterMethod, GeometryType, IconType, SRIDS, DefaultGridSizes, DefaultMarkerImageSizes, DefaultMaxZoom } from \"./consts\";\nimport type { GeoJSON, Marker, Viewport } from \"./geometry\";\nimport type { GridCluster, KmeansCluster } from \"./types\";\nimport {\n  Anycluster,\n  GetKmeansClusterContentRequestData,\n  ClusterRequestData,\n  MapContentCountRequestData,\n  GroupedMapContentRequestData,\n  AreaContentRequestData,\n  Filter,\n  FilterList,\n  NestedFilter,\n  FilterOrNestedFilter,\n  FilterOrNestedFilterList,\n  Modulations,\n} from \"./anycluster\";\n\nconst defaultGridFillColors = {\n  5: \"rgba(255, 192, 203, .5)\",\n  10: \"rgba(240, 128, 128, .5)\",\n  50: \"rgba(255, 127, 80, .5)\",\n  100: \"rgba(255, 165, 0, .5)\",\n  1000: \"rgba(255, 69, 0, .5)\",\n  10000: \"rgba(255, 0 , 0, .5)\",\n};\n\nconst defaultGridStrokeColors = {\n  5: \"pink\",\n  10: \"lightcoral\",\n  50: \"coral\",\n  100: \"orange\",\n  1000: \"orangered\",\n  10000: \"red\",\n};\n\nexport interface AnyclusterClientSettings {\n  srid?: SRIDS // srid of the map\n  kmeansGridSize?: number\n  gridGridSize?: number\n  clusterMethod?: ClusterMethod\n  geometryType?: GeometryType\n  area?: any\n  iconType?: IconType\n  maxZoom?: number,\n  onFinalClick?: Function\n  singlePinImages?: Record<string, string>\n  getSinglePinImageURL?: Function\n  markerImageSizes?: Record<string, number[]>\n  gridFillColors?: Record<number, string>\n  gridStrokeColors?: Record<number, string>\n  onGotClusters?: () => void\n  startClustering?: boolean\n}\n\nexport class AnyclusterClient {\n\n  srid: SRIDS\n  kmeansGridSize: number\n  gridGridSize: number\n  clusterMethod: ClusterMethod\n  geometryType: GeometryType\n\n  area: GeoJSON | null\n  iconType: IconType\n\n  anycluster: Anycluster\n  markerList: any[]\n  maxZoom: number\n  onFinalClick: Function\n  onGotClusters: Function\n  singlePinImages?: Record<string, string>\n  getSinglePinImageURL: Function\n\n  markerImageSizes: Record<string, number[]>\n\n  gridFillColors: Record<number, string>\n  gridStrokeColors: Record<number, string>\n\n  filters: FilterOrNestedFilterList = []\n\n  isStartup: boolean = false // openlayers fires moveend after loadend. This triggers two clustering requests of which the latter has to be dismissed\n  latestFilterChangeTimestamp: number | null = null\n\n  constructor(public map: any, public apiUrl: string, public markerFolderPath: string, settings: AnyclusterClientSettings) {\n\n    this.map = map;\n    this.apiUrl = apiUrl;\n    this.markerFolderPath = markerFolderPath;\n\n    settings = settings || {};\n\n\n    // settings\n    this.srid = settings.srid ? settings.srid : SRIDS.EPSG4326;\n    this.kmeansGridSize = settings.gridGridSize ? settings.gridGridSize : DefaultGridSizes.kmeans;\n    this.gridGridSize = settings.gridGridSize ? settings.gridGridSize : DefaultGridSizes.grid;\n\n    this.clusterMethod = settings.clusterMethod ? settings.clusterMethod : ClusterMethod.kmeans;\n    this.geometryType = settings.geometryType ? settings.geometryType : GeometryType.viewport;\n\n    this.area = settings.area ? settings.area : null;\n    this.iconType = settings.iconType ? settings.iconType : IconType.rounded;\n\n    this.singlePinImages = settings.singlePinImages ? settings.singlePinImages : {};\n    this.getSinglePinImageURL = settings.getSinglePinImageURL ? settings.getSinglePinImageURL : this._getSinglePinImageURL;\n\n    this.markerImageSizes = settings.markerImageSizes ? settings.markerImageSizes : DefaultMarkerImageSizes;\n\n    this.gridFillColors = settings.gridFillColors ? settings.gridFillColors : defaultGridFillColors;\n    this.gridStrokeColors = settings.gridStrokeColors ? settings.gridStrokeColors : defaultGridStrokeColors;\n\n    this.maxZoom = settings.maxZoom ? settings.maxZoom : DefaultMaxZoom;\n    // hooks\n    this.onGotClusters = settings.onGotClusters ? settings.onGotClusters : this._onGotClusters;\n    this.onFinalClick = settings.onFinalClick ? settings.onFinalClick : this._onFinalClick;\n\n\n    if (this.area) {\n      this.setArea(this.area);\n    }\n\n    const gridSize = this.getGridSize();\n    this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n\n    this.createClusterLayers();\n    this.markerList = [];\n\n    const startClustering = settings.startClustering === false ? settings.startClustering : true;\n\n    if (startClustering === true) {\n      this.startClustering();\n    }\n  }\n\n  createClusterLayers(): void {\n    throw new Error(\"NotImplementedError: createClusterLayers\");\n  }\n\n  addArea(geojson: object): void {\n    throw new Error(\"NotImplementedError: addArea\");\n  }\n\n  removeArea(): void {\n    throw new Error(\"NotImplementedError: removeArea\");\n  }\n\n  removeAllMarkers(): void {\n    throw new Error(\"NotImplementedError: removeAllMarkers\");\n  }\n\n  getZoom(): number {\n    throw new Error(\"NotImplementedError: getZoom\");\n  }\n\n  setMap(x: number, y: number, zoom: number): void {\n    throw new Error(\"NotImplementedError: setMap\");\n  }\n\n  getViewport(): Viewport {\n    throw new Error(\"NotImplementedError: setMap\");\n  }\n\n  addMapEventListeners(): void {\n    throw new Error(\"NotImplementedError: addMapEventListeners\");\n  }\n\n  drawKmeansMarker(cluster: KmeansCluster): void {\n    throw new Error(\"NotImplementedError: drawKmeansMarker\");\n  }\n\n  drawCell(cluster: GridCluster): void {\n    throw new Error(\"NotImplementedError: drawCell\");\n  }\n\n  drawGridMarker(cluster: GridCluster): void {\n    throw new Error(\"NotImplementedError: drawGridMarker\");\n  }\n\n  getGridSize(): number {\n    if (this.clusterMethod == ClusterMethod.grid) {\n      return this.gridGridSize;\n    }\n\n    return this.kmeansGridSize;\n  }\n\n  setClusterMethod(clusterMethod: ClusterMethod) {\n\n    if (clusterMethod == ClusterMethod.grid) {\n      this.area = null;\n      this.geometryType = GeometryType.viewport;\n      this.removeArea();\n    }\n\n    this.removeAllMarkers();\n    this.clusterMethod = clusterMethod;\n    const gridSize = this.getGridSize();\n    this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n    this.markerList = [];\n    this.getClusters(true);\n  }\n\n  setArea(geojson: GeoJSON) {\n\n    this.area = geojson;\n\n    this.removeArea();\n\n    if (geojson == null) {\n      this.geometryType = GeometryType.viewport;\n      this.setClusterMethod(ClusterMethod.kmeans);\n    }\n    else {\n\n      this.addArea(geojson);\n\n      this.geometryType = GeometryType.area;\n\n      this.setClusterMethod(ClusterMethod.kmeans);\n    }\n  }\n\n  _getSinglePinImageURL(cluster: KmeansCluster | GridCluster) {\n\n    const pinimg = cluster.pinimg;\n\n    let url = `${this.markerFolderPath}pin_unknown.png`;\n\n    if (this.singlePinImages && pinimg && pinimg in this.singlePinImages) {\n      url = this.singlePinImages[pinimg];\n    }\n\n    return url\n\n  }\n\n  selectPinIcon(cluster: KmeansCluster | GridCluster) {\n\n    const count = cluster.count;\n\n    let markerImageUrl = this.getSinglePinImageURL(cluster);\n    let pinicon = \"1\";\n\n    if (count > 10000) {\n      pinicon = \"10000\";\n    }\n\n    else if (count > 1000) {\n      pinicon = \"1000\";\n    }\n\n    else if (count > 100) {\n      pinicon = \"100\";\n    }\n\n    else if (count > 50) {\n      pinicon = \"50\";\n    }\n\n    else if (count > 10) {\n      pinicon = \"10\";\n    }\n\n    else if (count > 1) {\n      pinicon = \"5\";\n    }\n\n    if (count > 1) {\n      if (this.iconType == IconType.exact) {\n        markerImageUrl = `${this.markerFolderPath}${pinicon}_empty.png`;\n      }\n      else {\n        markerImageUrl = `${this.markerFolderPath}${pinicon}.png`;\n      }\n    }\n\n    const size = this.markerImageSizes[pinicon];\n    let anchor = [Math.round(size[0] / 2), size[1] - 1];\n    let relativeAnchor = [0.5, 1];\n\n    if (count > 1) {\n      anchor = [Math.round((size[0] / 2)), Math.round(size[1] / 2)];\n      relativeAnchor = [0.5, 0.5];\n    }\n\n    const imgObj = {\n      url: markerImageUrl,\n      size: size,\n      anchor: anchor,\n      relativeAnchor: relativeAnchor,\n      popupAnchor: [0, -Math.round(size[1]) + 8]\n    }\n\n    return imgObj;\n\n  }\n\n  // marker can be an openlayers Feature or a L.marker\n  setMarkerProps(marker: any, cluster: KmeansCluster) {\n\n    // add properties required by anycluster\n    marker.x = cluster.center.x;\n    marker.y = cluster.center.y;\n    marker.count = cluster.count;\n    marker.ids = cluster.ids;\n\n    return marker;\n\n  }\n\n  setCellProps(cell: any, cluster: GridCluster) {\n    cell.x = cluster.center.x;\n    cell.y = cluster.center.y;\n    cell.count = cluster.count;\n    cell.id = cluster.id;\n    cell.geojson = cluster.geojson;\n\n    return cell;\n  }\n\n  markerClickFunction(x: number, y: number) {\n    this.removeAllMarkers();\n    let zoom = this.getZoom();\n    zoom = zoom + 3;\n    this.setMap(x, y, zoom);\n  }\n\n  async onMarkerFinalClick(marker: any) {\n\n    const zoom = this.getZoom();\n    const x = marker.x;\n    const y = marker.y;\n\n    const geoJSON = this.getClusterGeometry();\n\n    if (this.clusterMethod == ClusterMethod.kmeans) {\n\n      const ids = marker.ids;\n      \n      const postData = {\n        \"geometry_type\": this.geometryType,\n        \"geojson\": geoJSON,\n        \"input_srid\": this.srid,\n        \"x\": x,\n        \"y\": y,\n        \"ids\": ids,\n        \"filters\": this.filters\n      } as GetKmeansClusterContentRequestData;\n\n      const data = await this.anycluster.getKmeansClusterContent(zoom, postData);\n\n      this.onFinalClick(marker, data);\n\n    }\n    else if (this.clusterMethod = ClusterMethod.grid) {\n\n      if (marker.count == 1) {\n        const data = await this.anycluster.getDatasetContent(zoom, marker.id);\n        this.onFinalClick(marker, data);\n      }\n      else {\n        const geojson = marker[\"geojson\"];\n        const zoom = this.getZoom();\n        const data = await this.anycluster.getAreaContent(zoom, geojson);\n\n        this.onFinalClick(marker, data);\n      }\n\n    }\n  }\n\n  roundMarkerCount(count: number): number {\n\n    if (count == 1) {\n      count = 1;\n    }\n    else if (count <= 5) {\n      count = 5;\n    }\n    else if (count <= 10) {\n      count = 10;\n    }\n    else if (count <= 50) {\n      count = 50;\n    }\n    else if (count <= 100) {\n      count = 100;\n    }\n    else if (count <= 1000) {\n      count = 1000;\n    }\n    else {\n      count = 10000;\n    }\n\n    return count;\n  }\n\n  getClusterGeometry() {\n    let geoJSON;\n\n    if (this.geometryType == GeometryType.viewport) {\n      const viewport = this.getViewport();\n      geoJSON = this.anycluster.viewportToGeoJSON(viewport);\n    }\n    else if (this.geometryType == GeometryType.area && this.area) {\n      geoJSON = this.area;\n    }\n    else {\n      throw new Error('No cluster geometry found');\n    }\n\n    return geoJSON;\n\n  }\n\n  async getClusters(clearCache = false) {\n\n    const geoJSON = this.getClusterGeometry();\n\n    const postData = {\n      \"output_srid\": this.srid,\n      \"geometry_type\": this.geometryType,\n      \"geojson\": geoJSON,\n      \"clear_cache\": clearCache,\n      \"filters\": this.filters\n    } as ClusterRequestData;\n\n    const zoom = this.getZoom();\n    const filterTimestamp = this.latestFilterChangeTimestamp;\n\n    if (this.clusterMethod == ClusterMethod.kmeans) {\n      const clusters: KmeansCluster[] = await this.anycluster.getKmeansCluster(zoom, postData);\n      const postResponseZoom = this.getZoom();\n      // only draw markers/cells if the user did not zoom or change filters during the wait for the response\n      if (clusters.length > 0 && filterTimestamp === this.latestFilterChangeTimestamp && zoom === postResponseZoom) {\n        clusters.forEach(cluster => {\n          this.drawKmeansMarker(cluster);\n        });\n\n        this.onGotClusters();\n      } else {\n        console.log(`[anycluster]: not drawing markers because of outdated response`);\n      }\n\n    } else if (this.clusterMethod == ClusterMethod.grid ) {\n      const clusters: GridCluster[] = await this.anycluster.getGridCluster(zoom, postData);\n      const postResponseZoom = this.getZoom();\n\n      // only draw markers/cells if the user did not zoom or change filters during the wait for the response\n      if (clusters.length > 0 && filterTimestamp === this.latestFilterChangeTimestamp && zoom === postResponseZoom) {\n        clusters.forEach(cluster => {\n            this.drawCell(cluster);\n        });\n\n        this.onGotClusters();\n      } else {\n        console.log(`[anycluster]: not drawing markers because of outdated response`);\n      }\n    } else {\n      throw new Error(`Invalid clusterMethod: ${this.clusterMethod}`);\n    }\n  }\n\n  async startClustering() {\n    this.isStartup = true;\n    await this.getClusters(true);\n    this.addMapEventListeners();\n    this.isStartup = false;\n  }\n\n  filtersAreEqual(filter1: FilterOrNestedFilter, filter2: FilterOrNestedFilter): boolean {\n    if ('column' in filter1 && 'column' in filter2) {\n      if (filter1.column == filter2.column && filter1.value == filter2.value && filter1.operator == filter2.operator) {\n        return true;\n      }\n    }\n    // testing with json.stringify is not ideal because {\"a\":1,\"b\":2} === {\"b\":2,\"a\":1} returns false\n    else if (JSON.stringify(filter1) === JSON.stringify(filter2)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // filtering\n  filter(filter: Filter | NestedFilter | FilterOrNestedFilter[], reloadMarkers?: boolean) {\n\n    if (Array.isArray(filter)) {\n      this.filters = filter;\n    }\n    else {\n      this.filters = [filter];\n    }\n    this.postFilterChange(reloadMarkers);\n  }\n\n  addFilter(filter: Filter, reloadMarkers?: boolean) {\n\n    let filterExists = false;\n\n    for (let f = 0; f < this.filters.length; f++) {\n      let existingFilter: FilterOrNestedFilter = this.filters[f];\n\n      if (this.filtersAreEqual(filter, existingFilter)) {\n        filterExists = true;\n        break;\n      }\n\n    }\n\n    if (!filterExists) {\n      this.filters.push(filter);\n    }\n\n    this.postFilterChange(reloadMarkers);\n  }\n\n  addFilters(filtersToAdd: FilterList, reloadMarkers?: boolean) {\n\n    for (let fa = 0; fa < filtersToAdd.length; fa++) {\n      let filter = filtersToAdd[fa];\n      this.addFilter(filter, false);\n    }\n    this.postFilterChange(reloadMarkers);\n  }\n\n  removeFilter(filter: Filter, reloadMarkers?: boolean) {\n\n    for (let f = 0; f < this.filters.length; f++) {\n      let existingFilter: FilterOrNestedFilter = this.filters[f];\n\n      if (this.filtersAreEqual(filter, existingFilter)) {\n        this.filters.splice(f, 1);\n        break;\n      }\n    }\n    this.postFilterChange(reloadMarkers);\n  }\n\n  removeFilters(filtersToRemove: FilterList, reloadMarkers?: boolean) {\n\n    for (let fr = 0; fr < filtersToRemove.length; fr++) {\n\n      let filter = filtersToRemove[fr];\n\n      this.removeFilter(filter, false);\n    }\n\n    this.postFilterChange(reloadMarkers);\n  }\n\n  resetFilters(reloadMarkers?: boolean) {\n    this.filters = [];\n    this.postFilterChange(reloadMarkers);\n  }\n\n  postFilterChange(reloadMarkers?: boolean) {\n\n    this.latestFilterChangeTimestamp = new Date().getTime();\n\n    if (reloadMarkers != false) {\n      reloadMarkers = true;\n    }\n    if (reloadMarkers == true) {\n      this.removeAllMarkers();\n      this.getClusters(true);\n    }\n  }\n\n\n  /**\n   * method for getting the unaggregated, paginated content of the map\n   */\n  async getMapContents(limit?: number, offset?: number, orderBy?: string) {\n    const geoJSON = this.getClusterGeometry();\n    const zoom = this.getZoom();\n\n    const postData = {\n      \"output_srid\": this.srid,\n      \"geometry_type\": GeometryType.area,\n      \"geojson\": geoJSON,\n      \"clear_cache\": false,\n      \"filters\": this.filters,\n      \"limit\": limit,\n      \"offset\": offset,\n      \"order_by\": orderBy,\n    } as AreaContentRequestData;\n\n    const data = this.anycluster.getAreaContent(zoom, postData);\n\n    return data;\n  }\n\n  /**\n   * methods for getting counts of objects on the current map / geometry\n   */\n\n  async getMapContentCount(modulations?: Modulations) {\n\n    const geoJSON = this.getClusterGeometry()\n\n    const postData = {\n      \"output_srid\": this.srid,\n      \"geometry_type\": this.geometryType,\n      \"geojson\": geoJSON,\n      \"clear_cache\": true,\n      \"filters\": this.filters,\n      \"modulations\": modulations,\n    } as MapContentCountRequestData;\n\n    const zoom = this.getZoom();\n\n    const data = await this.anycluster.getMapContentCount(zoom, postData);\n\n    return data;\n  }\n\n  async getFilteredMapContentCount(filters?: FilterOrNestedFilterList, modulations?: Modulations) {\n    const geoJSON = this.getClusterGeometry()\n\n    const postData = {\n      \"output_srid\": this.srid,\n      \"geometry_type\": this.geometryType,\n      \"geojson\": geoJSON,\n      \"clear_cache\": true,\n      \"filters\": filters,\n      \"modulations\": modulations,\n    } as MapContentCountRequestData;\n\n    const zoom = this.getZoom();\n\n    const data = await this.anycluster.getMapContentCount(zoom, postData);\n\n    return data;\n  }\n\n  async getGroupedMapContents(groupBy: string) {\n    const geoJSON = this.getClusterGeometry()\n\n    const postData = {\n      \"output_srid\": this.srid,\n      \"geometry_type\": this.geometryType,\n      \"geojson\": geoJSON,\n      \"clear_cache\": true,\n      \"filters\": this.filters,\n      \"group_by\": groupBy,\n    } as GroupedMapContentRequestData;\n\n    const zoom = this.getZoom();\n\n    const data = await this.anycluster.getGroupedMapContents(zoom, postData);\n\n    return data;\n\n  }\n\n  async getFilteredGroupedMapContents(filters: FilterOrNestedFilterList, groupBy: string) {\n    const geoJSON = this.getClusterGeometry()\n\n    const postData = {\n      \"output_srid\": this.srid,\n      \"geometry_type\": this.geometryType,\n      \"geojson\": geoJSON,\n      \"clear_cache\": true,\n      \"filters\": filters,\n      \"group_by\": groupBy,\n    } as GroupedMapContentRequestData;\n\n    const zoom = this.getZoom();\n\n    const data = await this.anycluster.getGroupedMapContents(zoom, postData);\n\n    return data;\n  }\n\n  // hooks\n  _onFinalClick(marker: Marker, data: any) {\n    alert(JSON.stringify(data));\n  }\n\n  _onGotClusters() { }\n\n}"],"names":["$d23ecb6e11364e2e$export$55fee9ea2526ad0d","$d23ecb6e11364e2e$export$ae91e066970d978a","$d23ecb6e11364e2e$export$8f4397a63c3cef66","$d23ecb6e11364e2e$export$13ff1290a9e22e77","$d23ecb6e11364e2e$export$9c3a9f8fbf06a34","$d23ecb6e11364e2e$export$7fa100a28fbb5fe2","$d23ecb6e11364e2e$export$9a28c02ac0f6fc9d","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","module","exports","$a84c901b6d8dcdc7$export$5e01b9ff483562af","$a84c901b6d8dcdc7$export$6db2f048e15a981e","$a84c901b6d8dcdc7$export$2104d4dd9d4984b2","$873ecc376aa9f94e$export$a09c19a7c4419c1","SRIDS","ClusterMethod","GeometryType","IconType","DefaultGridSizes","$d23ecb6e11364e2e$export$96b1907ff7fa3578","Operators","LogicalOperators","freeze","minX","maxX","minY","maxY","constructor","apiUrl","gridSize","srid","EPSG4326","maxBounds","EPSG3857","Error","validateZoom","zoom","Number","isInteger","getGridCluster","data","url","clusters","post","getKmeansCluster","getKmeansClusterContent","clusterContent","getDatasetContent","datasetId","getMapContentCount","mapContentCount","getGroupedMapContents","groupedMapContents","getAreaContent","areaContent","viewportToGeoJSON","viewport","left","Math","max","right","min","top","bottom","geoJSON","postData","encodedUrl","encodeURI","options","method","body","JSON","stringify","headers","mode","credentials","response","fetch","responseData","json","ok","$873ecc376aa9f94e$var$defaultGridFillColors","$873ecc376aa9f94e$var$defaultGridStrokeColors","map","markerFolderPath","settings","filters","isStartup","latestFilterChangeTimestamp","kmeansGridSize","gridGridSize","kmeans","grid","clusterMethod","geometryType","area","iconType","rounded","singlePinImages","getSinglePinImageURL","_getSinglePinImageURL","markerImageSizes","gridFillColors","gridStrokeColors","maxZoom","onGotClusters","_onGotClusters","onFinalClick","_onFinalClick","setArea","getGridSize","anycluster","createClusterLayers","markerList","startClustering","addArea","geojson","removeArea","removeAllMarkers","getZoom","setMap","x","y","getViewport","addMapEventListeners","drawKmeansMarker","cluster","drawCell","drawGridMarker","setClusterMethod","getClusters","pinimg","selectPinIcon","count","markerImageUrl","pinicon","exact","size","anchor","round","relativeAnchor","imgObj","popupAnchor","setMarkerProps","marker","center","ids","setCellProps","cell","id","markerClickFunction","onMarkerFinalClick","getClusterGeometry","roundMarkerCount","clearCache","filterTimestamp","postResponseZoom","length","forEach","console","log","filtersAreEqual","filter1","filter2","column","value","operator","filter","reloadMarkers","Array","isArray","postFilterChange","addFilter","filterExists","f","existingFilter","push","addFilters","filtersToAdd","fa","removeFilter","splice","removeFilters","filtersToRemove","fr","resetFilters","Date","getTime","getMapContents","limit","offset","orderBy","modulations","getFilteredMapContentCount","groupBy","getFilteredGroupedMapContents","alert"],"version":3,"file":"main.js.map"}