{"mappings":"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","sources":["src/consts.ts","src/anycluster.ts","src/anycluster-client.ts"],"sourcesContent":["\nexport interface MaxBounds {\n    minX: number,\n    maxX: number,\n    minY: number,\n    maxY: number\n}\n\nexport enum SRIDS {\n    EPSG4326 = 'EPSG:4326',\n    EPSG3857 = 'EPSG:3857'\n}\n\nexport enum ClusterMethod {\n    kmeans = 'kmeans',\n    grid = 'grid'\n}\n\n\nexport enum GeometryType {\n    viewport = 'viewport',\n    area = 'area'\n}\n\nexport enum IconType {\n    exact = 'exact',\n    rounded = 'rounded'\n}\n\nexport enum DefaultGridSizes {\n    grid = 64,\n    kmeans = 150\n}\n\nexport const DefaultMarkerImageSizes = {\n    1: [24, 39],\n    5: [30, 30],\n    10: [30, 30],\n    50: [40, 40],\n    100: [40, 40],\n    1000: [50, 50],\n    10000: [60, 60]\n}","import { SRIDS, MaxBounds, ClusterMethod, GeometryType } from \"./consts\";\nimport { Point, GeoJSON, Coordinates, Viewport } from \"./geometry\";\n\nexport const Bounds4326: MaxBounds = Object.freeze({\n    minX: -179,\n    maxX: 179,\n    minY: -89,\n    maxY: 89\n})\n\n\nexport const Bounds3857: MaxBounds = Object.freeze({\n    minX: -20037500, //-20037508.34\n    maxX: 20037500, // 20037508.34\n    minY: -20048960, // -20048966.1\n    maxY: 20048960 //  20048966.1\n})\n\n/*\nexport interface AnyclusterSettings {\n    gridSize: number\n    srid: SRIDS\n    autostart?: boolean\n    filters?: []\n    initialCenter?: Point\n    clusterArea?: object\n}*/\n\nexport interface ClusterRequestData {\n    output_srid: SRIDS\n    geometry_type: GeometryType\n    geojson: GeoJSON\n    clear_cache: boolean\n    filters: object[]\n}\n\nexport interface GetKmeansClusterContentRequestData {\n    geometry_type: GeometryType\n    input_srid: SRIDS\n    x: number\n    y: number\n    ids: number[]\n}\n\n\nexport class Anycluster {\n\n    filters: object[] = []\n    maxBounds: MaxBounds\n\n    constructor(private apiUrl: string, public gridSize: number, public srid: SRIDS) {\n\n        if (this.srid == SRIDS.EPSG4326) {\n            this.maxBounds = Bounds4326;\n        }\n        else if (this.srid == SRIDS.EPSG3857) {\n            this.maxBounds = Bounds3857;\n        }\n        else {\n            throw new Error(`invalid srid given: ${this.srid} `);\n        }\n\n    }\n\n    async getGridCluster(zoom: number, data: ClusterRequestData) {\n        const url = `${this.apiUrl}grid/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters;\n    }\n\n    async getKmeansCluster(zoom: number, data: ClusterRequestData) {\n\n        const url = `${this.apiUrl}kmeans/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters\n    }\n\n    async getKmeansClusterContent(zoom: number, data: GetKmeansClusterContentRequestData) {\n\n        const url = `${this.apiUrl}get-kmeans-cluster-content/${zoom}/${this.gridSize}/`;\n\n        const clusterContent = await this.post(url, data);\n\n        return clusterContent;\n    }\n\n    async getDatasetContent(zoom: number, datasetId: number) {\n        const url = `${this.apiUrl}get-dataset-content/${zoom}/${this.gridSize}/${datasetId}/`;\n\n        const clusterContent = await this.get(url);\n\n        return clusterContent;\n    }\n\n    getAreaContent() {\n\n    }\n\n    addFilters() {\n\n    }\n\n    removeFilters() {\n\n    }\n\n\n    viewportToGeoJSON(viewport: Viewport) {\n\n        const left = Math.max(viewport.left, this.maxBounds.minX);\n        const right = Math.min(viewport.right, this.maxBounds.maxX);\n        const top = Math.min(viewport.top, this.maxBounds.maxY);\n        const bottom = Math.max(viewport.bottom, this.maxBounds.minY);\n\n        const geometryType = \"Polygon\";\n\n        const coordinates = [[\n            [left, top],\n            [right, top],\n            [right, bottom],\n            [left, bottom],\n            [left, top]\n        ]];\n\n        const geoJSON = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": geometryType,\n                \"coordinates\": coordinates,\n                \"crs\": {\n                    \"type\": \"name\",\n                    \"properties\": {\n                        \"name\": this.srid\n                    }\n                }\n            }\n        };\n\n        return geoJSON;\n    }\n\n    async post(url: string, postData: object) {\n\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'POST',\n            body: JSON.stringify(postData),\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n\n    }\n\n    async get(url: string) {\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n    }\n}","\nimport { ClusterMethod, GeometryType, IconType, SRIDS, DefaultGridSizes, DefaultMarkerImageSizes } from \"./consts\";\nimport { GeoJSON, Marker, Cluster, Viewport } from \"./geometry\";\nimport { Anycluster, GetKmeansClusterContentRequestData, ClusterRequestData } from \"./anycluster\";\n\n\nexport interface AnyclusterClientSettings {\n    srid?: SRIDS // srid of the map\n    kmeansGridSize?: number\n    gridGridSize?: number\n    clusterMethod?: ClusterMethod\n    geometryType?: GeometryType\n    area?: any\n    iconType?: IconType\n    onFinalClick?: Function\n    singlePinImages?: Record<string, string>\n    markerImageSizes?: Record<string, number[]>\n    gridFillColors?: Record<number, string>\n    gridStrokeColors?: Record<number, string>\n}\n\nexport class AnyclusterClient {\n\n    srid: SRIDS\n    kmeansGridSize: number\n    gridGridSize: number\n    clusterMethod: ClusterMethod\n    geometryType: GeometryType\n\n    area: GeoJSON | null\n    iconType: IconType\n\n    anycluster: Anycluster\n    markerList: any[]\n    onFinalClick: Function\n    singlePinImages?: Record<string, string>\n\n    markerImageSizes: Record<string, number[]>\n\n    filters: any[] = []\n\n\n    constructor(public map: any, public apiUrl: string, public markerFolderPath: string, settings: AnyclusterClientSettings) {\n\n        this.map = map;\n        this.apiUrl = apiUrl;\n        this.markerFolderPath = markerFolderPath;\n\n        settings = settings || {};\n\n\n        // settings\n        this.srid = settings.srid ? settings.srid : SRIDS.EPSG4326;\n        this.kmeansGridSize = settings.gridGridSize ? settings.gridGridSize: DefaultGridSizes.kmeans;\n        this.gridGridSize = settings.gridGridSize ? settings.gridGridSize: DefaultGridSizes.grid;\n\n        this.clusterMethod = settings.clusterMethod ? settings.clusterMethod : ClusterMethod.kmeans;\n        this.geometryType = settings.geometryType ? settings.geometryType : GeometryType.viewport;\n\n        this.area = settings.area ? settings.area : null;\n        this.iconType = settings.iconType ? settings.iconType : IconType.rounded;\n\n        this.onFinalClick = settings.onFinalClick ? settings.onFinalClick : this._onFinalClick;\n\n        this.singlePinImages = settings.singlePinImages ? settings.singlePinImages : {};\n\n        this.markerImageSizes = settings.markerImageSizes ? settings.markerImageSizes : DefaultMarkerImageSizes;\n        \n\n        if (this.area) {\n            this.setArea(this.area);\n        }\n\n        const gridSize = this.getGridSize();\n        this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n\n        this.createClusterLayers();\n        this.markerList = [];\n\n        this.startClustering();\n    }\n\n    createClusterLayers(): void {\n        throw new Error(\"NotImplementedError: createClusterLayers\");\n    }\n\n    addArea(geojson: object): void {\n        throw new Error(\"NotImplementedError: addArea\");\n    }\n\n    removeArea(): void {\n        throw new Error(\"NotImplementedError: removeArea\");\n    }\n\n    removeAllMarkers(): void {\n        throw new Error(\"NotImplementedError: removeAllMarkers\");\n    }\n\n    getZoom(): number {\n        throw new Error(\"NotImplementedError: getZoom\");\n    }\n\n    setMap(x: number, y: number, zoom: number): void {\n        throw new Error(\"NotImplementedError: setMap\");\n    }\n\n    getViewport(): Viewport {\n        throw new Error(\"NotImplementedError: setMap\");\n    }\n\n    addMapEventListeners(): void {\n        throw new Error(\"NotImplementedError: addMapEventListeners\");\n    }\n\n    drawMarker(cluster: Cluster): void {\n        throw new Error(\"NotImplementedError: drawMarker\");\n    }\n\n    drawCell(cluster: Cluster): void {\n        throw new Error(\"NotImplementedError: drawCell\");\n    }\n\n    getAreaContent(geojson: GeoJSON): void {\n        throw new Error(\"NotImplementedError: getAreaContent\");\n    }\n\n\n    getGridSize(): number {\n        if (this.clusterMethod == ClusterMethod.grid) {\n            return this.gridGridSize;\n        }\n\n        return this.kmeansGridSize;\n    }\n\n    setClusterMethod(clusterMethod: ClusterMethod) {\n\n        if (clusterMethod == ClusterMethod.grid) {\n            this.area = null;\n            this.geometryType = GeometryType.viewport;\n            this.removeArea();\n        }\n\n        this.removeAllMarkers();\n        this.clusterMethod = clusterMethod;\n        const gridSize = this.getGridSize();\n        this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n        this.markerList = [];\n        this.getClusters(true);\n    }\n\n    setArea(geojson: GeoJSON) {\n\n        this.area = geojson;\n\n        this.removeArea();\n\n        if (geojson == null) {\n            this.geometryType = GeometryType.viewport;\n            this.setClusterMethod(ClusterMethod.kmeans);\n        }\n        else {\n\n            this.addArea(geojson);\n\n            this.geometryType = GeometryType.area;\n\n            this.setClusterMethod(ClusterMethod.kmeans);\n        }\n    }\n\n    getSinglePinImageURL(cluster: Cluster) {\n\n        const pinimg = cluster.pinimg;\n\n        let url = `${this.markerFolderPath}pin_unknown.png`;\n\n        if (this.singlePinImages && pinimg && pinimg in this.singlePinImages) {\n            url = this.singlePinImages[pinimg];\n        }\n\n        return url\n\n    }\n\n    selectPinIcon(cluster: Cluster) {\n\n        const count = cluster.count;\n\n        let markerImageUrl = this.getSinglePinImageURL(cluster);\n        let pinicon = \"1\";\n\n        if (count > 10000) {\n            pinicon = \"10000\";\n        }\n\n        else if (count > 1000) {\n            pinicon = \"1000\";\n        }\n\n        else if (count > 100) {\n            pinicon = \"100\";\n        }\n\n        else if (count > 50) {\n            pinicon = \"50\";\n        }\n\n        else if (count > 10) {\n            pinicon = \"10\";\n        }\n\n        else if (count > 1) {\n            pinicon = \"5\";\n        }\n\n        if (count > 1) {\n            if (this.iconType == IconType.exact) {\n                markerImageUrl = `${this.markerFolderPath}${pinicon}_empty.png`;\n            }\n            else {\n                markerImageUrl = `${this.markerFolderPath}${pinicon}.png`;\n            }\n        }\n\n        const size = this.markerImageSizes[pinicon];\n        let anchor = [Math.round(size[0] / 2), size[1] - 1];\n        let relativeAnchor = [0.5, 1];\n\n        if (count > 1) {\n            anchor = [Math.round((size[0] / 2)), Math.round(size[1] / 2)];\n            relativeAnchor = [0.5, 0.5];\n        }\n\n        const imgObj = {\n            url: markerImageUrl,\n            size: size,\n            anchor: anchor,\n            relativeAnchor: relativeAnchor,\n            popupAnchor: [0, -Math.round(size[1]) + 8]\n        }\n\n        return imgObj;\n\n    }\n\n    // marker can be an openlayers Feature or a L.marker\n    setMarkerProps(marker: any, cluster: Cluster) {\n\n        // add properties required by anycluster\n        marker.x = cluster.center.x;\n        marker.y = cluster.center.y;\n        marker.count = cluster.count;\n\n        if (cluster.hasOwnProperty(\"ids\")) {\n            marker.ids = cluster.ids;\n        }\n\n        if (cluster.hasOwnProperty(\"id\")) {\n            marker.id = cluster.id;\n        }\n\n        if (cluster.hasOwnProperty(\"geojson\")) {\n            \n            /*const geojson = {\n                \"type\": \"Feature\",\n                \"count\": cluster.count,\n                \"geometry\": cluster.geojson,\n                \"properties\": {\n                    \"count\": cluster.count\n                },\n                \"crs\" : {\n                    \"type\" : \"name\",\n                    \"properties\" : {\n                        \"name\" : this.srid\n                    }\n                }\n            };*/\n\n            marker.geojson = cluster.geojson;\n        }\n\n        return marker;\n\n    }\n\n    markerClickFunction(x: number, y: number) {\n        this.removeAllMarkers();\n        let zoom = this.getZoom();\n        zoom = zoom + 3;\n        this.setMap(x, y, zoom);\n    }\n\n    async onMarkerFinalClick(marker: any) {\n\n        const zoom = this.getZoom();\n        const x = marker.x;\n        const y = marker.y;\n        const ids = marker.ids;\n\n        if (this.clusterMethod == ClusterMethod.kmeans) {\n\n            const postData = {\n                \"geometry_type\": this.geometryType,\n                \"input_srid\": this.srid,\n                \"x\": x,\n                \"y\": y,\n                \"ids\": ids,\n                \"filters\": this.filters\n            } as GetKmeansClusterContentRequestData;\n\n            const data = await this.anycluster.getKmeansClusterContent(zoom, postData);\n\n            this.onFinalClick(marker, data);\n\n        }\n        else if (this.clusterMethod = ClusterMethod.grid) {\n\n            if (marker.count == 1) {\n                const data = await this.anycluster.getDatasetContent(zoom, marker.id);\n                this.onFinalClick(marker, data);\n            }\n            else {\n                const geojson = marker[\"geojson\"];\n                const data = await this.getAreaContent(geojson);\n\n                this.onFinalClick(marker, data);\n            }\n\n        }\n    }\n\n    roundMarkerCount(count: number): number {\n\n        if (count == 1) {\n            count = 1;\n        }\n        else if (count <= 5) {\n            count = 5;\n        }\n        else if (count <= 10) {\n            count = 10;\n        }\n        else if (count <= 50) {\n            count = 50;\n        }\n        else if (count <= 100) {\n            count = 100;\n        }\n        else if (count <= 1000) {\n            count = 1000;\n        }\n        else {\n            count = 10000;\n        }\n\n        return count;\n    }\n\n    getClusterGeometry() {\n        let geoJSON;\n\n        if (this.geometryType == GeometryType.viewport) {\n            const viewport = this.getViewport();\n            geoJSON = this.anycluster.viewportToGeoJSON(viewport);\n        }\n        else if (this.geometryType == GeometryType.area && this.area) {\n            geoJSON = this.area;\n        }\n        else {\n            throw new Error('No cluster geometry found');\n        }\n\n        return geoJSON;\n\n    }\n\n    async getClusters(clearCache = false) {\n\n        const geoJSON = this.getClusterGeometry()\n\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": clearCache\n        } as ClusterRequestData;\n\n        const zoom = this.getZoom();\n\n        if (this.clusterMethod == ClusterMethod.kmeans) {\n\n\n            const clusters: Cluster[] = await this.anycluster.getKmeansCluster(zoom, postData);\n\n            if (clusters.length > 0) {\n                clusters.forEach(cluster => {\n                    this.drawMarker(cluster);\n                });\n            }\n        }\n        else if (this.clusterMethod == ClusterMethod.grid) {\n            const clusters: Cluster[] = await this.anycluster.getGridCluster(zoom, postData);\n\n            if (clusters.length > 0) {\n                clusters.forEach(cluster => {\n                    this.drawCell(cluster);\n                });\n            }\n        }\n        else {\n            throw new Error(`Invalid clusterMethod: ${this.clusterMethod}`);\n        }\n    }\n\n    startClustering() {\n        this.getClusters(true);\n        this.addMapEventListeners();\n    }\n\n    _onFinalClick(marker: Marker, data: any) {\n        alert(JSON.stringify(data));\n    }\n\n}"],"names":["$d23ecb6e11364e2e$export$55fee9ea2526ad0d","SRIDS","$d23ecb6e11364e2e$export$ae91e066970d978a","ClusterMethod","$d23ecb6e11364e2e$export$8f4397a63c3cef66","GeometryType","$d23ecb6e11364e2e$export$13ff1290a9e22e77","IconType","$d23ecb6e11364e2e$export$9c3a9f8fbf06a34","DefaultGridSizes","$d23ecb6e11364e2e$export$96b1907ff7fa3578","$a84c901b6d8dcdc7$export$2104d4dd9d4984b2","Object","freeze","minX","maxX","minY","maxY","$a84c901b6d8dcdc7$export$6db2f048e15a981e","$a84c901b6d8dcdc7$export$5e01b9ff483562af","constructor","apiUrl","gridSize","srid","filters","this","EPSG4326","maxBounds","EPSG3857","Error","async","zoom","data","url","post","datasetId","get","getAreaContent","addFilters","removeFilters","viewportToGeoJSON","viewport","left","Math","max","right","min","top","bottom","type","geometry","coordinates","crs","properties","name","postData","encodedUrl","encodeURI","options","method","body","JSON","stringify","headers","mode","credentials","response","fetch","responseData","json","ok","$873ecc376aa9f94e$export$a09c19a7c4419c1","map","markerFolderPath","settings","kmeansGridSize","gridGridSize","kmeans","grid","clusterMethod","geometryType","area","iconType","rounded","onFinalClick","_onFinalClick","singlePinImages","markerImageSizes","setArea","getGridSize","anycluster","createClusterLayers","markerList","startClustering","addArea","geojson","removeArea","removeAllMarkers","getZoom","setMap","x","y","getViewport","addMapEventListeners","drawMarker","cluster","drawCell","setClusterMethod","getClusters","getSinglePinImageURL","pinimg","selectPinIcon","count","markerImageUrl","pinicon","exact","size","anchor","round","relativeAnchor","popupAnchor","setMarkerProps","marker","center","hasOwnProperty","ids","id","markerClickFunction","geometry_type","input_srid","getKmeansClusterContent","getDatasetContent","roundMarkerCount","getClusterGeometry","geoJSON","clearCache","output_srid","clear_cache","clusters","getKmeansCluster","length","forEach","getGridCluster","alert"],"version":3,"file":"main.js.map"}