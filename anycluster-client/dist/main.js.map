{"mappings":"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","sources":["src/consts.ts","src/anycluster.ts","src/anycluster-client.ts"],"sourcesContent":["\nexport interface MaxBounds {\n    minX: number,\n    maxX: number,\n    minY: number,\n    maxY: number\n}\n\nexport enum SRIDS {\n    EPSG4326 = 'EPSG:4326',\n    EPSG3857 = 'EPSG:3857'\n}\n\nexport enum ClusterMethod {\n    kmeans = 'kmeans',\n    grid = 'grid'\n}\n\n\nexport enum GeometryType {\n    viewport = 'viewport',\n    area = 'area'\n}\n\nexport enum IconType {\n    exact = 'exact',\n    rounded = 'rounded'\n}\n\nexport enum DefaultGridSizes {\n    grid = 64,\n    kmeans = 150\n}\n\nexport const DefaultMarkerImageSizes = {\n    1: [24, 39],\n    5: [30, 30],\n    10: [30, 30],\n    50: [40, 40],\n    100: [40, 40],\n    1000: [50, 50],\n    10000: [60, 60]\n}\n\nexport enum Operators {\n    in = 'in',\n    notIn = 'not in',\n    equals = '=',\n    unEquals = '!=',\n    largerThan = '>=',\n    smallerThan = '<=',\n    startswith = 'startswith',\n    contains = 'contains',\n}\n\nexport enum LogicalOperators {\n    AND = 'AND',\n    OR = 'OR',\n}","import { SRIDS, MaxBounds, ClusterMethod, GeometryType, Operators, LogicalOperators } from \"./consts\";\nimport { Point, GeoJSON, Coordinates, Viewport } from \"./geometry\";\n\nexport const Bounds4326: MaxBounds = Object.freeze({\n    minX: -179,\n    maxX: 179,\n    minY: -89,\n    maxY: 89\n})\n\n\nexport const Bounds3857: MaxBounds = Object.freeze({\n    minX: -20037500, //-20037508.34\n    maxX: 20037500, // 20037508.34\n    minY: -20048960, // -20048966.1\n    maxY: 20048960 //  20048966.1\n})\n\nexport interface Filter {\n    column: string\n    value: string | number | boolean\n    operator: Operators\n    logicalOperator?: LogicalOperators\n}\n\nexport interface NestedFilter {\n    filters : Filter[]\n    logicalOperator?: LogicalOperators\n}\n\nexport type FilterOrNestedFilter = Filter | NestedFilter;\n\nexport interface ClusterRequestData {\n    output_srid: SRIDS\n    geometry_type: GeometryType\n    geojson: GeoJSON\n    clear_cache: boolean\n    filters: FilterOrNestedFilter[]\n}\n\nexport type FilterList = Filter[];\n\nexport type FilterOrNestedFilterList = FilterOrNestedFilter[];\n\nexport interface GetKmeansClusterContentRequestData {\n    geometry_type: GeometryType\n    input_srid: SRIDS\n    x: number\n    y: number\n    ids: number[]\n}\n\nexport interface Modulations {\n    [name:string] : Filter | NestedFilter\n}\n\nexport interface MapContentCountRequestData extends ClusterRequestData {\n    modulations?: Modulations\n}\n\nexport interface GroupedMapContentRequestData extends ClusterRequestData {\n    group_by: string\n}\n\nexport class Anycluster {\n\n    maxBounds: MaxBounds\n\n    constructor(private apiUrl: string, public gridSize: number, public srid: SRIDS) {\n\n        if (this.srid == SRIDS.EPSG4326) {\n            this.maxBounds = Bounds4326;\n        }\n        else if (this.srid == SRIDS.EPSG3857) {\n            this.maxBounds = Bounds3857;\n        }\n        else {\n            throw new Error(`invalid srid given: ${this.srid} `);\n        }\n\n    }\n\n    async getGridCluster(zoom: number, data: ClusterRequestData) {\n        const url = `${this.apiUrl}grid/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters;\n    }\n\n    async getKmeansCluster(zoom: number, data: ClusterRequestData) {\n\n        const url = `${this.apiUrl}kmeans/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters\n    }\n\n    async getKmeansClusterContent(zoom: number, data: GetKmeansClusterContentRequestData) {\n\n        const url = `${this.apiUrl}get-kmeans-cluster-content/${zoom}/${this.gridSize}/`;\n\n        const clusterContent = await this.post(url, data);\n\n        return clusterContent;\n    }\n\n    async getDatasetContent(zoom: number, datasetId: number) {\n        const url = `${this.apiUrl}get-dataset-content/${zoom}/${this.gridSize}/${datasetId}/`;\n\n        const clusterContent = await this.get(url);\n\n        return clusterContent;\n    }\n\n    async getMapContentCount(zoom: number, data: MapContentCountRequestData) {\n        const url = `${this.apiUrl}get-map-content-count/${zoom}/${this.gridSize}/`;\n\n        const mapContentCount = await this.post(url, data)\n\n        return mapContentCount;\n    }\n\n    async getGroupedMapContents(zoom: number, data: GroupedMapContentRequestData) {\n        const url = `${this.apiUrl}get-grouped-map-contents/${zoom}/${this.gridSize}/`;\n\n        const groupedMapContents = await this.post(url, data);\n\n        return groupedMapContents;\n\n    }\n\n    viewportToGeoJSON(viewport: Viewport) {\n\n        const left = Math.max(viewport.left, this.maxBounds.minX);\n        const right = Math.min(viewport.right, this.maxBounds.maxX);\n        const top = Math.min(viewport.top, this.maxBounds.maxY);\n        const bottom = Math.max(viewport.bottom, this.maxBounds.minY);\n\n        const geometryType = \"Polygon\";\n\n        const coordinates = [[\n            [left, top],\n            [right, top],\n            [right, bottom],\n            [left, bottom],\n            [left, top]\n        ]];\n\n        const geoJSON = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": geometryType,\n                \"coordinates\": coordinates,\n                \"crs\": {\n                    \"type\": \"name\",\n                    \"properties\": {\n                        \"name\": this.srid\n                    }\n                }\n            }\n        };\n\n        return geoJSON;\n    }\n\n    async post(url: string, postData: object) {\n\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'POST',\n            body: JSON.stringify(postData),\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n\n    }\n\n    async get(url: string) {\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n    }\n}","\nimport { ClusterMethod, GeometryType, IconType, SRIDS, DefaultGridSizes, DefaultMarkerImageSizes } from \"./consts\";\nimport { GeoJSON, Marker, Cluster, Viewport } from \"./geometry\";\nimport {\n    Anycluster,\n    GetKmeansClusterContentRequestData,\n    ClusterRequestData,\n    MapContentCountRequestData,\n    GroupedMapContentRequestData,\n    Filter,\n    FilterList,\n    NestedFilter,\n    FilterOrNestedFilter,\n    FilterOrNestedFilterList,\n    Modulations\n} from \"./anycluster\";\n\n\nconst defaultGridFillColors = {\n    5: \"rgba(255, 192, 203, .5)\",\n    10: \"rgba(240, 128, 128, .5)\",\n    50: \"rgba(255, 127, 80, .5)\",\n    100: \"rgba(255, 165, 0, .5)\",\n    1000: \"rgba(255, 69, 0, .5)\",\n    10000: \"rgba(255, 0 , 0, .5)\"\n};\n\nconst defaultGridStrokeColors = {\n    5: \"pink\",\n    10: \"lightcoral\",\n    50: \"coral\",\n    100: \"orange\",\n    1000: \"orangered\",\n    10000: \"red\"\n};\n\nexport interface AnyclusterClientSettings {\n    srid?: SRIDS // srid of the map\n    kmeansGridSize?: number\n    gridGridSize?: number\n    clusterMethod?: ClusterMethod\n    geometryType?: GeometryType\n    area?: any\n    iconType?: IconType\n    onFinalClick?: Function\n    singlePinImages?: Record<string, string>\n    markerImageSizes?: Record<string, number[]>\n    gridFillColors?: Record<number, string>\n    gridStrokeColors?: Record<number, string>\n    onGotClusters?: () => void\n}\n\nexport class AnyclusterClient {\n\n    srid: SRIDS\n    kmeansGridSize: number\n    gridGridSize: number\n    clusterMethod: ClusterMethod\n    geometryType: GeometryType\n\n    area: GeoJSON | null\n    iconType: IconType\n\n    anycluster: Anycluster\n    markerList: any[]\n    onFinalClick: Function\n    singlePinImages?: Record<string, string>\n\n    markerImageSizes: Record<string, number[]>\n\n    gridFillColors: Record<number, string>\n    gridStrokeColors: Record<number, string>\n\n    filters: FilterOrNestedFilterList = []\n\n\n    constructor(public map: any, public apiUrl: string, public markerFolderPath: string, settings: AnyclusterClientSettings) {\n\n        this.map = map;\n        this.apiUrl = apiUrl;\n        this.markerFolderPath = markerFolderPath;\n\n        settings = settings || {};\n\n\n        // settings\n        this.srid = settings.srid ? settings.srid : SRIDS.EPSG4326;\n        this.kmeansGridSize = settings.gridGridSize ? settings.gridGridSize : DefaultGridSizes.kmeans;\n        this.gridGridSize = settings.gridGridSize ? settings.gridGridSize : DefaultGridSizes.grid;\n\n        this.clusterMethod = settings.clusterMethod ? settings.clusterMethod : ClusterMethod.kmeans;\n        this.geometryType = settings.geometryType ? settings.geometryType : GeometryType.viewport;\n\n        this.area = settings.area ? settings.area : null;\n        this.iconType = settings.iconType ? settings.iconType : IconType.rounded;\n\n        this.singlePinImages = settings.singlePinImages ? settings.singlePinImages : {};\n\n        this.markerImageSizes = settings.markerImageSizes ? settings.markerImageSizes : DefaultMarkerImageSizes;\n\n        this.gridFillColors = settings.gridFillColors ? settings.gridFillColors : defaultGridFillColors;\n        this.gridStrokeColors = settings.gridStrokeColors ? settings.gridStrokeColors : defaultGridStrokeColors;\n\n        // hooks\n        this.onGotClusters = settings.onGotClusters ? settings.onGotClusters : this._onGotClusters;\n        this.onFinalClick = settings.onFinalClick ? settings.onFinalClick : this._onFinalClick;\n\n\n        if (this.area) {\n            this.setArea(this.area);\n        }\n\n        const gridSize = this.getGridSize();\n        this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n\n        this.createClusterLayers();\n        this.markerList = [];\n\n        this.startClustering();\n    }\n\n    createClusterLayers(): void {\n        throw new Error(\"NotImplementedError: createClusterLayers\");\n    }\n\n    addArea(geojson: object): void {\n        throw new Error(\"NotImplementedError: addArea\");\n    }\n\n    removeArea(): void {\n        throw new Error(\"NotImplementedError: removeArea\");\n    }\n\n    removeAllMarkers(): void {\n        throw new Error(\"NotImplementedError: removeAllMarkers\");\n    }\n\n    getZoom(): number {\n        throw new Error(\"NotImplementedError: getZoom\");\n    }\n\n    setMap(x: number, y: number, zoom: number): void {\n        throw new Error(\"NotImplementedError: setMap\");\n    }\n\n    getViewport(): Viewport {\n        throw new Error(\"NotImplementedError: setMap\");\n    }\n\n    addMapEventListeners(): void {\n        throw new Error(\"NotImplementedError: addMapEventListeners\");\n    }\n\n    drawMarker(cluster: Cluster): void {\n        throw new Error(\"NotImplementedError: drawMarker\");\n    }\n\n    drawCell(cluster: Cluster): void {\n        throw new Error(\"NotImplementedError: drawCell\");\n    }\n\n    getAreaContent(geojson: GeoJSON): void {\n        throw new Error(\"NotImplementedError: getAreaContent\");\n    }\n\n\n    getGridSize(): number {\n        if (this.clusterMethod == ClusterMethod.grid) {\n            return this.gridGridSize;\n        }\n\n        return this.kmeansGridSize;\n    }\n\n    setClusterMethod(clusterMethod: ClusterMethod) {\n\n        if (clusterMethod == ClusterMethod.grid) {\n            this.area = null;\n            this.geometryType = GeometryType.viewport;\n            this.removeArea();\n        }\n\n        this.removeAllMarkers();\n        this.clusterMethod = clusterMethod;\n        const gridSize = this.getGridSize();\n        this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n        this.markerList = [];\n        this.getClusters(true);\n    }\n\n    setArea(geojson: GeoJSON) {\n\n        this.area = geojson;\n\n        this.removeArea();\n\n        if (geojson == null) {\n            this.geometryType = GeometryType.viewport;\n            this.setClusterMethod(ClusterMethod.kmeans);\n        }\n        else {\n\n            this.addArea(geojson);\n\n            this.geometryType = GeometryType.area;\n\n            this.setClusterMethod(ClusterMethod.kmeans);\n        }\n    }\n\n    getSinglePinImageURL(cluster: Cluster) {\n\n        const pinimg = cluster.pinimg;\n\n        let url = `${this.markerFolderPath}pin_unknown.png`;\n\n        if (this.singlePinImages && pinimg && pinimg in this.singlePinImages) {\n            url = this.singlePinImages[pinimg];\n        }\n\n        return url\n\n    }\n\n    selectPinIcon(cluster: Cluster) {\n\n        const count = cluster.count;\n\n        let markerImageUrl = this.getSinglePinImageURL(cluster);\n        let pinicon = \"1\";\n\n        if (count > 10000) {\n            pinicon = \"10000\";\n        }\n\n        else if (count > 1000) {\n            pinicon = \"1000\";\n        }\n\n        else if (count > 100) {\n            pinicon = \"100\";\n        }\n\n        else if (count > 50) {\n            pinicon = \"50\";\n        }\n\n        else if (count > 10) {\n            pinicon = \"10\";\n        }\n\n        else if (count > 1) {\n            pinicon = \"5\";\n        }\n\n        if (count > 1) {\n            if (this.iconType == IconType.exact) {\n                markerImageUrl = `${this.markerFolderPath}${pinicon}_empty.png`;\n            }\n            else {\n                markerImageUrl = `${this.markerFolderPath}${pinicon}.png`;\n            }\n        }\n\n        const size = this.markerImageSizes[pinicon];\n        let anchor = [Math.round(size[0] / 2), size[1] - 1];\n        let relativeAnchor = [0.5, 1];\n\n        if (count > 1) {\n            anchor = [Math.round((size[0] / 2)), Math.round(size[1] / 2)];\n            relativeAnchor = [0.5, 0.5];\n        }\n\n        const imgObj = {\n            url: markerImageUrl,\n            size: size,\n            anchor: anchor,\n            relativeAnchor: relativeAnchor,\n            popupAnchor: [0, -Math.round(size[1]) + 8]\n        }\n\n        return imgObj;\n\n    }\n\n    // marker can be an openlayers Feature or a L.marker\n    setMarkerProps(marker: any, cluster: Cluster) {\n\n        // add properties required by anycluster\n        marker.x = cluster.center.x;\n        marker.y = cluster.center.y;\n        marker.count = cluster.count;\n\n        if (cluster.hasOwnProperty(\"ids\")) {\n            marker.ids = cluster.ids;\n        }\n\n        if (cluster.hasOwnProperty(\"id\")) {\n            marker.id = cluster.id;\n        }\n\n        if (cluster.hasOwnProperty(\"geojson\")) {\n\n            /*const geojson = {\n                \"type\": \"Feature\",\n                \"count\": cluster.count,\n                \"geometry\": cluster.geojson,\n                \"properties\": {\n                    \"count\": cluster.count\n                },\n                \"crs\" : {\n                    \"type\" : \"name\",\n                    \"properties\" : {\n                        \"name\" : this.srid\n                    }\n                }\n            };*/\n\n            marker.geojson = cluster.geojson;\n        }\n\n        return marker;\n\n    }\n\n    markerClickFunction(x: number, y: number) {\n        this.removeAllMarkers();\n        let zoom = this.getZoom();\n        zoom = zoom + 3;\n        this.setMap(x, y, zoom);\n    }\n\n    async onMarkerFinalClick(marker: any) {\n\n        const zoom = this.getZoom();\n        const x = marker.x;\n        const y = marker.y;\n        const ids = marker.ids;\n\n        if (this.clusterMethod == ClusterMethod.kmeans) {\n\n            const postData = {\n                \"geometry_type\": this.geometryType,\n                \"input_srid\": this.srid,\n                \"x\": x,\n                \"y\": y,\n                \"ids\": ids,\n                \"filters\": this.filters\n            } as GetKmeansClusterContentRequestData;\n\n            const data = await this.anycluster.getKmeansClusterContent(zoom, postData);\n\n            this.onFinalClick(marker, data);\n\n        }\n        else if (this.clusterMethod = ClusterMethod.grid) {\n\n            if (marker.count == 1) {\n                const data = await this.anycluster.getDatasetContent(zoom, marker.id);\n                this.onFinalClick(marker, data);\n            }\n            else {\n                const geojson = marker[\"geojson\"];\n                const data = await this.getAreaContent(geojson);\n\n                this.onFinalClick(marker, data);\n            }\n\n        }\n    }\n\n    roundMarkerCount(count: number): number {\n\n        if (count == 1) {\n            count = 1;\n        }\n        else if (count <= 5) {\n            count = 5;\n        }\n        else if (count <= 10) {\n            count = 10;\n        }\n        else if (count <= 50) {\n            count = 50;\n        }\n        else if (count <= 100) {\n            count = 100;\n        }\n        else if (count <= 1000) {\n            count = 1000;\n        }\n        else {\n            count = 10000;\n        }\n\n        return count;\n    }\n\n    getClusterGeometry() {\n        let geoJSON;\n\n        if (this.geometryType == GeometryType.viewport) {\n            const viewport = this.getViewport();\n            geoJSON = this.anycluster.viewportToGeoJSON(viewport);\n        }\n        else if (this.geometryType == GeometryType.area && this.area) {\n            geoJSON = this.area;\n        }\n        else {\n            throw new Error('No cluster geometry found');\n        }\n\n        return geoJSON;\n\n    }\n\n    async getClusters(clearCache = false) {\n\n        const geoJSON = this.getClusterGeometry()\n\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": clearCache,\n            \"filters\": this.filters\n        } as ClusterRequestData;\n\n        const zoom = this.getZoom();\n\n        if (this.clusterMethod == ClusterMethod.kmeans) {\n\n\n            const clusters: Cluster[] = await this.anycluster.getKmeansCluster(zoom, postData);\n\n            if (clusters.length > 0) {\n                clusters.forEach(cluster => {\n                    this.drawMarker(cluster);\n                });\n            }\n        }\n        else if (this.clusterMethod == ClusterMethod.grid) {\n            const clusters: Cluster[] = await this.anycluster.getGridCluster(zoom, postData);\n\n            if (clusters.length > 0) {\n                clusters.forEach(cluster => {\n                    this.drawCell(cluster);\n                });\n            }\n        }\n        else {\n            throw new Error(`Invalid clusterMethod: ${this.clusterMethod}`);\n        }\n\n        this.onGotClusters();\n\n    }\n\n    startClustering() {\n        this.getClusters(true);\n        this.addMapEventListeners();\n    }\n\n    filtersAreEqual(filter1: FilterOrNestedFilter, filter2: FilterOrNestedFilter): boolean {\n        if ('column' in filter1 && 'column' in filter2) {\n            if (filter1.column == filter2.column && filter1.value == filter2.value && filter1.operator == filter2.operator) {\n                return true;\n            }\n        }\n        // testing with json.stringify is not ideal because {\"a\":1,\"b\":2} === {\"b\":2,\"a\":1} returns false\n        else if (JSON.stringify(filter1) === JSON.stringify(filter2)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    // filtering\n    filter(filter: Filter | NestedFilter | FilterOrNestedFilter[], reloadMarkers?: boolean) {\n\n        if (Array.isArray(filter)) {\n            this.filters = filter;\n        }\n        else {\n            this.filters = [filter];\n        }\n        this.postFilterChange(reloadMarkers);\n    }\n\n    addFilter(filter: Filter, reloadMarkers?: boolean) {\n\n        let filterExists = false;\n\n        for (let f = 0; f < this.filters.length; f++) {\n            let existingFilter: FilterOrNestedFilter = this.filters[f];\n\n            if (this.filtersAreEqual(filter, existingFilter)) {\n                filterExists = true;\n                break;\n            }\n\n        }\n\n        if (!filterExists) {\n            this.filters.push(filter);\n        }\n\n        this.postFilterChange(reloadMarkers);\n    }\n\n    addFilters(filtersToAdd: FilterList, reloadMarkers?: boolean) {\n\n        for (let fa = 0; fa < filtersToAdd.length; fa++) {\n            let filter = filtersToAdd[fa];\n            this.addFilter(filter, false);\n        }\n        this.postFilterChange(reloadMarkers);\n    }\n\n    removeFilter(filter: Filter, reloadMarkers?: boolean) {\n\n        for (let f = 0; f < this.filters.length; f++) {\n            let existingFilter: FilterOrNestedFilter = this.filters[f];\n\n            if (this.filtersAreEqual(filter, existingFilter)) {\n                this.filters.splice(f, 1);\n                break;\n            }\n        }\n        this.postFilterChange(reloadMarkers);\n    }\n\n    removeFilters(filtersToRemove: FilterList, reloadMarkers?: boolean) {\n\n        for (let fr = 0; fr < filtersToRemove.length; fr++) {\n\n            let filter = filtersToRemove[fr];\n\n            this.removeFilter(filter, false);\n        }\n\n        this.postFilterChange(reloadMarkers);\n    }\n\n    resetFilters(reloadMarkers?: boolean) {\n        this.filters = [];\n        this.postFilterChange(reloadMarkers);\n    }\n\n    postFilterChange(reloadMarkers?: boolean) {\n        if (reloadMarkers != false) {\n            reloadMarkers = true;\n        }\n        if (reloadMarkers == true) {\n            this.removeAllMarkers();\n            this.getClusters(true);\n        }\n    }\n\n    /**\n     * methods for getting counts of objects on the current map / geometry\n     */\n\n    async getMapContentCount(modulations?: Modulations) {\n\n        const geoJSON = this.getClusterGeometry()\n\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": true,\n            \"filters\": this.filters,\n            \"modulations\": modulations,\n        } as MapContentCountRequestData;\n\n        const zoom = this.getZoom();\n\n        const data = await this.anycluster.getMapContentCount(zoom, postData);\n\n        return data;\n    }\n\n    async getGroupedMapContents(groupBy: string) {\n\n        const geoJSON = this.getClusterGeometry()\n\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": true,\n            \"filters\": this.filters,\n            \"group_by\": groupBy,\n        } as GroupedMapContentRequestData;\n\n        const zoom = this.getZoom();\n\n        const data = await this.anycluster.getGroupedMapContents(zoom, postData);\n\n        return data;\n\n    }\n\n    // hooks\n    _onFinalClick(marker: Marker, data: any) {\n        alert(JSON.stringify(data));\n    }\n    \n    _onGotClusters() {}\n\n}"],"names":["$d23ecb6e11364e2e$export$55fee9ea2526ad0d","SRIDS","$d23ecb6e11364e2e$export$ae91e066970d978a","ClusterMethod","$d23ecb6e11364e2e$export$8f4397a63c3cef66","GeometryType","$d23ecb6e11364e2e$export$13ff1290a9e22e77","IconType","$d23ecb6e11364e2e$export$9c3a9f8fbf06a34","DefaultGridSizes","$d23ecb6e11364e2e$export$96b1907ff7fa3578","$d23ecb6e11364e2e$export$7fa100a28fbb5fe2","Operators","$d23ecb6e11364e2e$export$9a28c02ac0f6fc9d","LogicalOperators","$a84c901b6d8dcdc7$export$2104d4dd9d4984b2","Object","freeze","minX","maxX","minY","maxY","$a84c901b6d8dcdc7$export$6db2f048e15a981e","$a84c901b6d8dcdc7$export$5e01b9ff483562af","constructor","apiUrl","gridSize","srid","this","EPSG4326","maxBounds","EPSG3857","Error","async","zoom","data","url","post","datasetId","get","viewportToGeoJSON","viewport","left","Math","max","right","min","top","bottom","type","geometry","coordinates","crs","properties","name","postData","encodedUrl","encodeURI","options","method","body","JSON","stringify","headers","mode","credentials","response","fetch","responseData","json","ok","$873ecc376aa9f94e$var$defaultGridFillColors","$873ecc376aa9f94e$var$defaultGridStrokeColors","$873ecc376aa9f94e$export$a09c19a7c4419c1","map","markerFolderPath","settings","filters","kmeansGridSize","gridGridSize","kmeans","grid","clusterMethod","geometryType","area","iconType","rounded","singlePinImages","markerImageSizes","gridFillColors","gridStrokeColors","onGotClusters","_onGotClusters","onFinalClick","_onFinalClick","setArea","getGridSize","anycluster","createClusterLayers","markerList","startClustering","addArea","geojson","removeArea","removeAllMarkers","getZoom","setMap","x","y","getViewport","addMapEventListeners","drawMarker","cluster","drawCell","getAreaContent","setClusterMethod","getClusters","getSinglePinImageURL","pinimg","selectPinIcon","count","markerImageUrl","pinicon","exact","size","anchor","round","relativeAnchor","popupAnchor","setMarkerProps","marker","center","hasOwnProperty","ids","id","markerClickFunction","geometry_type","input_srid","getKmeansClusterContent","getDatasetContent","roundMarkerCount","getClusterGeometry","geoJSON","clearCache","output_srid","clear_cache","clusters","getKmeansCluster","length","forEach","getGridCluster","filtersAreEqual","filter1","filter2","column","value","operator","filter","reloadMarkers","Array","isArray","postFilterChange","addFilter","filterExists","f","existingFilter","push","addFilters","filtersToAdd","fa","removeFilter","splice","removeFilters","filtersToRemove","fr","resetFilters","modulations","getMapContentCount","groupBy","group_by","getGroupedMapContents","alert"],"version":3,"file":"main.js.map"}