{"mappings":"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","sources":["src/index.ts","src/consts.ts","src/anycluster.ts","src/anycluster-client.ts"],"sourcesContent":["export {\n    ClusterMethod,\n    GeometryType,\n    IconType,\n    SRIDS,\n    Operators,\n    LogicalOperators,\n} from \"./consts\";\n\nexport { \n    Anycluster,\n    Bounds3857,\n    Bounds4326,\n} from \"./anycluster\";\n\nexport type {\n    Filter,\n    GetKmeansClusterContentRequestData,\n    ClusterRequestData,\n    MapContentCountRequestData,\n    GroupedMapContentRequestData,\n    AreaContentRequestData,\n    FilterList,\n    NestedFilter,\n    FilterOrNestedFilter,\n    FilterOrNestedFilterList,\n    Modulations,\n} from \"./anycluster\";\n\nexport {\n    AnyclusterClient,\n} from \"./anycluster-client\";\n\nexport type {\n    AnyclusterClientSettings\n} from \"./anycluster-client\";\n\nexport type {\n    GeoJSON,\n    Marker,\n    Viewport,\n} from \"./geometry\";\n\nexport type {\n    KmeansCluster,\n    KmeansClusterResponse,\n    GridCluster,\n} from \"./types\";","\nexport interface MaxBounds {\n    minX: number,\n    maxX: number,\n    minY: number,\n    maxY: number\n}\n\nexport enum SRIDS {\n    EPSG4326 = 'EPSG:4326',\n    EPSG3857 = 'EPSG:3857'\n}\n\nexport enum ClusterMethod {\n    kmeans = 'kmeans',\n    grid = 'grid'\n}\n\n\nexport enum GeometryType {\n    viewport = 'viewport',\n    area = 'area'\n}\n\nexport enum IconType {\n    exact = 'exact',\n    rounded = 'rounded'\n}\n\nexport enum DefaultGridSizes {\n    grid = 64,\n    kmeans = 150\n}\n\nexport const DefaultMarkerImageSizes = {\n    1: [24, 39],\n    5: [30, 30],\n    10: [30, 30],\n    50: [40, 40],\n    100: [40, 40],\n    1000: [50, 50],\n    10000: [60, 60]\n}\n\nexport enum Operators {\n    in = 'in',\n    notIn = 'not in',\n    equals = '=',\n    unEquals = '!=',\n    largerThan = '>=',\n    smallerThan = '<=',\n    startswith = 'startswith',\n    contains = 'contains',\n}\n\nexport enum LogicalOperators {\n    AND = 'AND',\n    OR = 'OR',\n}\n\nexport const DefaultMaxZoom = 13;","import { SRIDS, MaxBounds, ClusterMethod, GeometryType, Operators, LogicalOperators } from \"./consts\";\nimport { Point, GeoJSON, Coordinates, Viewport } from \"./geometry\";\nimport type { KmeansClusterResponse } from \"./types\";\n\nexport const Bounds4326: MaxBounds = Object.freeze({\n    minX: -179,\n    maxX: 179,\n    minY: -89,\n    maxY: 89\n});\n\n\nexport const Bounds3857: MaxBounds = Object.freeze({\n    minX: -20037500, //-20037508.34\n    maxX: 20037500, // 20037508.34\n    minY: -20048960, // -20048966.1\n    maxY: 20048960 //  20048966.1\n});\n\nexport interface Filter {\n    column: string\n    value: string | number | boolean\n    operator: Operators\n    logicalOperator?: LogicalOperators\n}\n\nexport interface NestedFilter {\n    filters : Filter[]\n    logicalOperator?: LogicalOperators\n}\n\nexport type FilterOrNestedFilter = Filter | NestedFilter;\n\nexport interface ClusterRequestData {\n    output_srid: SRIDS\n    geometry_type: GeometryType\n    geojson: GeoJSON\n    clear_cache: boolean\n    filters: FilterOrNestedFilter[]\n}\n\nexport type FilterList = Filter[];\n\nexport type FilterOrNestedFilterList = FilterOrNestedFilter[];\n\nexport interface GetKmeansClusterContentRequestData {\n    geometry_type: GeometryType\n    geojson?: GeoJSON\n    input_srid: SRIDS\n    x: number\n    y: number\n    ids: number[]\n}\n\nexport interface Modulations {\n    [name:string] : FilterOrNestedFilter | FilterOrNestedFilterList\n}\n\nexport interface MapContentCountRequestData extends ClusterRequestData {\n    modulations?: Modulations\n}\n\nexport interface AreaContentRequestData extends ClusterRequestData {\n    limit?: number\n    offset?: number\n    order_by?: string\n}\n\nexport interface GroupedMapContentRequestData extends ClusterRequestData {\n    group_by: string\n}\n\nexport class Anycluster {\n\n    maxBounds: MaxBounds\n\n    constructor(private apiUrl: string, public gridSize: number, public srid: SRIDS) {\n\n        if (this.srid == SRIDS.EPSG4326) {\n            this.maxBounds = Bounds4326;\n        }\n        else if (this.srid == SRIDS.EPSG3857) {\n            this.maxBounds = Bounds3857;\n        }\n        else {\n            throw new Error(`invalid srid given: ${this.srid} `);\n        }\n\n    }\n\n    validateZoom(zoom: number) {\n        if (!Number.isInteger(zoom)) {\n            throw new Error(`[anycluster] non-integer zoom: ${zoom}`);\n        }\n    }\n\n    async getGridCluster(zoom: number, data: ClusterRequestData) {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}grid/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters;\n    }\n\n    async getKmeansCluster(zoom: number, data: ClusterRequestData): Promise<KmeansClusterResponse> {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}kmeans/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters;\n    }\n\n    async getKmeansClusterContent(zoom: number, data: GetKmeansClusterContentRequestData) {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}get-kmeans-cluster-content/${zoom}/${this.gridSize}/`;\n\n        const clusterContent = await this.post(url, data);\n\n        return clusterContent;\n    }\n\n    async getDatasetContent(zoom: number, datasetId: number) {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}get-dataset-content/${zoom}/${this.gridSize}/${datasetId}/`;\n\n        const clusterContent = await this.get(url);\n\n        return clusterContent;\n    }\n\n    async getMapContentCount(zoom: number, data: MapContentCountRequestData) {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}get-map-content-count/${zoom}/${this.gridSize}/`;\n\n        const mapContentCount = await this.post(url, data)\n\n        return mapContentCount;\n    }\n\n    async getGroupedMapContents(zoom: number, data: GroupedMapContentRequestData) {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}get-grouped-map-contents/${zoom}/${this.gridSize}/`;\n\n        const groupedMapContents = await this.post(url, data);\n\n        return groupedMapContents;\n\n    }\n\n    async getAreaContent(zoom:number, data: AreaContentRequestData) {\n\n        this.validateZoom(zoom);\n\n        const url = `${this.apiUrl}get-area-content/${zoom}/${this.gridSize}/`;\n\n        const areaContent = await this.post(url, data);\n\n        return areaContent;\n    }\n\n    viewportToGeoJSON(viewport: Viewport) {\n\n        const left = Math.max(viewport.left, this.maxBounds.minX);\n        const right = Math.min(viewport.right, this.maxBounds.maxX);\n        const top = Math.min(viewport.top, this.maxBounds.maxY);\n        const bottom = Math.max(viewport.bottom, this.maxBounds.minY);\n\n        const geometryType = \"Polygon\";\n\n        const coordinates = [[\n            [left, top],\n            [right, top],\n            [right, bottom],\n            [left, bottom],\n            [left, top]\n        ]];\n\n        const geoJSON = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": geometryType,\n                \"coordinates\": coordinates,\n                \"crs\": {\n                    \"type\": \"name\",\n                    \"properties\": {\n                        \"name\": this.srid\n                    }\n                }\n            }\n        };\n\n        return geoJSON;\n    }\n\n    async post(url: string, postData: object) {\n\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'POST',\n            body: JSON.stringify(postData),\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n\n    }\n\n    async get(url: string) {\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n    }\n}","\nimport { ClusterMethod, GeometryType, IconType, SRIDS, DefaultGridSizes, DefaultMarkerImageSizes, DefaultMaxZoom } from \"./consts\";\nimport type { GeoJSON, Marker, Viewport } from \"./geometry\";\nimport type { GridCluster, KmeansCluster } from \"./types\";\nimport {\n  Anycluster,\n  GetKmeansClusterContentRequestData,\n  ClusterRequestData,\n  MapContentCountRequestData,\n  GroupedMapContentRequestData,\n  AreaContentRequestData,\n  Filter,\n  FilterList,\n  NestedFilter,\n  FilterOrNestedFilter,\n  FilterOrNestedFilterList,\n  Modulations,\n} from \"./anycluster\";\n\nconst defaultGridFillColors = {\n  5: \"rgba(255, 192, 203, .5)\",\n  10: \"rgba(240, 128, 128, .5)\",\n  50: \"rgba(255, 127, 80, .5)\",\n  100: \"rgba(255, 165, 0, .5)\",\n  1000: \"rgba(255, 69, 0, .5)\",\n  10000: \"rgba(255, 0 , 0, .5)\",\n};\n\nconst defaultGridStrokeColors = {\n  5: \"pink\",\n  10: \"lightcoral\",\n  50: \"coral\",\n  100: \"orange\",\n  1000: \"orangered\",\n  10000: \"red\",\n};\n\nexport interface AnyclusterClientSettings {\n  srid?: SRIDS // srid of the map\n  kmeansGridSize?: number\n  gridGridSize?: number\n  clusterMethod?: ClusterMethod\n  geometryType?: GeometryType\n  area?: any\n  iconType?: IconType\n  maxZoom?: number,\n  onFinalClick?: Function\n  singlePinImages?: Record<string, string>\n  getSinglePinImageURL?: Function\n  markerImageSizes?: Record<string, number[]>\n  gridFillColors?: Record<number, string>\n  gridStrokeColors?: Record<number, string>\n  onGotClusters?: () => void\n  startClustering?: boolean\n}\n\nexport class AnyclusterClient {\n\n  srid: SRIDS\n  kmeansGridSize: number\n  gridGridSize: number\n  clusterMethod: ClusterMethod\n  geometryType: GeometryType\n\n  area: GeoJSON | null\n  iconType: IconType\n\n  anycluster: Anycluster\n  markerList: any[]\n  maxZoom: number\n  onFinalClick: Function\n  onGotClusters: Function\n  singlePinImages?: Record<string, string>\n  getSinglePinImageURL: Function\n\n  markerImageSizes: Record<string, number[]>\n\n  gridFillColors: Record<number, string>\n  gridStrokeColors: Record<number, string>\n\n  filters: FilterOrNestedFilterList = []\n\n  isStartup: boolean = false // openlayers fires moveend after loadend. This triggers two clustering requests of which the latter has to be dismissed\n  latestFilterChangeTimestamp: number | null = null\n\n  constructor(public map: any, public apiUrl: string, public markerFolderPath: string, settings: AnyclusterClientSettings) {\n\n    this.map = map;\n    this.apiUrl = apiUrl;\n    this.markerFolderPath = markerFolderPath;\n\n    settings = settings || {};\n\n\n    // settings\n    this.srid = settings.srid ? settings.srid : SRIDS.EPSG4326;\n    this.kmeansGridSize = settings.gridGridSize ? settings.gridGridSize : DefaultGridSizes.kmeans;\n    this.gridGridSize = settings.gridGridSize ? settings.gridGridSize : DefaultGridSizes.grid;\n\n    this.clusterMethod = settings.clusterMethod ? settings.clusterMethod : ClusterMethod.kmeans;\n    this.geometryType = settings.geometryType ? settings.geometryType : GeometryType.viewport;\n\n    this.area = settings.area ? settings.area : null;\n    this.iconType = settings.iconType ? settings.iconType : IconType.rounded;\n\n    this.singlePinImages = settings.singlePinImages ? settings.singlePinImages : {};\n    this.getSinglePinImageURL = settings.getSinglePinImageURL ? settings.getSinglePinImageURL : this._getSinglePinImageURL;\n\n    this.markerImageSizes = settings.markerImageSizes ? settings.markerImageSizes : DefaultMarkerImageSizes;\n\n    this.gridFillColors = settings.gridFillColors ? settings.gridFillColors : defaultGridFillColors;\n    this.gridStrokeColors = settings.gridStrokeColors ? settings.gridStrokeColors : defaultGridStrokeColors;\n\n    this.maxZoom = settings.maxZoom ? settings.maxZoom : DefaultMaxZoom;\n    // hooks\n    this.onGotClusters = settings.onGotClusters ? settings.onGotClusters : this._onGotClusters;\n    this.onFinalClick = settings.onFinalClick ? settings.onFinalClick : this._onFinalClick;\n\n\n    if (this.area) {\n      this.setArea(this.area);\n    }\n\n    const gridSize = this.getGridSize();\n    this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n\n    this.createClusterLayers();\n    this.markerList = [];\n\n    const startClustering = settings.startClustering === false ? settings.startClustering : true;\n\n    if (startClustering === true) {\n      this.startClustering();\n    }\n  }\n\n  createClusterLayers(): void {\n    throw new Error(\"NotImplementedError: createClusterLayers\");\n  }\n\n  addArea(geojson: object): void {\n    throw new Error(\"NotImplementedError: addArea\");\n  }\n\n  removeArea(): void {\n    throw new Error(\"NotImplementedError: removeArea\");\n  }\n\n  removeAllMarkers(): void {\n    throw new Error(\"NotImplementedError: removeAllMarkers\");\n  }\n\n  getZoom(): number {\n    throw new Error(\"NotImplementedError: getZoom\");\n  }\n\n  setMap(x: number, y: number, zoom: number): void {\n    throw new Error(\"NotImplementedError: setMap\");\n  }\n\n  getViewport(): Viewport {\n    throw new Error(\"NotImplementedError: setMap\");\n  }\n\n  addMapEventListeners(): void {\n    throw new Error(\"NotImplementedError: addMapEventListeners\");\n  }\n\n  drawKmeansMarker(cluster: KmeansCluster): void {\n    throw new Error(\"NotImplementedError: drawKmeansMarker\");\n  }\n\n  drawCell(cluster: GridCluster): void {\n    throw new Error(\"NotImplementedError: drawCell\");\n  }\n\n  drawGridMarker(cluster: GridCluster): void {\n    throw new Error(\"NotImplementedError: drawGridMarker\");\n  }\n\n  getGridSize(): number {\n    if (this.clusterMethod == ClusterMethod.grid) {\n      return this.gridGridSize;\n    }\n\n    return this.kmeansGridSize;\n  }\n\n  setClusterMethod(clusterMethod: ClusterMethod) {\n\n    if (clusterMethod == ClusterMethod.grid) {\n      this.area = null;\n      this.geometryType = GeometryType.viewport;\n      this.removeArea();\n    }\n\n    this.removeAllMarkers();\n    this.clusterMethod = clusterMethod;\n    const gridSize = this.getGridSize();\n    this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n    this.markerList = [];\n    this.getClusters(true);\n  }\n\n  setArea(geojson: GeoJSON) {\n\n    this.area = geojson;\n\n    this.removeArea();\n\n    if (geojson == null) {\n      this.geometryType = GeometryType.viewport;\n      this.setClusterMethod(ClusterMethod.kmeans);\n    }\n    else {\n\n      this.addArea(geojson);\n\n      this.geometryType = GeometryType.area;\n\n      this.setClusterMethod(ClusterMethod.kmeans);\n    }\n  }\n\n  _getSinglePinImageURL(cluster: KmeansCluster | GridCluster) {\n\n    const pinimg = cluster.pinimg;\n\n    let url = `${this.markerFolderPath}pin_unknown.png`;\n\n    if (this.singlePinImages && pinimg && pinimg in this.singlePinImages) {\n      url = this.singlePinImages[pinimg];\n    }\n\n    return url\n\n  }\n\n  selectPinIcon(cluster: KmeansCluster | GridCluster) {\n\n    const count = cluster.count;\n\n    let markerImageUrl = this.getSinglePinImageURL(cluster);\n    let pinicon = \"1\";\n\n    if (count > 10000) {\n      pinicon = \"10000\";\n    }\n\n    else if (count > 1000) {\n      pinicon = \"1000\";\n    }\n\n    else if (count > 100) {\n      pinicon = \"100\";\n    }\n\n    else if (count > 50) {\n      pinicon = \"50\";\n    }\n\n    else if (count > 10) {\n      pinicon = \"10\";\n    }\n\n    else if (count > 1) {\n      pinicon = \"5\";\n    }\n\n    if (count > 1) {\n      if (this.iconType == IconType.exact) {\n        markerImageUrl = `${this.markerFolderPath}${pinicon}_empty.png`;\n      }\n      else {\n        markerImageUrl = `${this.markerFolderPath}${pinicon}.png`;\n      }\n    }\n\n    const size = this.markerImageSizes[pinicon];\n    let anchor = [Math.round(size[0] / 2), size[1] - 1];\n    let relativeAnchor = [0.5, 1];\n\n    if (count > 1) {\n      anchor = [Math.round((size[0] / 2)), Math.round(size[1] / 2)];\n      relativeAnchor = [0.5, 0.5];\n    }\n\n    const imgObj = {\n      url: markerImageUrl,\n      size: size,\n      anchor: anchor,\n      relativeAnchor: relativeAnchor,\n      popupAnchor: [0, -Math.round(size[1]) + 8]\n    }\n\n    return imgObj;\n\n  }\n\n  // marker can be an openlayers Feature or a L.marker\n  setMarkerProps(marker: any, cluster: KmeansCluster) {\n\n    // add properties required by anycluster\n    marker.x = cluster.center.x;\n    marker.y = cluster.center.y;\n    marker.count = cluster.count;\n    marker.ids = cluster.ids;\n\n    return marker;\n\n  }\n\n  setCellProps(cell: any, cluster: GridCluster) {\n    cell.x = cluster.center.x;\n    cell.y = cluster.center.y;\n    cell.count = cluster.count;\n    cell.id = cluster.id;\n    cell.geojson = cluster.geojson;\n\n    return cell;\n  }\n\n  markerClickFunction(x: number, y: number) {\n    this.removeAllMarkers();\n    let zoom = this.getZoom();\n    zoom = zoom + 3;\n    this.setMap(x, y, zoom);\n  }\n\n  async onMarkerFinalClick(marker: any) {\n\n    const zoom = this.getZoom();\n    const x = marker.x;\n    const y = marker.y;\n\n    const geoJSON = this.getClusterGeometry();\n\n    if (this.clusterMethod == ClusterMethod.kmeans) {\n\n      const ids = marker.ids;\n      \n      const postData = {\n        \"geometry_type\": this.geometryType,\n        \"geojson\": geoJSON,\n        \"input_srid\": this.srid,\n        \"x\": x,\n        \"y\": y,\n        \"ids\": ids,\n        \"filters\": this.filters\n      } as GetKmeansClusterContentRequestData;\n\n      const data = await this.anycluster.getKmeansClusterContent(zoom, postData);\n\n      this.onFinalClick(marker, data);\n\n    }\n    else if (this.clusterMethod = ClusterMethod.grid) {\n\n      if (marker.count == 1) {\n        const data = await this.anycluster.getDatasetContent(zoom, marker.id);\n        this.onFinalClick(marker, data);\n      }\n      else {\n        const geojson = marker[\"geojson\"];\n        const zoom = this.getZoom();\n        const data = await this.anycluster.getAreaContent(zoom, geojson);\n\n        this.onFinalClick(marker, data);\n      }\n\n    }\n  }\n\n  roundMarkerCount(count: number): number {\n\n    if (count == 1) {\n      count = 1;\n    }\n    else if (count <= 5) {\n      count = 5;\n    }\n    else if (count <= 10) {\n      count = 10;\n    }\n    else if (count <= 50) {\n      count = 50;\n    }\n    else if (count <= 100) {\n      count = 100;\n    }\n    else if (count <= 1000) {\n      count = 1000;\n    }\n    else {\n      count = 10000;\n    }\n\n    return count;\n  }\n\n  getClusterGeometry() {\n    let geoJSON;\n\n    if (this.geometryType == GeometryType.viewport) {\n      const viewport = this.getViewport();\n      geoJSON = this.anycluster.viewportToGeoJSON(viewport);\n    }\n    else if (this.geometryType == GeometryType.area && this.area) {\n      geoJSON = this.area;\n    }\n    else {\n      throw new Error('No cluster geometry found');\n    }\n\n    return geoJSON;\n\n  }\n\n  async getClusters(clearCache = false) {\n\n    const geoJSON = this.getClusterGeometry();\n\n    const postData = {\n      \"output_srid\": this.srid,\n      \"geometry_type\": this.geometryType,\n      \"geojson\": geoJSON,\n      \"clear_cache\": clearCache,\n      \"filters\": this.filters\n    } as ClusterRequestData;\n\n    const zoom = this.getZoom();\n    const filterTimestamp = this.latestFilterChangeTimestamp;\n\n    if (this.clusterMethod == ClusterMethod.kmeans) {\n      const clusters: KmeansCluster[] = await this.anycluster.getKmeansCluster(zoom, postData);\n      const postResponseZoom = this.getZoom();\n      // only draw markers/cells if the user did not zoom or change filters during the wait for the response\n      if (clusters.length > 0 && filterTimestamp === this.latestFilterChangeTimestamp && zoom === postResponseZoom) {\n        clusters.forEach(cluster => {\n          this.drawKmeansMarker(cluster);\n        });\n\n        this.onGotClusters();\n      } else {\n        console.log(`[anycluster]: not drawing markers because of outdated response`);\n      }\n\n    } else if (this.clusterMethod == ClusterMethod.grid ) {\n      const clusters: GridCluster[] = await this.anycluster.getGridCluster(zoom, postData);\n      const postResponseZoom = this.getZoom();\n\n      // only draw markers/cells if the user did not zoom or change filters during the wait for the response\n      if (clusters.length > 0 && filterTimestamp === this.latestFilterChangeTimestamp && zoom === postResponseZoom) {\n        clusters.forEach(cluster => {\n            this.drawCell(cluster);\n        });\n\n        this.onGotClusters();\n      } else {\n        console.log(`[anycluster]: not drawing markers because of outdated response`);\n      }\n    } else {\n      throw new Error(`Invalid clusterMethod: ${this.clusterMethod}`);\n    }\n  }\n\n  async startClustering() {\n    this.isStartup = true;\n    await this.getClusters(true);\n    this.addMapEventListeners();\n    this.isStartup = false;\n  }\n\n  filtersAreEqual(filter1: FilterOrNestedFilter, filter2: FilterOrNestedFilter): boolean {\n    if ('column' in filter1 && 'column' in filter2) {\n      if (filter1.column == filter2.column && filter1.value == filter2.value && filter1.operator == filter2.operator) {\n        return true;\n      }\n    }\n    // testing with json.stringify is not ideal because {\"a\":1,\"b\":2} === {\"b\":2,\"a\":1} returns false\n    else if (JSON.stringify(filter1) === JSON.stringify(filter2)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // filtering\n  filter(filter: Filter | NestedFilter | FilterOrNestedFilter[], reloadMarkers?: boolean) {\n\n    if (Array.isArray(filter)) {\n      this.filters = filter;\n    }\n    else {\n      this.filters = [filter];\n    }\n    this.postFilterChange(reloadMarkers);\n  }\n\n  addFilter(filter: Filter, reloadMarkers?: boolean) {\n\n    let filterExists = false;\n\n    for (let f = 0; f < this.filters.length; f++) {\n      let existingFilter: FilterOrNestedFilter = this.filters[f];\n\n      if (this.filtersAreEqual(filter, existingFilter)) {\n        filterExists = true;\n        break;\n      }\n\n    }\n\n    if (!filterExists) {\n      this.filters.push(filter);\n    }\n\n    this.postFilterChange(reloadMarkers);\n  }\n\n  addFilters(filtersToAdd: FilterList, reloadMarkers?: boolean) {\n\n    for (let fa = 0; fa < filtersToAdd.length; fa++) {\n      let filter = filtersToAdd[fa];\n      this.addFilter(filter, false);\n    }\n    this.postFilterChange(reloadMarkers);\n  }\n\n  removeFilter(filter: Filter, reloadMarkers?: boolean) {\n\n    for (let f = 0; f < this.filters.length; f++) {\n      let existingFilter: FilterOrNestedFilter = this.filters[f];\n\n      if (this.filtersAreEqual(filter, existingFilter)) {\n        this.filters.splice(f, 1);\n        break;\n      }\n    }\n    this.postFilterChange(reloadMarkers);\n  }\n\n  removeFilters(filtersToRemove: FilterList, reloadMarkers?: boolean) {\n\n    for (let fr = 0; fr < filtersToRemove.length; fr++) {\n\n      let filter = filtersToRemove[fr];\n\n      this.removeFilter(filter, false);\n    }\n\n    this.postFilterChange(reloadMarkers);\n  }\n\n  resetFilters(reloadMarkers?: boolean) {\n    this.filters = [];\n    this.postFilterChange(reloadMarkers);\n  }\n\n  postFilterChange(reloadMarkers?: boolean) {\n\n    this.latestFilterChangeTimestamp = new Date().getTime();\n\n    if (reloadMarkers != false) {\n      reloadMarkers = true;\n    }\n    if (reloadMarkers == true) {\n      this.removeAllMarkers();\n      this.getClusters(true);\n    }\n  }\n\n\n  /**\n   * method for getting the unaggregated, paginated content of the map\n   */\n  async getMapContents(limit?: number, offset?: number, orderBy?: string) {\n    const geoJSON = this.getClusterGeometry();\n    const zoom = this.getZoom();\n\n    const postData = {\n      \"output_srid\": this.srid,\n      \"geometry_type\": GeometryType.area,\n      \"geojson\": geoJSON,\n      \"clear_cache\": false,\n      \"filters\": this.filters,\n      \"limit\": limit,\n      \"offset\": offset,\n      \"order_by\": orderBy,\n    } as AreaContentRequestData;\n\n    const data = this.anycluster.getAreaContent(zoom, postData);\n\n    return data;\n  }\n\n  /**\n   * methods for getting counts of objects on the current map / geometry\n   */\n\n  async getMapContentCount(modulations?: Modulations) {\n\n    const geoJSON = this.getClusterGeometry()\n\n    const postData = {\n      \"output_srid\": this.srid,\n      \"geometry_type\": this.geometryType,\n      \"geojson\": geoJSON,\n      \"clear_cache\": true,\n      \"filters\": this.filters,\n      \"modulations\": modulations,\n    } as MapContentCountRequestData;\n\n    const zoom = this.getZoom();\n\n    const data = await this.anycluster.getMapContentCount(zoom, postData);\n\n    return data;\n  }\n\n  async getFilteredMapContentCount(filters?: FilterOrNestedFilterList, modulations?: Modulations) {\n    const geoJSON = this.getClusterGeometry()\n\n    const postData = {\n      \"output_srid\": this.srid,\n      \"geometry_type\": this.geometryType,\n      \"geojson\": geoJSON,\n      \"clear_cache\": true,\n      \"filters\": filters,\n      \"modulations\": modulations,\n    } as MapContentCountRequestData;\n\n    const zoom = this.getZoom();\n\n    const data = await this.anycluster.getMapContentCount(zoom, postData);\n\n    return data;\n  }\n\n  async getGroupedMapContents(groupBy: string) {\n    const geoJSON = this.getClusterGeometry()\n\n    const postData = {\n      \"output_srid\": this.srid,\n      \"geometry_type\": this.geometryType,\n      \"geojson\": geoJSON,\n      \"clear_cache\": true,\n      \"filters\": this.filters,\n      \"group_by\": groupBy,\n    } as GroupedMapContentRequestData;\n\n    const zoom = this.getZoom();\n\n    const data = await this.anycluster.getGroupedMapContents(zoom, postData);\n\n    return data;\n\n  }\n\n  async getFilteredGroupedMapContents(filters: FilterOrNestedFilterList, groupBy: string) {\n    const geoJSON = this.getClusterGeometry()\n\n    const postData = {\n      \"output_srid\": this.srid,\n      \"geometry_type\": this.geometryType,\n      \"geojson\": geoJSON,\n      \"clear_cache\": true,\n      \"filters\": filters,\n      \"group_by\": groupBy,\n    } as GroupedMapContentRequestData;\n\n    const zoom = this.getZoom();\n\n    const data = await this.anycluster.getGroupedMapContents(zoom, postData);\n\n    return data;\n  }\n\n  // hooks\n  _onFinalClick(marker: Marker, data: any) {\n    alert(JSON.stringify(data));\n  }\n\n  _onGotClusters() { }\n\n}"],"names":[],"version":3,"file":"anycluster.js.map"}