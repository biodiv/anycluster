{"mappings":"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","sources":["src/index.ts","src/consts.ts","src/anycluster.ts","src/anycluster-client.ts"],"sourcesContent":["export {\n    ClusterMethod,\n    GeometryType,\n    IconType,\n    SRIDS\n} from \"./consts\";\n\nexport { \n    Anycluster\n} from \"./anycluster\";\n\nexport {\n    AnyclusterClient\n} from \"./anycluster-client\";","\nexport interface MaxBounds {\n    minX: number,\n    maxX: number,\n    minY: number,\n    maxY: number\n}\n\nexport enum SRIDS {\n    EPSG4326 = 'EPSG:4326',\n    EPSG3857 = 'EPSG:3857'\n}\n\nexport enum ClusterMethod {\n    kmeans = 'kmeans',\n    grid = 'grid'\n}\n\n\nexport enum GeometryType {\n    viewport = 'viewport',\n    area = 'area'\n}\n\nexport enum IconType {\n    exact = 'exact',\n    rounded = 'rounded'\n}\n\nexport enum DefaultGridSizes {\n    grid = 64,\n    kmeans = 150\n}\n\nexport const DefaultMarkerImageSizes = {\n    1: [24, 39],\n    5: [30, 30],\n    10: [30, 30],\n    50: [40, 40],\n    100: [40, 40],\n    1000: [50, 50],\n    10000: [60, 60]\n}","import { SRIDS, MaxBounds, ClusterMethod, GeometryType } from \"./consts\";\nimport { Point, GeoJSON, Coordinates, Viewport } from \"./geometry\";\n\nexport const Bounds4326: MaxBounds = Object.freeze({\n    minX: -179,\n    maxX: 179,\n    minY: -89,\n    maxY: 89\n})\n\n\nexport const Bounds3857: MaxBounds = Object.freeze({\n    minX: -20037500, //-20037508.34\n    maxX: 20037500, // 20037508.34\n    minY: -20048960, // -20048966.1\n    maxY: 20048960 //  20048966.1\n})\n\n/*\nexport interface AnyclusterSettings {\n    gridSize: number\n    srid: SRIDS\n    autostart?: boolean\n    filters?: []\n    initialCenter?: Point\n    clusterArea?: object\n}*/\n\nexport interface ClusterRequestData {\n    output_srid: SRIDS\n    geometry_type: GeometryType\n    geojson: GeoJSON\n    clear_cache: boolean\n    filters: object[]\n}\n\nexport interface GetKmeansClusterContentRequestData {\n    geometry_type: GeometryType\n    input_srid: SRIDS\n    x: number\n    y: number\n    ids: number[]\n}\n\n\nexport class Anycluster {\n\n    filters: object[] = []\n    maxBounds: MaxBounds\n\n    constructor(private apiUrl: string, public gridSize: number, public srid: SRIDS) {\n\n        if (this.srid == SRIDS.EPSG4326) {\n            this.maxBounds = Bounds4326;\n        }\n        else if (this.srid == SRIDS.EPSG3857) {\n            this.maxBounds = Bounds3857;\n        }\n        else {\n            throw new Error(`invalid srid given: ${this.srid} `);\n        }\n\n    }\n\n    async getGridCluster(zoom: number, data: ClusterRequestData) {\n        const url = `${this.apiUrl}grid/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters;\n    }\n\n    async getKmeansCluster(zoom: number, data: ClusterRequestData) {\n\n        const url = `${this.apiUrl}kmeans/${zoom}/${this.gridSize}/`;\n        const clusters = await this.post(url, data);\n        return clusters\n    }\n\n    async getKmeansClusterContent(zoom: number, data: GetKmeansClusterContentRequestData) {\n\n        const url = `${this.apiUrl}get-kmeans-cluster-content/${zoom}/${this.gridSize}/`;\n\n        const clusterContent = await this.post(url, data);\n\n        return clusterContent;\n    }\n\n    async getDatasetContent(zoom: number, datasetId: number) {\n        const url = `${this.apiUrl}get-dataset-content/${zoom}/${this.gridSize}/${datasetId}/`;\n\n        const clusterContent = await this.get(url);\n\n        return clusterContent;\n    }\n\n    getAreaContent() {\n\n    }\n\n    addFilters() {\n\n    }\n\n    removeFilters() {\n\n    }\n\n\n    viewportToGeoJSON(viewport: Viewport) {\n\n        const left = Math.max(viewport.left, this.maxBounds.minX);\n        const right = Math.min(viewport.right, this.maxBounds.maxX);\n        const top = Math.min(viewport.top, this.maxBounds.maxY);\n        const bottom = Math.max(viewport.bottom, this.maxBounds.minY);\n\n        const geometryType = \"Polygon\";\n\n        const coordinates = [[\n            [left, top],\n            [right, top],\n            [right, bottom],\n            [left, bottom],\n            [left, top]\n        ]];\n\n        const geoJSON = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": geometryType,\n                \"coordinates\": coordinates,\n                \"crs\": {\n                    \"type\": \"name\",\n                    \"properties\": {\n                        \"name\": this.srid\n                    }\n                }\n            }\n        };\n\n        return geoJSON;\n    }\n\n    async post(url: string, postData: object) {\n\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'POST',\n            body: JSON.stringify(postData),\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n\n    }\n\n    async get(url: string) {\n        const encodedUrl = encodeURI(url);\n\n        const options = {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            mode: 'cors' as 'cors',\n            credentials: 'include' as 'include'\n        }\n\n        const response = await fetch(encodedUrl, options);\n        const responseData = await response.json();\n\n        if (response.ok) {\n            return responseData\n        }\n        else {\n            throw new Error(JSON.stringify(responseData));\n        }\n    }\n}","\nimport { ClusterMethod, GeometryType, IconType, SRIDS, DefaultGridSizes, DefaultMarkerImageSizes } from \"./consts\";\nimport { GeoJSON, Marker, Cluster, Viewport } from \"./geometry\";\nimport { Anycluster, GetKmeansClusterContentRequestData, ClusterRequestData } from \"./anycluster\";\n\n\nexport interface AnyclusterClientSettings {\n    srid?: SRIDS // srid of the map\n    kmeansGridSize?: number\n    gridGridSize?: number\n    clusterMethod?: ClusterMethod\n    geometryType?: GeometryType\n    area?: any\n    iconType?: IconType\n    onFinalClick?: Function\n    singlePinImages?: Record<string, string>\n    markerImageSizes?: Record<string, number[]>\n    gridFillColors?: Record<number, string>\n    gridStrokeColors?: Record<number, string>\n}\n\nexport class AnyclusterClient {\n\n    srid: SRIDS\n    kmeansGridSize: number\n    gridGridSize: number\n    clusterMethod: ClusterMethod\n    geometryType: GeometryType\n\n    area: GeoJSON | null\n    iconType: IconType\n\n    anycluster: Anycluster\n    markerList: any[]\n    onFinalClick: Function\n    singlePinImages?: Record<string, string>\n\n    markerImageSizes: Record<string, number[]>\n\n    filters: any[] = []\n\n\n    constructor(public map: any, public apiUrl: string, public markerFolderPath: string, settings: AnyclusterClientSettings) {\n\n        this.map = map;\n        this.apiUrl = apiUrl;\n        this.markerFolderPath = markerFolderPath;\n\n        settings = settings || {};\n\n\n        // settings\n        this.srid = settings.srid ? settings.srid : SRIDS.EPSG4326;\n        this.kmeansGridSize = settings.gridGridSize ? settings.gridGridSize: DefaultGridSizes.kmeans;\n        this.gridGridSize = settings.gridGridSize ? settings.gridGridSize: DefaultGridSizes.grid;\n\n        this.clusterMethod = settings.clusterMethod ? settings.clusterMethod : ClusterMethod.kmeans;\n        this.geometryType = settings.geometryType ? settings.geometryType : GeometryType.viewport;\n\n        this.area = settings.area ? settings.area : null;\n        this.iconType = settings.iconType ? settings.iconType : IconType.rounded;\n\n        this.onFinalClick = settings.onFinalClick ? settings.onFinalClick : this._onFinalClick;\n\n        this.singlePinImages = settings.singlePinImages ? settings.singlePinImages : {};\n\n        this.markerImageSizes = settings.markerImageSizes ? settings.markerImageSizes : DefaultMarkerImageSizes;\n        \n\n        if (this.area) {\n            this.setArea(this.area);\n        }\n\n        const gridSize = this.getGridSize();\n        this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n\n        this.createClusterLayers();\n        this.markerList = [];\n\n        this.startClustering();\n    }\n\n    createClusterLayers(): void {\n        throw new Error(\"NotImplementedError: createClusterLayers\");\n    }\n\n    addArea(geojson: object): void {\n        throw new Error(\"NotImplementedError: addArea\");\n    }\n\n    removeArea(): void {\n        throw new Error(\"NotImplementedError: removeArea\");\n    }\n\n    removeAllMarkers(): void {\n        throw new Error(\"NotImplementedError: removeAllMarkers\");\n    }\n\n    getZoom(): number {\n        throw new Error(\"NotImplementedError: getZoom\");\n    }\n\n    setMap(x: number, y: number, zoom: number): void {\n        throw new Error(\"NotImplementedError: setMap\");\n    }\n\n    getViewport(): Viewport {\n        throw new Error(\"NotImplementedError: setMap\");\n    }\n\n    addMapEventListeners(): void {\n        throw new Error(\"NotImplementedError: addMapEventListeners\");\n    }\n\n    drawMarker(cluster: Cluster): void {\n        throw new Error(\"NotImplementedError: drawMarker\");\n    }\n\n    drawCell(cluster: Cluster): void {\n        throw new Error(\"NotImplementedError: drawCell\");\n    }\n\n    getAreaContent(geojson: GeoJSON): void {\n        throw new Error(\"NotImplementedError: getAreaContent\");\n    }\n\n\n    getGridSize(): number {\n        if (this.clusterMethod == ClusterMethod.grid) {\n            return this.gridGridSize;\n        }\n\n        return this.kmeansGridSize;\n    }\n\n    setClusterMethod(clusterMethod: ClusterMethod) {\n\n        if (clusterMethod == ClusterMethod.grid) {\n            this.area = null;\n            this.geometryType = GeometryType.viewport;\n            this.removeArea();\n        }\n\n        this.removeAllMarkers();\n        this.clusterMethod = clusterMethod;\n        const gridSize = this.getGridSize();\n        this.anycluster = new Anycluster(this.apiUrl, gridSize, this.srid);\n        this.markerList = [];\n        this.getClusters(true);\n    }\n\n    setArea(geojson: GeoJSON) {\n\n        this.area = geojson;\n\n        this.removeArea();\n\n        if (geojson == null) {\n            this.geometryType = GeometryType.viewport;\n            this.setClusterMethod(ClusterMethod.kmeans);\n        }\n        else {\n\n            this.addArea(geojson);\n\n            this.geometryType = GeometryType.area;\n\n            this.setClusterMethod(ClusterMethod.kmeans);\n        }\n    }\n\n    getSinglePinImageURL(cluster: Cluster) {\n\n        const pinimg = cluster.pinimg;\n\n        let url = `${this.markerFolderPath}pin_unknown.png`;\n\n        if (this.singlePinImages && pinimg && pinimg in this.singlePinImages) {\n            url = this.singlePinImages[pinimg];\n        }\n\n        return url\n\n    }\n\n    selectPinIcon(cluster: Cluster) {\n\n        const count = cluster.count;\n\n        let markerImageUrl = this.getSinglePinImageURL(cluster);\n        let pinicon = \"1\";\n\n        if (count > 10000) {\n            pinicon = \"10000\";\n        }\n\n        else if (count > 1000) {\n            pinicon = \"1000\";\n        }\n\n        else if (count > 100) {\n            pinicon = \"100\";\n        }\n\n        else if (count > 50) {\n            pinicon = \"50\";\n        }\n\n        else if (count > 10) {\n            pinicon = \"10\";\n        }\n\n        else if (count > 1) {\n            pinicon = \"5\";\n        }\n\n        if (count > 1) {\n            if (this.iconType == IconType.exact) {\n                markerImageUrl = `${this.markerFolderPath}${pinicon}_empty.png`;\n            }\n            else {\n                markerImageUrl = `${this.markerFolderPath}${pinicon}.png`;\n            }\n        }\n\n        const size = this.markerImageSizes[pinicon];\n        let anchor = [Math.round(size[0] / 2), size[1] - 1];\n        let relativeAnchor = [0.5, 1];\n\n        if (count > 1) {\n            anchor = [Math.round((size[0] / 2)), Math.round(size[1] / 2)];\n            relativeAnchor = [0.5, 0.5];\n        }\n\n        const imgObj = {\n            url: markerImageUrl,\n            size: size,\n            anchor: anchor,\n            relativeAnchor: relativeAnchor,\n            popupAnchor: [0, -Math.round(size[1]) + 8]\n        }\n\n        return imgObj;\n\n    }\n\n    // marker can be an openlayers Feature or a L.marker\n    setMarkerProps(marker: any, cluster: Cluster) {\n\n        // add properties required by anycluster\n        marker.x = cluster.center.x;\n        marker.y = cluster.center.y;\n        marker.count = cluster.count;\n\n        if (cluster.hasOwnProperty(\"ids\")) {\n            marker.ids = cluster.ids;\n        }\n\n        if (cluster.hasOwnProperty(\"id\")) {\n            marker.id = cluster.id;\n        }\n\n        if (cluster.hasOwnProperty(\"geojson\")) {\n            \n            /*const geojson = {\n                \"type\": \"Feature\",\n                \"count\": cluster.count,\n                \"geometry\": cluster.geojson,\n                \"properties\": {\n                    \"count\": cluster.count\n                },\n                \"crs\" : {\n                    \"type\" : \"name\",\n                    \"properties\" : {\n                        \"name\" : this.srid\n                    }\n                }\n            };*/\n\n            marker.geojson = cluster.geojson;\n        }\n\n        return marker;\n\n    }\n\n    markerClickFunction(x: number, y: number) {\n        this.removeAllMarkers();\n        let zoom = this.getZoom();\n        zoom = zoom + 3;\n        this.setMap(x, y, zoom);\n    }\n\n    async onMarkerFinalClick(marker: any) {\n\n        const zoom = this.getZoom();\n        const x = marker.x;\n        const y = marker.y;\n        const ids = marker.ids;\n\n        if (this.clusterMethod == ClusterMethod.kmeans) {\n\n            const postData = {\n                \"geometry_type\": this.geometryType,\n                \"input_srid\": this.srid,\n                \"x\": x,\n                \"y\": y,\n                \"ids\": ids,\n                \"filters\": this.filters\n            } as GetKmeansClusterContentRequestData;\n\n            const data = await this.anycluster.getKmeansClusterContent(zoom, postData);\n\n            this.onFinalClick(marker, data);\n\n        }\n        else if (this.clusterMethod = ClusterMethod.grid) {\n\n            if (marker.count == 1) {\n                const data = await this.anycluster.getDatasetContent(zoom, marker.id);\n                this.onFinalClick(marker, data);\n            }\n            else {\n                const geojson = marker[\"geojson\"];\n                const data = await this.getAreaContent(geojson);\n\n                this.onFinalClick(marker, data);\n            }\n\n        }\n    }\n\n    roundMarkerCount(count: number): number {\n\n        if (count == 1) {\n            count = 1;\n        }\n        else if (count <= 5) {\n            count = 5;\n        }\n        else if (count <= 10) {\n            count = 10;\n        }\n        else if (count <= 50) {\n            count = 50;\n        }\n        else if (count <= 100) {\n            count = 100;\n        }\n        else if (count <= 1000) {\n            count = 1000;\n        }\n        else {\n            count = 10000;\n        }\n\n        return count;\n    }\n\n    getClusterGeometry() {\n        let geoJSON;\n\n        if (this.geometryType == GeometryType.viewport) {\n            const viewport = this.getViewport();\n            geoJSON = this.anycluster.viewportToGeoJSON(viewport);\n        }\n        else if (this.geometryType == GeometryType.area && this.area) {\n            geoJSON = this.area;\n        }\n        else {\n            throw new Error('No cluster geometry found');\n        }\n\n        return geoJSON;\n\n    }\n\n    async getClusters(clearCache = false) {\n\n        const geoJSON = this.getClusterGeometry()\n\n        const postData = {\n            \"output_srid\": this.srid,\n            \"geometry_type\": this.geometryType,\n            \"geojson\": geoJSON,\n            \"clear_cache\": clearCache\n        } as ClusterRequestData;\n\n        const zoom = this.getZoom();\n\n        if (this.clusterMethod == ClusterMethod.kmeans) {\n\n\n            const clusters: Cluster[] = await this.anycluster.getKmeansCluster(zoom, postData);\n\n            if (clusters.length > 0) {\n                clusters.forEach(cluster => {\n                    this.drawMarker(cluster);\n                });\n            }\n        }\n        else if (this.clusterMethod == ClusterMethod.grid) {\n            const clusters: Cluster[] = await this.anycluster.getGridCluster(zoom, postData);\n\n            if (clusters.length > 0) {\n                clusters.forEach(cluster => {\n                    this.drawCell(cluster);\n                });\n            }\n        }\n        else {\n            throw new Error(`Invalid clusterMethod: ${this.clusterMethod}`);\n        }\n    }\n\n    startClustering() {\n        this.getClusters(true);\n        this.addMapEventListeners();\n    }\n\n    _onFinalClick(marker: Marker, data: any) {\n        alert(JSON.stringify(data));\n    }\n\n}"],"names":[],"version":3,"file":"anycluster.js.map"}