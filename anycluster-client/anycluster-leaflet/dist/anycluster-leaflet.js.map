{"mappings":"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","sources":["src/index.ts","src/anycluster-leaflet.ts"],"sourcesContent":["export {\n    ClusterMethod,\n    AnyclusterLeaflet,\n} from \"./anycluster-leaflet\";","import {\n    AnyclusterClient,\n    AnyclusterClientSettings,\n    Viewport,\n    KmeansCluster,\n    GridCluster,\n    ClusterMethod,\n    GeoJSON as IGeoJSON,\n    IconType,\n} from 'anycluster-client';\n\nimport * as  L from 'leaflet';\n\nexport {\n    ClusterMethod\n};\n\nexport class AnyclusterLeaflet extends AnyclusterClient {\n\n    currentZoom: number\n\n    constructor(map: any, apiUrl: string, markerFolderPath: string, settings: AnyclusterClientSettings) {\n        super(map, apiUrl, markerFolderPath, settings);\n\n        this.currentZoom = this.getZoom();\n\n    }\n\n\n    removeArea() {\n        if (this.map.hasOwnProperty(\"areaLayer\")) {\n            this.map.areaLayer.clearLayers();\n        }\n    }\n\n    addArea(geojson: IGeoJSON) {\n        if (!this.map.hasOwnProperty(\"areaLayer\")) {\n            this.createAreaLayer();\n        }\n\n        L.geoJSON(geojson, {\n            style: {\n                color: 'red'\n            }\n        }).addTo(this.map.areaLayer);\n\n    }\n\n    createClusterLayers() {\n        const kmeansLayer = L.layerGroup().addTo(this.map);\n        this.map.kmeansLayer = kmeansLayer;\n\n        // support geojson for grid cluster\n        const gridClusterLayer = L.layerGroup().addTo(this.map);\n        this.map.gridClusterLayer = gridClusterLayer;\n\n    }\n\n    createAreaLayer() {\n        const areaLayer = L.layerGroup().addTo(this.map);\n        this.map.areaLayer = areaLayer;\n\n    }\n\n    getMarkerIcon(cluster: KmeansCluster | GridCluster) {\n\n        // get the correct icon\n        const piniconObj = this.selectPinIcon(cluster);\n\n        let markerIcon;\n\n        if (this.iconType === IconType.exact && cluster.count > 1){\n            markerIcon = L.divIcon({\n                className: '',\n                html: `<div style=\"display:flex;align-items:center;justify-content:center;color:#FFF;font-weight:bold;fonts-size:12px;width:100%;height:100%;background-image:url('${piniconObj.url}')\">${cluster.count}</div>`,\n                iconSize: piniconObj.size,\n                iconAnchor: piniconObj.anchor,\n                popupAnchor: piniconObj.popupAnchor\n            });\n        }\n        else {\n            // create a leaflet icon\n            markerIcon = L.icon({\n                iconUrl: piniconObj.url,\n                iconSize: piniconObj.size,\n                iconAnchor: piniconObj.anchor,\n                popupAnchor: piniconObj.popupAnchor\n            });\n        }\n\n        return markerIcon;\n\n    }\n\n    _getLMarker(cluster: KmeansCluster | GridCluster) {\n        const markerIcon = this.getMarkerIcon(cluster);\n\n        const latLng = L.latLng(cluster.center.y, cluster.center.x);\n\n        const marker_options = {\n            icon: markerIcon\n        };\n\n        const marker = L.marker(latLng, marker_options);\n\n        return marker;\n    }\n\n    _drawLMarker(marker: any) {\n        this.addMarkerClickListener(marker);\n\n        marker.addTo(this.map.kmeansLayer);\n\n        this.markerList.push(marker);\n    }\n\n    drawKmeansMarker(cluster: KmeansCluster) {\n        let marker = this._getLMarker(cluster);\n        marker = this.setMarkerProps(marker, cluster);\n        this._drawLMarker(marker);\n    }\n\n    drawGridMarker(cluster: GridCluster) {\n        let marker = this._getLMarker(cluster);\n        marker = this.setCellProps(marker, cluster);\n        this._drawLMarker(marker);\n    }\n\n    drawCell(cluster: GridCluster) {\n        const count = cluster.count;\n\n        if (count == 1) {\n            this.drawGridMarker(cluster)\n        }\n        else {\n            const latLng = L.latLng(cluster.center.y, cluster.center.x);\n\n            const geojson = {\n                \"type\": \"Feature\",\n                \"count\": count,\n                \"geometry\": cluster.geojson,\n                \"properties\": {\n                    \"count\": count\n                }\n            };\n\n\n            const roundedCount = this.roundMarkerCount(count);\n\n            const fillColor = this.gridFillColors[roundedCount];\n            const strokeColor = this.gridStrokeColors[roundedCount];\n            const strokeWeight = 1;\n\n            const cell = L.geoJSON(geojson, {\n                style: {\n                    color: strokeColor,\n                    stroke: true,\n                    fillColor: fillColor,\n                    weight: strokeWeight,\n                    fillOpacity: 1,\n                }\n            });\n\n            // add properties required by anycluster to marker\n            cell.latitude = latLng.lat;\n            cell.longitude = latLng.lng;\n            cell.x = latLng.lng;\n            cell.y = latLng.lat;\n            cell.count = count;\n            cell.geojson = geojson;\n\n            this.addMarkerClickListener(cell);\n\n            cell.addTo(this.map.gridClusterLayer);\n        }\n\n    }\n\n    removeAllMarkers() {\n\n        // remove all the markers in one go\n        this.map.kmeansLayer.clearLayers();\n\n        if (this.map.hasOwnProperty(\"gridClusterLayer\")) {\n            this.map.gridClusterLayer.clearLayers();\n        }\n\n        this.markerList.length = 0;\n\n\n    }\n\n    addMapEventListeners() {\n        this.map.addEventListener(\"moveend\", event => this.getClusters());\n        this.map.addEventListener(\"zoomend\", event => this.removeAllMarkers());\n    }\n\n\n    getViewport(): Viewport {\n\n        const viewport = this.map.getBounds();\n\n        if (viewport.isValid()) {\n            const viewportJSON = {\n                \"left\": viewport.getSouthWest().wrap().lng,\n                \"top\": viewport.getNorthEast().wrap().lat,\n                \"right\": viewport.getNorthEast().wrap().lng,\n                \"bottom\": viewport.getSouthWest().wrap().lat\n            };\n\n            return viewportJSON;\n        }\n        else {\n            throw new Error(\"invalid viewport\");\n        }\n\n    }\n\n    getZoom(): number {\n        return this.map.getZoom();\n    }\n\n    setZoom(zoom: number): void {\n        this.map.setZoom(zoom);\n    }\n\n\n    setMap(x: number, y: number, zoom: number): void {\n        const center = L.latLng(y, x);\n        this.map.setView(center, zoom);\n    }\n\n    addMarkerClickListener(marker) {\n\n        const zoom = this.getZoom();\n\n        if (zoom >= this.maxZoom || marker.count == 1) {\n            marker.on(\"click\", (event) => {\n                this.onMarkerFinalClick(marker);\n            });\n        }\n\n        else {\n            marker.on(\"click\", (event) => {\n                this.markerClickFunction(marker.x, marker.y);\n            });\n        }\n    }\n\n}"],"names":[],"version":3,"file":"anycluster-leaflet.js.map"}