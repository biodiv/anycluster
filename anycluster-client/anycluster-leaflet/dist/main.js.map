{"mappings":"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","sources":["<anon>","src/index.ts","src/anycluster-leaflet.ts"],"sourcesContent":["var $kEX8F$anyclusterclient = require(\"anycluster-client\");\nvar $kEX8F$leaflet = require(\"leaflet\");\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n$parcel$export(module.exports, \"ClusterMethod\", () => $daa68199c6ecee0a$re_export$ClusterMethod);\n$parcel$export(module.exports, \"AnyclusterLeaflet\", () => $daa68199c6ecee0a$export$d28c3646e727c4c9);\n\n\nclass $daa68199c6ecee0a$export$d28c3646e727c4c9 extends (0, $kEX8F$anyclusterclient.AnyclusterClient) {\n    constructor(map, apiUrl, markerFolderPath, settings){\n        super(map, apiUrl, markerFolderPath, settings);\n        this.currentZoom = this.getZoom();\n    }\n    removeArea() {\n        if (this.map.hasOwnProperty(\"areaLayer\")) this.map.areaLayer.clearLayers();\n    }\n    addArea(geojson) {\n        if (!this.map.hasOwnProperty(\"areaLayer\")) this.createAreaLayer();\n        $kEX8F$leaflet.geoJSON(geojson, {\n            style: {\n                color: \"red\"\n            }\n        }).addTo(this.map.areaLayer);\n    }\n    createClusterLayers() {\n        const kmeansLayer = $kEX8F$leaflet.layerGroup().addTo(this.map);\n        this.map.kmeansLayer = kmeansLayer;\n        // support geojson for grid cluster\n        const gridClusterLayer = $kEX8F$leaflet.layerGroup().addTo(this.map);\n        this.map.gridClusterLayer = gridClusterLayer;\n    }\n    createAreaLayer() {\n        const areaLayer = $kEX8F$leaflet.layerGroup().addTo(this.map);\n        this.map.areaLayer = areaLayer;\n    }\n    getMarkerIcon(cluster) {\n        // get the correct icon\n        const piniconObj = this.selectPinIcon(cluster);\n        // create a leaflet icon\n        const markerIcon = $kEX8F$leaflet.icon({\n            iconUrl: piniconObj.url,\n            iconSize: piniconObj.size,\n            iconAnchor: piniconObj.anchor,\n            popupAnchor: piniconObj.popupAnchor\n        });\n        return markerIcon;\n    }\n    drawMarker(cluster) {\n        const markerIcon = this.getMarkerIcon(cluster);\n        const latLng = $kEX8F$leaflet.latLng(cluster.center.y, cluster.center.x);\n        const marker_options = {\n            icon: markerIcon\n        };\n        let marker = $kEX8F$leaflet.marker(latLng, marker_options);\n        marker = this.setMarkerProps(marker, cluster);\n        this.addMarkerClickListener(marker);\n        marker.addTo(this.map.kmeansLayer);\n        this.markerList.push(marker);\n    }\n    drawCell(cluster) {\n        const count = cluster.count;\n        if (count == 1) this.drawMarker(cluster);\n        else {\n            const latLng = $kEX8F$leaflet.latLng(cluster.center.y, cluster.center.x);\n            const geojson = {\n                \"type\": \"Feature\",\n                \"count\": count,\n                \"geometry\": cluster.geojson,\n                \"properties\": {\n                    \"count\": count\n                }\n            };\n            const roundedCount = this.roundMarkerCount(count);\n            const fillColor = this.gridFillColors[roundedCount];\n            const strokeColor = this.gridStrokeColors[roundedCount];\n            const strokeWeight = 1;\n            const cell = $kEX8F$leaflet.geoJSON(geojson, {\n                style: {\n                    color: strokeColor,\n                    stroke: true,\n                    fillColor: fillColor,\n                    weight: strokeWeight,\n                    fillOpacity: 1\n                }\n            });\n            // add properties required by anycluster to marker\n            cell.latitude = latLng.lat;\n            cell.longitude = latLng.lng;\n            cell.x = latLng.lng;\n            cell.y = latLng.lat;\n            cell.count = count;\n            cell.geojson = geojson;\n            this.addMarkerClickListener(cell);\n            cell.addTo(this.map.gridClusterLayer);\n        }\n    }\n    removeAllMarkers() {\n        // remove all the markers in one go\n        this.map.kmeansLayer.clearLayers();\n        if (this.map.hasOwnProperty(\"gridClusterLayer\")) this.map.gridClusterLayer.clearLayers();\n        this.markerList.length = 0;\n    }\n    addMapEventListeners() {\n        this.map.addEventListener(\"moveend\", (event)=>this.getClusters());\n        this.map.addEventListener(\"zoomend\", (event)=>this.removeAllMarkers());\n    }\n    getViewport() {\n        const viewport = this.map.getBounds();\n        if (viewport.isValid()) {\n            const viewportJSON = {\n                \"left\": viewport.getSouthWest().wrap().lng,\n                \"top\": viewport.getNorthEast().wrap().lat,\n                \"right\": viewport.getNorthEast().wrap().lng,\n                \"bottom\": viewport.getSouthWest().wrap().lat\n            };\n            return viewportJSON;\n        } else throw new Error(\"invalid viewport\");\n    }\n    getZoom() {\n        return this.map.getZoom();\n    }\n    setZoom(zoom) {\n        this.map.setZoom(zoom);\n    }\n    setMap(x, y, zoom) {\n        const center = $kEX8F$leaflet.latLng(y, x);\n        this.map.setView(center, zoom);\n    }\n    addMarkerClickListener(marker) {\n        const zoom = this.getZoom();\n        if (zoom >= this.maxZoom || marker.count == 1) marker.on(\"click\", (event)=>{\n            this.onMarkerFinalClick(marker);\n        });\n        else marker.on(\"click\", (event)=>{\n            this.markerClickFunction(marker.x, marker.y);\n        });\n    }\n}\n\n\n\n\n//# sourceMappingURL=main.js.map\n","export {\n    ClusterMethod,\n    AnyclusterLeaflet,\n} from \"./anycluster-leaflet\";","import {\n    AnyclusterClient,\n    AnyclusterClientSettings,\n    Viewport,\n    Cluster,\n    ClusterMethod,\n    GeoJSON as IGeoJSON,\n} from 'anycluster-client';\n\nimport * as  L from 'leaflet';\n\nexport {\n    ClusterMethod\n};\n\nexport class AnyclusterLeaflet extends AnyclusterClient {\n\n    currentZoom: number\n\n    constructor(map: any, apiUrl: string, markerFolderPath: string, settings: AnyclusterClientSettings) {\n        super(map, apiUrl, markerFolderPath, settings);\n\n        this.currentZoom = this.getZoom();\n\n    }\n\n\n    removeArea() {\n        if (this.map.hasOwnProperty(\"areaLayer\")) {\n            this.map.areaLayer.clearLayers();\n        }\n    }\n\n    addArea(geojson: IGeoJSON) {\n        if (!this.map.hasOwnProperty(\"areaLayer\")) {\n            this.createAreaLayer();\n        }\n\n        L.geoJSON(geojson, {\n            style: {\n                color: 'red'\n            }\n        }).addTo(this.map.areaLayer);\n\n    }\n\n    createClusterLayers() {\n        const kmeansLayer = L.layerGroup().addTo(this.map);\n        this.map.kmeansLayer = kmeansLayer;\n\n        // support geojson for grid cluster\n        const gridClusterLayer = L.layerGroup().addTo(this.map);\n        this.map.gridClusterLayer = gridClusterLayer;\n\n    }\n\n    createAreaLayer() {\n        const areaLayer = L.layerGroup().addTo(this.map);\n        this.map.areaLayer = areaLayer;\n\n    }\n\n    getMarkerIcon(cluster: Cluster) {\n\n        // get the correct icon\n        const piniconObj = this.selectPinIcon(cluster);\n\n        // create a leaflet icon\n        const markerIcon = L.icon({\n            iconUrl: piniconObj.url,\n            iconSize: piniconObj.size,\n            iconAnchor: piniconObj.anchor,\n            popupAnchor: piniconObj.popupAnchor\n        });\n\n        return markerIcon;\n\n    }\n\n    drawMarker(cluster: Cluster) {\n        const markerIcon = this.getMarkerIcon(cluster);\n\n        const latLng = L.latLng(cluster.center.y, cluster.center.x);\n\n        const marker_options = {\n            icon: markerIcon\n        };\n\n        let marker = L.marker(latLng, marker_options);\n\n        marker = this.setMarkerProps(marker, cluster);\n\n        this.addMarkerClickListener(marker);\n\n        marker.addTo(this.map.kmeansLayer);\n\n        this.markerList.push(marker);\n\n    }\n\n    drawCell(cluster: Cluster) {\n        const count = cluster.count;\n\n        if (count == 1) {\n            this.drawMarker(cluster)\n        }\n        else {\n            const latLng = L.latLng(cluster.center.y, cluster.center.x);\n\n            const geojson = {\n                \"type\": \"Feature\",\n                \"count\": count,\n                \"geometry\": cluster.geojson,\n                \"properties\": {\n                    \"count\": count\n                }\n            };\n\n\n            const roundedCount = this.roundMarkerCount(count);\n\n            const fillColor = this.gridFillColors[roundedCount];\n            const strokeColor = this.gridStrokeColors[roundedCount];\n            const strokeWeight = 1;\n\n            const cell = L.geoJSON(geojson, {\n                style: {\n                    color: strokeColor,\n                    stroke: true,\n                    fillColor: fillColor,\n                    weight: strokeWeight,\n                    fillOpacity: 1,\n                }\n            });\n\n            // add properties required by anycluster to marker\n            cell.latitude = latLng.lat;\n            cell.longitude = latLng.lng;\n            cell.x = latLng.lng;\n            cell.y = latLng.lat;\n            cell.count = count;\n            cell.geojson = geojson;\n\n            this.addMarkerClickListener(cell);\n\n            cell.addTo(this.map.gridClusterLayer);\n        }\n\n    }\n\n    removeAllMarkers() {\n\n        // remove all the markers in one go\n        this.map.kmeansLayer.clearLayers();\n\n        if (this.map.hasOwnProperty(\"gridClusterLayer\")) {\n            this.map.gridClusterLayer.clearLayers();\n        }\n\n        this.markerList.length = 0;\n\n\n    }\n\n    addMapEventListeners() {\n        this.map.addEventListener(\"moveend\", event => this.getClusters());\n        this.map.addEventListener(\"zoomend\", event => this.removeAllMarkers());\n    }\n\n\n    getViewport(): Viewport {\n\n        const viewport = this.map.getBounds();\n\n        if (viewport.isValid()) {\n            const viewportJSON = {\n                \"left\": viewport.getSouthWest().wrap().lng,\n                \"top\": viewport.getNorthEast().wrap().lat,\n                \"right\": viewport.getNorthEast().wrap().lng,\n                \"bottom\": viewport.getSouthWest().wrap().lat\n            };\n\n            return viewportJSON;\n        }\n        else {\n            throw new Error(\"invalid viewport\");\n        }\n\n    }\n\n    getZoom(): number {\n        return this.map.getZoom();\n    }\n\n    setZoom(zoom: number): void {\n        this.map.setZoom(zoom);\n    }\n\n\n    setMap(x: number, y: number, zoom: number): void {\n        const center = L.latLng(y, x);\n        this.map.setView(center, zoom);\n    }\n\n    addMarkerClickListener(marker) {\n\n        const zoom = this.getZoom();\n\n        if (zoom >= this.maxZoom || marker.count == 1) {\n            marker.on(\"click\", (event) => {\n                this.onMarkerFinalClick(marker);\n            });\n        }\n\n        else {\n            marker.on(\"click\", (event) => {\n                this.markerClickFunction(marker.x, marker.y);\n            });\n        }\n    }\n\n}"],"names":["$kEX8F$anyclusterclient","require","$kEX8F$leaflet","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","module","exports","$daa68199c6ecee0a$re_export$ClusterMethod","$daa68199c6ecee0a$export$d28c3646e727c4c9","AnyclusterClient","constructor","map","apiUrl","markerFolderPath","settings","currentZoom","getZoom","removeArea","hasOwnProperty","areaLayer","clearLayers","addArea","geojson","createAreaLayer","geoJSON","style","color","addTo","createClusterLayers","kmeansLayer","layerGroup","gridClusterLayer","getMarkerIcon","cluster","piniconObj","selectPinIcon","markerIcon","icon","iconUrl","url","iconSize","size","iconAnchor","anchor","popupAnchor","drawMarker","latLng","center","y","x","marker","setMarkerProps","addMarkerClickListener","markerList","push","drawCell","count","roundedCount","roundMarkerCount","fillColor","gridFillColors","strokeColor","gridStrokeColors","cell","stroke","weight","fillOpacity","latitude","lat","longitude","lng","removeAllMarkers","length","addMapEventListeners","addEventListener","event","getClusters","getViewport","viewport","getBounds","isValid","viewportJSON","getSouthWest","wrap","getNorthEast","Error","setZoom","zoom","setMap","setView","maxZoom","on","onMarkerFinalClick","markerClickFunction"],"version":3,"file":"main.js.map"}