{"mappings":"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","sources":["<anon>","src/index.ts","src/anycluster-leaflet.ts"],"sourcesContent":["var $kEX8F$anyclusterclient = require(\"anycluster-client\");\nvar $kEX8F$leaflet = require(\"leaflet\");\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n$parcel$export(module.exports, \"ClusterMethod\", () => $daa68199c6ecee0a$re_export$ClusterMethod);\n$parcel$export(module.exports, \"AnyclusterLeaflet\", () => $daa68199c6ecee0a$export$d28c3646e727c4c9);\n\n\nclass $daa68199c6ecee0a$export$d28c3646e727c4c9 extends (0, $kEX8F$anyclusterclient.AnyclusterClient) {\n    constructor(map, apiUrl, markerFolderPath, settings){\n        super(map, apiUrl, markerFolderPath, settings);\n        this.currentZoom = this.getZoom();\n    }\n    removeArea() {\n        if (this.map.hasOwnProperty(\"areaLayer\")) this.map.areaLayer.clearLayers();\n    }\n    addArea(geojson) {\n        if (!this.map.hasOwnProperty(\"areaLayer\")) this.createAreaLayer();\n        $kEX8F$leaflet.geoJSON(geojson, {\n            style: {\n                color: \"red\"\n            }\n        }).addTo(this.map.areaLayer);\n    }\n    createClusterLayers() {\n        const kmeansLayer = $kEX8F$leaflet.layerGroup().addTo(this.map);\n        this.map.kmeansLayer = kmeansLayer;\n        // support geojson for grid cluster\n        const gridClusterLayer = $kEX8F$leaflet.layerGroup().addTo(this.map);\n        this.map.gridClusterLayer = gridClusterLayer;\n    }\n    createAreaLayer() {\n        const areaLayer = $kEX8F$leaflet.layerGroup().addTo(this.map);\n        this.map.areaLayer = areaLayer;\n    }\n    getMarkerIcon(cluster) {\n        // get the correct icon\n        const piniconObj = this.selectPinIcon(cluster);\n        let markerIcon;\n        if (this.iconType === (0, $kEX8F$anyclusterclient.IconType).exact && cluster.count > 1) markerIcon = $kEX8F$leaflet.divIcon({\n            className: \"\",\n            html: `<div style=\"display:flex;align-items:center;justify-content:center;color:#FFF;font-weight:bold;fonts-size:12px;width:100%;height:100%;background-image:url('${piniconObj.url}')\">${cluster.count}</div>`,\n            iconSize: piniconObj.size,\n            iconAnchor: piniconObj.anchor,\n            popupAnchor: piniconObj.popupAnchor\n        });\n        else // create a leaflet icon\n        markerIcon = $kEX8F$leaflet.icon({\n            iconUrl: piniconObj.url,\n            iconSize: piniconObj.size,\n            iconAnchor: piniconObj.anchor,\n            popupAnchor: piniconObj.popupAnchor\n        });\n        return markerIcon;\n    }\n    _getLMarker(cluster) {\n        const markerIcon = this.getMarkerIcon(cluster);\n        const latLng = $kEX8F$leaflet.latLng(cluster.center.y, cluster.center.x);\n        const marker_options = {\n            icon: markerIcon\n        };\n        const marker = $kEX8F$leaflet.marker(latLng, marker_options);\n        return marker;\n    }\n    _drawLMarker(marker) {\n        this.addMarkerClickListener(marker);\n        marker.addTo(this.map.kmeansLayer);\n        this.markerList.push(marker);\n    }\n    drawKmeansMarker(cluster) {\n        let marker = this._getLMarker(cluster);\n        marker = this.setMarkerProps(marker, cluster);\n        this._drawLMarker(marker);\n    }\n    drawGridMarker(cluster) {\n        let marker = this._getLMarker(cluster);\n        marker = this.setCellProps(marker, cluster);\n        this._drawLMarker(marker);\n    }\n    drawCell(cluster) {\n        const count = cluster.count;\n        if (count == 1) this.drawGridMarker(cluster);\n        else {\n            const latLng = $kEX8F$leaflet.latLng(cluster.center.y, cluster.center.x);\n            const geojson = {\n                \"type\": \"Feature\",\n                \"count\": count,\n                \"geometry\": cluster.geojson,\n                \"properties\": {\n                    \"count\": count\n                }\n            };\n            const roundedCount = this.roundMarkerCount(count);\n            const fillColor = this.gridFillColors[roundedCount];\n            const strokeColor = this.gridStrokeColors[roundedCount];\n            const strokeWeight = 1;\n            const cell = $kEX8F$leaflet.geoJSON(geojson, {\n                style: {\n                    color: strokeColor,\n                    stroke: true,\n                    fillColor: fillColor,\n                    weight: strokeWeight,\n                    fillOpacity: 1\n                }\n            });\n            // add properties required by anycluster to marker\n            cell.latitude = latLng.lat;\n            cell.longitude = latLng.lng;\n            cell.x = latLng.lng;\n            cell.y = latLng.lat;\n            cell.count = count;\n            cell.geojson = geojson;\n            this.addMarkerClickListener(cell);\n            cell.addTo(this.map.gridClusterLayer);\n        }\n    }\n    removeAllMarkers() {\n        // remove all the markers in one go\n        this.map.kmeansLayer.clearLayers();\n        if (this.map.hasOwnProperty(\"gridClusterLayer\")) this.map.gridClusterLayer.clearLayers();\n        this.markerList.length = 0;\n    }\n    addMapEventListeners() {\n        this.map.addEventListener(\"moveend\", (event)=>this.getClusters());\n        this.map.addEventListener(\"zoomend\", (event)=>this.removeAllMarkers());\n    }\n    getViewport() {\n        const viewport = this.map.getBounds();\n        if (viewport.isValid()) {\n            const viewportJSON = {\n                \"left\": viewport.getSouthWest().wrap().lng,\n                \"top\": viewport.getNorthEast().wrap().lat,\n                \"right\": viewport.getNorthEast().wrap().lng,\n                \"bottom\": viewport.getSouthWest().wrap().lat\n            };\n            return viewportJSON;\n        } else throw new Error(\"invalid viewport\");\n    }\n    getZoom() {\n        return this.map.getZoom();\n    }\n    setZoom(zoom) {\n        this.map.setZoom(zoom);\n    }\n    setMap(x, y, zoom) {\n        const center = $kEX8F$leaflet.latLng(y, x);\n        this.map.setView(center, zoom);\n    }\n    addMarkerClickListener(marker) {\n        const zoom = this.getZoom();\n        if (zoom >= this.maxZoom || marker.count == 1) marker.on(\"click\", (event)=>{\n            this.onMarkerFinalClick(marker);\n        });\n        else marker.on(\"click\", (event)=>{\n            this.markerClickFunction(marker.x, marker.y);\n        });\n    }\n}\n\n\n\n\n//# sourceMappingURL=main.js.map\n","export {\n    ClusterMethod,\n    AnyclusterLeaflet,\n} from \"./anycluster-leaflet\";","import {\n    AnyclusterClient,\n    AnyclusterClientSettings,\n    Viewport,\n    KmeansCluster,\n    GridCluster,\n    ClusterMethod,\n    GeoJSON as IGeoJSON,\n    IconType,\n} from 'anycluster-client';\n\nimport * as  L from 'leaflet';\n\nexport {\n    ClusterMethod\n};\n\nexport class AnyclusterLeaflet extends AnyclusterClient {\n\n    currentZoom: number\n\n    constructor(map: any, apiUrl: string, markerFolderPath: string, settings: AnyclusterClientSettings) {\n        super(map, apiUrl, markerFolderPath, settings);\n\n        this.currentZoom = this.getZoom();\n\n    }\n\n\n    removeArea() {\n        if (this.map.hasOwnProperty(\"areaLayer\")) {\n            this.map.areaLayer.clearLayers();\n        }\n    }\n\n    addArea(geojson: IGeoJSON) {\n        if (!this.map.hasOwnProperty(\"areaLayer\")) {\n            this.createAreaLayer();\n        }\n\n        L.geoJSON(geojson, {\n            style: {\n                color: 'red'\n            }\n        }).addTo(this.map.areaLayer);\n\n    }\n\n    createClusterLayers() {\n        const kmeansLayer = L.layerGroup().addTo(this.map);\n        this.map.kmeansLayer = kmeansLayer;\n\n        // support geojson for grid cluster\n        const gridClusterLayer = L.layerGroup().addTo(this.map);\n        this.map.gridClusterLayer = gridClusterLayer;\n\n    }\n\n    createAreaLayer() {\n        const areaLayer = L.layerGroup().addTo(this.map);\n        this.map.areaLayer = areaLayer;\n\n    }\n\n    getMarkerIcon(cluster: KmeansCluster | GridCluster) {\n\n        // get the correct icon\n        const piniconObj = this.selectPinIcon(cluster);\n\n        let markerIcon;\n\n        if (this.iconType === IconType.exact && cluster.count > 1){\n            markerIcon = L.divIcon({\n                className: '',\n                html: `<div style=\"display:flex;align-items:center;justify-content:center;color:#FFF;font-weight:bold;fonts-size:12px;width:100%;height:100%;background-image:url('${piniconObj.url}')\">${cluster.count}</div>`,\n                iconSize: piniconObj.size,\n                iconAnchor: piniconObj.anchor,\n                popupAnchor: piniconObj.popupAnchor\n            });\n        }\n        else {\n            // create a leaflet icon\n            markerIcon = L.icon({\n                iconUrl: piniconObj.url,\n                iconSize: piniconObj.size,\n                iconAnchor: piniconObj.anchor,\n                popupAnchor: piniconObj.popupAnchor\n            });\n        }\n\n        return markerIcon;\n\n    }\n\n    _getLMarker(cluster: KmeansCluster | GridCluster) {\n        const markerIcon = this.getMarkerIcon(cluster);\n\n        const latLng = L.latLng(cluster.center.y, cluster.center.x);\n\n        const marker_options = {\n            icon: markerIcon\n        };\n\n        const marker = L.marker(latLng, marker_options);\n\n        return marker;\n    }\n\n    _drawLMarker(marker: any) {\n        this.addMarkerClickListener(marker);\n\n        marker.addTo(this.map.kmeansLayer);\n\n        this.markerList.push(marker);\n    }\n\n    drawKmeansMarker(cluster: KmeansCluster) {\n        let marker = this._getLMarker(cluster);\n        marker = this.setMarkerProps(marker, cluster);\n        this._drawLMarker(marker);\n    }\n\n    drawGridMarker(cluster: GridCluster) {\n        let marker = this._getLMarker(cluster);\n        marker = this.setCellProps(marker, cluster);\n        this._drawLMarker(marker);\n    }\n\n    drawCell(cluster: GridCluster) {\n        const count = cluster.count;\n\n        if (count == 1) {\n            this.drawGridMarker(cluster)\n        }\n        else {\n            const latLng = L.latLng(cluster.center.y, cluster.center.x);\n\n            const geojson = {\n                \"type\": \"Feature\",\n                \"count\": count,\n                \"geometry\": cluster.geojson,\n                \"properties\": {\n                    \"count\": count\n                }\n            };\n\n\n            const roundedCount = this.roundMarkerCount(count);\n\n            const fillColor = this.gridFillColors[roundedCount];\n            const strokeColor = this.gridStrokeColors[roundedCount];\n            const strokeWeight = 1;\n\n            const cell = L.geoJSON(geojson, {\n                style: {\n                    color: strokeColor,\n                    stroke: true,\n                    fillColor: fillColor,\n                    weight: strokeWeight,\n                    fillOpacity: 1,\n                }\n            });\n\n            // add properties required by anycluster to marker\n            cell.latitude = latLng.lat;\n            cell.longitude = latLng.lng;\n            cell.x = latLng.lng;\n            cell.y = latLng.lat;\n            cell.count = count;\n            cell.geojson = geojson;\n\n            this.addMarkerClickListener(cell);\n\n            cell.addTo(this.map.gridClusterLayer);\n        }\n\n    }\n\n    removeAllMarkers() {\n\n        // remove all the markers in one go\n        this.map.kmeansLayer.clearLayers();\n\n        if (this.map.hasOwnProperty(\"gridClusterLayer\")) {\n            this.map.gridClusterLayer.clearLayers();\n        }\n\n        this.markerList.length = 0;\n\n\n    }\n\n    addMapEventListeners() {\n        this.map.addEventListener(\"moveend\", event => this.getClusters());\n        this.map.addEventListener(\"zoomend\", event => this.removeAllMarkers());\n    }\n\n\n    getViewport(): Viewport {\n\n        const viewport = this.map.getBounds();\n\n        if (viewport.isValid()) {\n            const viewportJSON = {\n                \"left\": viewport.getSouthWest().wrap().lng,\n                \"top\": viewport.getNorthEast().wrap().lat,\n                \"right\": viewport.getNorthEast().wrap().lng,\n                \"bottom\": viewport.getSouthWest().wrap().lat\n            };\n\n            return viewportJSON;\n        }\n        else {\n            throw new Error(\"invalid viewport\");\n        }\n\n    }\n\n    getZoom(): number {\n        return this.map.getZoom();\n    }\n\n    setZoom(zoom: number): void {\n        this.map.setZoom(zoom);\n    }\n\n\n    setMap(x: number, y: number, zoom: number): void {\n        const center = L.latLng(y, x);\n        this.map.setView(center, zoom);\n    }\n\n    addMarkerClickListener(marker) {\n\n        const zoom = this.getZoom();\n\n        if (zoom >= this.maxZoom || marker.count == 1) {\n            marker.on(\"click\", (event) => {\n                this.onMarkerFinalClick(marker);\n            });\n        }\n\n        else {\n            marker.on(\"click\", (event) => {\n                this.markerClickFunction(marker.x, marker.y);\n            });\n        }\n    }\n\n}"],"names":["$kEX8F$anyclusterclient","require","$kEX8F$leaflet","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","module","exports","$daa68199c6ecee0a$re_export$ClusterMethod","$daa68199c6ecee0a$export$d28c3646e727c4c9","AnyclusterClient","constructor","map","apiUrl","markerFolderPath","settings","currentZoom","getZoom","removeArea","hasOwnProperty","areaLayer","clearLayers","addArea","geojson","createAreaLayer","geoJSON","style","color","addTo","createClusterLayers","kmeansLayer","layerGroup","gridClusterLayer","getMarkerIcon","cluster","piniconObj","selectPinIcon","iconType","IconType","exact","count","divIcon","className","html","url","iconSize","size","iconAnchor","anchor","popupAnchor","icon","iconUrl","_getLMarker","markerIcon","latLng","center","y","x","marker","_drawLMarker","addMarkerClickListener","markerList","push","drawKmeansMarker","setMarkerProps","drawGridMarker","setCellProps","drawCell","roundedCount","roundMarkerCount","fillColor","gridFillColors","strokeColor","gridStrokeColors","cell","stroke","weight","fillOpacity","latitude","lat","longitude","lng","removeAllMarkers","length","addMapEventListeners","addEventListener","event","getClusters","getViewport","viewport","getBounds","isValid","viewportJSON","getSouthWest","wrap","getNorthEast","Error","setZoom","zoom","setMap","setView","maxZoom","on","onMarkerFinalClick","markerClickFunction"],"version":3,"file":"main.js.map"}